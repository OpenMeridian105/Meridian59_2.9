// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
Player is Battler

// Don't instantiate this class--use things derived from it

constants:

   include blakston.khd
   include protocol.khd

   // Three minutes
   BOND_REPORT_INTERVAL = 1000 * 60 * 3
   
   // One minute
   DEATH_RIFT_INTERVAL = 1000 * 60

   KARMA_TUNE_A_INVERSE = 20
   KARMA_TUNE_B_INVERSE = 5

   // Meaning:   Time needed to completely empty a full stomach
   // Formula:   10000 / FOOD_USE_RATE
   // Currently: 833 sec = 13.9 min
   FOOD_USE_RATE = 12

   // Currently: 10 improves every 15-22 minutes.
   ADVANCE_TIMER_MIN =   900000
   ADVANCE_TIMER_MAX =   1320000
   ADVANCEMENT_LIMIT =   10

   PKPOINTER_TIME = 10*60*1000

   PLAYER_TRANSLATION_LEGS_MASK = 0xff
   PLAYER_TRANSLATION_LEGS_MUL = 1
   PLAYER_TRANSLATION_BODY_MASK = 0xff00
   PLAYER_TRANSLATION_BODY_MUL = 0x100
   PLAYER_TRANSLATION_Skin_MASK = 0xff0000
   PLAYER_TRANSLATION_Skin_MUL = 0x10000

   PLAYER_TRANSLATION2_HAIR_MASK = 0xff
   PLAYER_TRANSLATION2_HAIR_MUL = 1
   PLAYER_TRANSLATION2_ARMS_MASK = 0xff00
   PLAYER_TRANSLATION2_ARMS_MUL = 0x100

   BASE_NEED = 105

   // How steep is the curve for learning new levels of spells?
   //  A higher number means a greater slope (less points at low levels)
   POINTS_SLOPE = 7                 

   // Sets a reasonable lower level on the number of percents needed to
   //  advance to the next level of spells/skills.
   MIN_NEEDED_TO_ADVANCE = 75       
                                    
   // How many weapon swings until we get an improve check?
   SWINGS_PER_IMPROVE_CHECK = 75    

   // What's the length after having a player attacked before we let "mules" 
   //  cast on them again.  Currently set to 15 minutes.  Should be bigger 
   //  than logoff ghost time (currently 10 mins)
   ATTACKED_PLAYER_WAIT = 15 * 60

   // Damage is capped at piBase_Max_Health divided by this number.  Reduces
   //  newbie slaughter.
   MAX_HEALTH_DAMAGE_FRACTION = 3

   // Damage is overall capped to this number.  Gives a slight edge to people
   //  with higher hps.
   MAX_DAMAGE_PER_HIT = 30

   // What's the maximum stat we can have after modification?
   MAXIMUM_STAT = 70

   // how long to wait before sending another pvp notify sound (seconds)
   PVP_NOTIFY_DECAY = 5 * 60
   
   // How long since the last honor point change until a player is considered
   // inactive for the system? Measured in seconds, currently 60 days.
   USER_HONOR_INACTIVE_TIME = 60 * 60 * 24 * 60
   
resources:

   include player.lkod

   player_cant_broadcast = \
      "You can't broadcast a message--you don't have enough mana."
   player_broadcasts_off = "The broadcast channel is currently muted."
   player_squelched = "You are prevented from communicating for now."
   player_cant_send = \
      "You can't send this message--you don't have enough mana."
   player_silent_room = "Your telepathic abilities will not work here."

   player_use_broken = "You can't use %s%s--it's broken."
   player_cant_use = "You can't use that."
   player_using_already = "You are already using that."
   player_use_full = "You are using too many things like that already."
   player_use_full_hands = "Your hands are too full to use that."
   player_not_using = "You are not using that."
   player_not_holding = "You are not even holding %s%s."
   player_regbag_empty = "The reagent bag is empty."

   player_hit_color_blue = "~b"
   player_hit_color_none = ""

   player_token_reward = \
      "Let me give you %s%s as payment for returning the token."
   player_token_reward_heavy = \
      "Feel free to take the %s%s by your feet as payment for returning the "
      "token."
   player_improve_maxhealth = "~I~BYou suddenly feel a little tougher."
   player_improve_health_invigorate = \
      "~I~BYou feel invigorated by your success."
   player_spits = "You spit on the corpse of your unworthy foe."
   player_regain_angel = \
      "Due to your weakness, your protective guardian angel returns."
   player_no_angel = "You suddenly feel more vulnerable."

   player_join_faction = \
      "~IYour name is entered on the roll of membership for %s%s's political "
      "faction."
   player_lost_token_hall = \
      "The token refuses to enter the guild hall and writhes in your hands.  "
      "You cannot hold it."
   player_lost_token_arena = \
      "The token refuses to enter the arena and writhes in your hands.  "
      "You cannot hold it."
   player_lost_token_survival = \
      "You suddenly lose your grasp on the token as you are pulled "
      "across dimensions."
   player_lost_token_generic = \
      "The token refuses to enter this room and writhes in your hands.  "
      "You cannot hold it."
   player_intrigue_shut = "~IThe Royal Court no longer needs your services."
   player_lost_intriguing = \
      "~IYou doubt you are still worthy of notice by the Royal Court."
   player_faction_time = \
      "~IYour liege is no longer convinced of your loyalty. You should visit "
      "your liege at court again."
   player_faction_attacked = \
      "~BYou have attacked a member of your own faction!"
   player_non_intriguing_attacked = \
      "~BYou have displeased your liege by attacking a potential future ally!"
   player_unfactioned = \
      "~IYour liege has no use for one such as you, lacking in prowess or "
      "devotion.  Your name has been stricken from the roll of membership.~n"

   player_cancel_rescue = \
      "~IYour aggression halts your attempt to escape from the "
      "current situation."

   player_cancel_rescue_phase = \
      "~IThe protective magics that might have rescued you instead "
      "snap and fade as you phase out of existence."
   player_cancel_rescue_newowner = \
      "~IYour change of location disrupts Shal'ille's attempt to whisk "
      "you to safety."

   player_temp_safe = \
      "~I~BYou feel your guardian angel is near to you."
   player_temp_safe_end = \
      "~I~BYou feel your guardian angel has departed once more."

   player_improved = "~I~BYou have improved in the art of %s.~n ~B[%i%%] "
   player_improved_wav_rsc = imp.ogg
   player_aggressor = "Shal'ille frowns upon your unprovoked attack."
   player_aggressor_minion = \
      "Shal'ille frowns upon your unprovoked attack on %s%s's minion."
   player_safety_caught = \
      "Hey!  You almost hit %s%s!  Good thing your safety was on!"
   player_safety_caught_minion = \
      "Hey!  You almost hit %s%s's minion! Good thing your safety was on!"
   player_own_minion = \
      "You cannot attack your own minion!"
   player_cannot_attack_follower = \
      "You cannot attack this poor soul in need of guidance!"
   player_safe_server = \
      "You are not allowed to attack other players in this world."
   player_no_enter = \
      "Your guardian angel holds you back and prevents you from entering here."
   player_assgame_soon = \
      "~kRoq tells you, \"~IA new Assassin's Circle shall be initiated "
      "shortly.\""

   player_tougher_wav_rsc = tougher.ogg
   player_missed_something_wave_rsc = swordmis.ogg
   player_killed_something = "You killed %s%s."
   player_killed_player = \
      "You have killed another player and have been branded a murderer."
   player_wanted_now = "You are now wanted for the murder of %s%s."
   player_haunted_on = "%s%s's violent death summons forth a revenant."
   player_haunted_off = "The revenant is satisfied."
   
   player_training_inform = "You now have ~B%i~B training points!"
   player_reached_maxtraining = \
      "You now have ~B%i~B training points and can not gain any more!  "
      "Cast the Meditate spell and say the name of a spell or skill out loud "
      "to use your points to train it."
   player_gained_training = "You have gained ~B%i~B training points!"
   player_spent_training = "You have spent ~B%i~B training points!"
   player_logon_bonus = \
      "You have received your daily training bonus of ~B%i~B points!  "
      "Come back tomorrow for more!"
   player_experience_gained = "You have gained ~B~s%i~v~B XP."
   player_experience_lost = "You have lost ~B~r%i~B~v XP!"

   player_unbound_energy_wiped = "The volatile energy surrounding you "
      "dissipates in the violently twisting aether."
   player_unbound_energy_gained = "You gather ~B~t%i~v~B unbound energy "
      "from your fallen enemy. (~B~t%i ~v~Btotal)"
   player_unbound_energy_lost = "You channel ~B~t%i~v~B unbound energy "
      "to shape your spell. Your remaining unbound energy is ~B~t%i~v~B."
   player_unbound_energy_wasted = "Your mind is too preoccupied with your "
      "recent encounter to make any use of the subtle energies dispersing "
      "before your eyes."

   player_cant_hit_optout = \
      "You have opted not to participate in player versus player combat."
   player_cant_hit_optout_minion = \
      "This creature is the servant of another player - you have opted not "
      "to participate in player versus player combat."
   player_cant_hit_newbie = \
      "You are not yet experienced enough to fight other players."
   player_cant_hit_newbie_minion = \
      "This creature is the servant of another player - you are not yet "
      "experienced enough to fight it."
   player_guardian_angel = \
      "A guardian angel whispers to you, \"You may not attack %s%s.\""
   player_kill_zone = \
      "Your guardian angel whispers to you, \"I cannot protect you here.\""
   player_angel_rejoins = "Your guardian angel rejoins you."
   player_lose_node = "You lose your connection to the mana node in %s."

   player_hit_immunity =  "%s%s%s laughs off your pitiful blow."
   player_hit_resisted = "%s%s%s shrugs off your attack."
   player_hit_anti_resisted = "%s%s%s staggers backwards from the blow."
   player_hit_anti_immunity = \
      "%s%s%s convulses and seems to be suffering badly."
   
   player_immune_to_hit = "%sMysteriously, you feel almost no pain!"
   player_resists_hit = "%sMuch of the pain fades away."
   player_anti_resists_hit = \
      "%sThe pain seems to resonate and grow inside you."
   player_anti_immune_to_hit = \
      "%sYour body is wracked with pain of incredible magnitude."
   
   player_was_missed = "%s%s%s misses you."
   player_was_hit = "%s%s%s hits you."
   player_was_slashed = "%s%s%s slashes your side, leaving a nasty cut."
   player_was_bludgeoned = "%s%s%s bludgeons you, causing a large bruise."
   player_was_pierced = "%s%s%s slyly pierces you while you were distracted."
   player_was_thrusted = "%s%s%s skewers you with a deft thrust.  Sluish!"
   player_was_burned = "%s%s%s's fire flares brightly, leaving you charred."
   player_was_shocked = "%s%s%s grins as a jolt of electricity hits you."
   player_was_frozen = "%s%s%s stings you with a jolt of cold."
   player_was_quaked = "%s%s%s's tremors shake you about."
   player_was_holyhit = "%s%s%s hits you with a jolt of purity."
   player_was_unholyhit = \
      "%s%s%s hits you, and you feel your soul has been invaded."
   player_was_stung = "%s%s%s dances away after having stung you badly."
   player_was_bitten = "%s%s%s bites you several times, leaving you bloody."
   player_was_clawed = "%s%s%s rends your flesh with razor sharp claws."
   player_was_punched = "%s%s%s hits you with a solid punch."
   player_was_kicked = "%s%s%s slams a foot into your gut."

   player_attack_out_of_range = "%s%s is too far away to hit with %s%s."
   player_attack_out_of_punch_range = "You can't reach %s%s with your %s."
   player_attack_out_of_spell_range = "%s%s is out of range."
   player_attack_not_in_view = "You can't see your selected target."

   player_no_target_self = "You cannot attack yourself."
   player_no_target_self_spell = "You cannot cast this spell on yourself."

   player_cant_apply = "You can't use %s%s on other things."

   player_wave_hit = hit.ogg

   // These are now old resources..... here in case we want to de-hack...
   player_desc_guild = "%q of %s%q."
   player_no_guild = "No known guild affiliation."
   player_faction_duke = "A staunch servant of Duke Akardius.\n"
   player_faction_princess = "Firmly loyal to Princess Kateriina.\n"
   player_faction_rebel = "A freedom fighter supporting Jonas.\n"
   player_faction_neutral = \
      "Not a court vassal, yet affected by the Meridian Council."
   player_not_intriguing = "Not yet concerned with affairs at the Royal Court."

   player_dot = "."

   // Master fixed info resource.
   player_fixed_info = "%r%r%s%s%s%r%s%q%r"

   // Hometown strings.
   player_hometown_rsc = "%s%s%s%q%s\n"
   player_citizen_barloque = " has been a Barloquan"
   player_citizen_tos = " has been a citizen of Tos"
   player_citizen_cornoth = " hailed from Cor Noth"
   player_citizen_jasper = " has called Jasper home"
   player_citizen_marion = " has been a Marionite"
   player_citizen_raza = " is of Raza"
   player_citizen_kocatan = " has lived in Ko'catan"
   player_citizen_unknown = " has wandered"
   player_of = " of "
   player_for = " for "
   player_years = " years."
   player_year = " year."
   player_under_one_year = " less than a year."

   player_guild_rsc = "%q%s%s%q.\n"
   player_is_holding = "%s is holding %s%s.\n"
   player_is_wearing = "%s is wearing %s%s.\n"
   player_donation_title = "Noble benefactor of Meridian in %q."
   player_donation_separator = ", "
   player_is_justicar = "Elected Royal Justicar of the Meridian.\n"

   player_known_for_mastery = "Known far and wide for mastery of "
   player_and = " and "
   player_magics = " magics"
   player_skills = "weaponcraft skills"

   player_dagger_shatters = "Your black dagger crumbles into dust."

   player_desc_enchanted_none = "%q"
   player_desc_enchanted = "%s has %s%s.\n\n%s"
   
   player_too_full = "You are too full to eat."
   player_too_full_drink = "You are too full to drink."

   player_to_hunters = "You detect that %s%s could be found somewhere around %s"

   player_dead_male_icona_rsc = playerXa.bgf
   player_dead_male_iconb_rsc = playerXb.bgf
   player_dead_female_icona_rsc = heraXa.bgf
   player_dead_female_iconb_rsc = heraXb.bgf
   
   player_dead_male_name_rsc = "dead male body"
   player_dead_female_name_rsc = "dead female body"
   
   playerm_death_wav = pdeath.ogg
   playerf_death_wav = pdeathf.ogg

   player_token_death = \
      "As you die, the token pulsates, and you feel an odd sensation..."

   player_dance = \
      "You swallow your pride and get down to the ditty in your head."
   player_cant_dance = \
      "You can't dance, all the stuff in your hands is cramping your style!"
   player_cant_dance_resting = \
      "You're sitting right now.  Let's not take this \'getting down\' stuff "
      "too literally, ok?"
   player_stop_dance = \
      "You lose your rhythm and settle out of your dancing frenzy." 

   player_wave = "You wave your hand."
   player_point = "You point."

   player_window_overlay_hand = povhand.bgf
   player_window_overlay_glow = povglow.bgf

   player_male_icon_rsc = bta.bgf
   player_female_icon_rsc = btb.bgf

   player_legs_a_rsc = bfa.bgf
   player_legs_b_rsc = bfb.bgf

   player_rightarm_a_rsc = bra.bgf
   player_rightarm_b_rsc = brb.bgf

   player_leftarm_a_rsc = bla.bgf
   player_leftarm_b_rsc = blb.bgf

   // hair for Rob
   player_toupee_q_rsc = ptq.bgf

   player_sound_learn_spell = splearn.ogg

   player_angel = "Your guardian angel"
   intrigue_ambassador = "Baron Springer of Cor Noth Township"

   player_newbie_honor_string = "This soul is new to the lands of Meridian 59.\n"

   player_newbie_commands = \
      "\n~BBasic Commands for Meridian 59:~B\n"
      "~IUse these mouse and keyboard commands to interact with the world.\n"
      "These are the default commands.  You can change the keyboard commands "
      "by going to the menu item~I ~wGame > Configuration.\n"
      "~rright-click on an object ~b- examines an object, letting you see "
      "more detail.  Right-click on the sign in this area to learn more.\n"
      "~rspace bar ~b- go through doors, like the blue door to the north.\n"
      "~rE key ~b- attack monsters.  You may want to wield a weapon first!\n"
      "~n~IType the following commands (red text) into the text bar below. "
      "You can press the RETURN key to move to the chat window.~I\n"
      "~rsay (message) ~b- send a message to everyone in the same room.\n"
      "~rtell (player name) (message) ~b- Send a message to a single player "
      "in private.\n"
      "~rbroadcast (message) ~b- send a message to everyone that is logged "
      "on.\n"
      "~rwho ~b- shows a list of all the people logged into the game right "
      "now.\n"
      "~rmail ~b- opens up your mail folder.  Read the messages from your "
      "guardian angel!\n"
      "~rhelp ~b- opens our web-based help pages.  It will take a few "
      "seconds to load.\n"

   player_safety_on_mail = \
      "Your safety is currently on, meaning you cannot cast hostile spells or "
      "attack innocent players."
   player_safety_off_mail = \
      "Your safety is currently off.  If you do not wish to attack innocent "
      "players, I heartily recommend that you turn it on."

   player_ready_to_kill = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword against other "
      "players if you so desire.  It is with a heavy heart that I take my "
      "leave of you, but I trust that you will do fine without me."
      "\n\n"
      "You also have many other rights and responsibilities available to "
      "you.  You can now join a guild with other friends.  Guilds are a good "
      "way to gain protection from those that would do you harm.  Joining a "
      "good guild will make the difference between merely surviving or "
      "thriving in the world.  Guilds can also get into wars with other "
      "guilds, so be careful that you don't make too many enemies."
      "\n\n"
      "I must warn you that engaging in lethal combat against other players "
      "may soil your good name.  If you strike an innocent, or cast "
      "a spell which harms him, you may be branded an outlaw, an onus which "
      "only fades upon your death.  If you slay an innocent in cold blood, "
      "you will be blacklisted as a murderer, and this is a weight upon your "
      "soul which does not easily depart.  This puts you at risk:  since "
      "murderers and outlaws are not innocents, one may attack them without "
      "being named a murderer or an outlaw."
      "\n\n"
      "Also note that assisting an outlaw or murder by casting helpful spells "
      "upon them will brand you an outlaw in the eyes of society.  You must "
      "choose your friends and your enemies well!"
      "\n\n"
      "If you do not wish to engage in the unsavory practice of attacking "
      "innocents or assisting the unlawful, it is heartily recommended that "
      "you do not enable attacking innocents in your game preferences.  This "
      "is also called your \"safety\" since it keeps you safe from being "
      "outcast as an unlawful outlaw or murderer.  While your safety is on, "
      "you are not permitted to either attack innocents or cast spells that "
      "are hostile to them.  This can be crucial when one stray sword blow "
      "can make you an outlaw.  However, rest assured that you will always be "
      "permitted to strike outlaws and murderers, since it is crucial that "
      "you always have the option of defending yourself from their "
      "treacherous ways."
      "\n\n"
      "%s"
      "\n\n"
      "Finally, some last bits of advice as I depart.  Do not despair if "
      "you are sent to the underworld by some monster or even another "
      "player.  Death is part of the cycle, and learning to recover from "
      "death is important.  Put some items away in the vault in Barloque for "
      "times when you find yourself killed and unable to get items from your "
      "corpse.  Also, ask politely for assistance and you will often find "
      "someone willing to lend a helping hand.  Make some friends and you "
      "will find that nothing is truly beyond your reach."
      "\n\n"
      "Have fun in Meridian!"
      "\n\n"
      "  -- Your guardian angel"

   player_ready_to_guild = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword with fellow "
      "players and engage in guild politics.  It is with a heavy heart that I "
      "take my leave of you, but I trust that you will do fine without me.\n\n"
      "%s\n\n"
      "  -- Your guardian angel"

   player_tutorial_mail = "Subject: You're doing well for yourself.\n"
      "It's nice to see that you seem to be doing well.  "
      "I thought I might take this time to explain some finer points of "
      "the world of Meridian to you."
      "\n\n"
      "There are a variety of spells and skill schools that you can "
      "advance in.  However, learning from all spell and skill schools "
      "dilutes your focus, and slows down your learning.  The more you "
      "narrow your focus onto one or two particular spell schools, the "
      "quicker you will advance in that spell school, and the sooner you "
      "will be offered new spells in that school.  Stray from the path, "
      "however, and you will find that teachers may not offer you spells that "
      "they had previously offered you.  Thus, you must choose very early on "
      "whether or not you prefer the versatility of being able to pull from a "
      "multitude of low level spells and skills, or the power of excelling in "
      "one or two.  Therefore, be sure that you examine any potential ability "
      "before you acquire it!"
      "\n\n"
      "No advancement is more prized than increasing your endurance by "
      "gaining health points.  Note you that those who go toe to toe with "
      "monsters are more likely to advance in health than those who stay "
      "safely out of harm's way, slinging fireballs.  Also, attacking "
      "insignificant foes earns you no points for valor, and offers no hope "
      "of advancement."
      "\n\n"
      "Your vigor is crucial - it helps determine how fast your health and "
      "mana returns to you - a tired warrior will find these resources "
      "fleeting.  Vigor can be restored either through needed rest or a "
      "hearty meal."
      "\n\n"
      "When you reach 50 health, I will no longer be able to protect you from "
      "combat with other players.  If you do not wish to partake in player-"
      "versus player combat, you can opt-out by visiting the Temple of "
      "Shal'ille (north from the town of Marion) and following the directions "
      "on the sign placed there."
      "\n\n"
      "I congratulate you on your recent success.  I know the bards will sing "
      "of your future exploits."
      "\n\n"
      "  -- Your guardian angel"

   player_first_mail = "Subject: Welcome!\n"
      "Welcome to Meridian 59!  I hope you enjoy the exciting world waiting "
      "for you!"
      "\n\n"
      "You have entered an on-line community, meaning that you may well be "
      "playing with several other players at a time.  Making allies and "
      "dealing with potential enemy players is as much a part of Meridian 59 "
      "as killing monsters.  We hope you feel at home in your new online "
      "community."
      "\n\n"
      "I am your guardian angel, and thus I shall protect you from the spells "
      "and swords of other players for a short time.  Use this time to "
      "acquaint yourself with the world, and to gather your resources.  Know "
      "you that the shops of the land are always safe zones, and the inns are "
      "good places to rest and recover your strength."
      "\n\n"
      "Spells and skills will almost certainly be crucial to your success.  "
      "Note that a young warrior's skills are stronger than a inexperienced "
      "wizard's spells, but at the higher end, the sorcerer is far more "
      "formidable to deal with given his variety of options.  The apprentice "
      "will almost always need the steady sword of the mercenary by his side "
      "to get that far, so find comrades who complement your abilities."
      "\n\n"
      "You can learn a lot by talking to the little people: the shopkeepers, "
      "the bankers, the innkeepers.  Ask them for help.  Sometimes, they "
      "may even wish for you to run an errand for them if you ask."
      "\n\n"
      "No matter if warrior or mage, every adventurer needs a town he can call "
      "home. New souls to these lands find a temporary refuge in Raza, but only "
      "few feel a true connection to this place. An adventurer's choice of home "
      "has far-reaching consequences after all - and Raza may not be the most "
      "beneficial one. For this reason, you may want to set off on a quest to "
      "find a fitting base of operations for your future endeavors and declare "
      "one of the cities in Meridian your home.  There should be no doubt that "
      "such a choice must be carefully considered. It might be helpful to seek "
      "the locals' advice and ask them for their opinion on the various cities "
      "of the realm before you make your decision a final one. Once you have "
      "come to a conclusion, it is time to prepare for a journey to the city of "
      "Cor Noth. There, you will find the Hall of Genealogy, where you can vow "
      "your allegiance to a city of your choosing and become a permanent "
      "citizen, with all of the attached benefits - and drawbacks."
      "\n\n"
      "Death is unkind to you - avoid it!  A death can make you weaker, and "
      "all of your possessions are left where you met your demise, where any "
      "scavenger, human or otherwise, may take it as they please.  Best that "
      "you join an ally on your travels that they may gather your valuables "
      "should you meet such an unfortunate fate."
      "\n\n"
      "Lastly, if you wish to leave this land for a bit, it is recommended to "
      "log off in a safe place, such as an Inn or Adventurer's Hall.  For "
      "brief exits from the game, you can use the spell Phase to disconnect "
      "you from this plane of existence, rendering you unable to be harmed.  "
      "However if you Phase or log off without your guardian angel for longer "
      "than 8 minutes for innocents (3 minutes for murderers), you will take "
      "a penalty (dropping item(s) and losing skill and spell points) and be "
      "sent back to the last safe location you visited."
      "\n\n"
      "We hope that you enjoy your stay in our land."
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail = "Subject: Death\n"
      "It saddens me that you fell in combat and into the underworld.  It is "
      "a dangerous life as an adventurer, as you have undoubtedly learned."
      "\n\n"
      "Since you are so young, I have pleaded to the gods that you should be "
      "spared some of the penalty for death.  Normally, the shock of leaving "
      "the underworld would reduce your maximum health and penalize you a "
      "small part of the spells and skills you have learned so far.  I will "
      "spare you the cost of your health, and only a few of your spells and "
      "skill will be reduced after you leave the underworld."
      "\n\n"
      "You will also notice that your possessions are gone.  They were left "
      "behind at your corpse where you died.  The items will only remain "
      "there a limited amount of time, so you must act quickly."
      "\n\n"
      "If you don't know where you died, then you should broadcast for help.  "
      "Type \"broadcast Can someone help me find my items?\" right now and "
      "watch for someone to respond to you.  Tell that person what you can "
      "remember about where you were fighting.  Often you will find someone "
      "kind to help you, or they might even help you get better equipment "
      "than you had before.  There are many kind souls in this land"
      "\n\n"
      "If you know where you died, the portal archways in the underworld will "
      "take you directly to the inns of the cities of the mainland.  The "
      "large rip in space in the western side of the underworld is often the "
      "quickest way back.  It randomly switches between the different inns.  "
      "Look (right-click by default) the portal to see where it leads.  If it "
      "leads to the place you want to go, enter it quickly!  It will not lead "
      "there for very long."
      "\n\n"
      "Do not be discouraged!  Many powerful warriors have stumbled into the "
      "fires of the underworld.  What makes them powerful is that they "
      "decided to fight on, gaining power and ability to vanquish the "
      "terrible monsters that felled them before!"
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail_notice = \
      "Your guardian angel has sent you a special game mail on how to cope "
      "with death.  Type ~Imail~I and read the last game mail from your "
      "guardian angel."

   player_intrigue_mail = "Subject: Invitation to visit the Royal Court\n"
      "Oh, most worthy adventurer.  Tales of your exploits have been oft told "
      "here at the Court, and recently, the Meridian Council itself declared "
      "you to possess considerable promise. Perhaps someday you will be "
      "given the honor of studying and guarding one of the Five Tokens."
      "\n\n"
      "The Council serves our fair land by using their acquired knowledge to "
      "benefit daily life. For the most part, they are honest and impartial "
      "in their decisions - guided by the Priestess of Shal'ille. However, "
      "Duke Akardius and Princess Kateriina and their factions of followers "
      "try to sway the Council down differing paths:"
      "\n\n"
      "Duke Akardius wishes for more of the Council's energies to be used for "
      "the benefit of commerce and the study of lore, while the Princess "
      "seeks their aid in advancing knowledge of magic. Both believe their "
      "path is the way to reduce the plague of monsters which terrify the "
      "land these days."
      "\n\n"
      "There are also boorish tales of a third faction of rebels.  They "
      "are dissatisfied with the current political climate and seek to "
      "bring their leader to rule our lands.  I do not know much about "
      "these rebels, nor do I care to learn anything.  You are on your own "
      "if you wish to learn about them."
      "\n\n"
      "Should you desire to join any of these factions, seek the Liege. "
      "As a faction member, you can help to influence the Council yourself, "
      "and share in the benefits of belonging to the party in power. You will "
      "need to demonstrate fealty to your Liege on a regular basis to "
      "keep your name on the rolls. Even if you join neither faction, you "
      "will still be influenced by the Council's decisions - as are all."
      "\n\n"
      "Fair partings, and perhaps we will someday meet at the court."
      "\n\n"
      "----Baron of Cor Noth Township, Gerah Springer."

   player_Debug_learnpoints = "%i out of %i points used."

   player_Debug_playercanlearn = \
      "Do the math for %s to learn a %i level spell from the %s school.  "
      "%i points from spells already known (%i from this school).  Intellect "
      "reduces the needed by %i for a total of %i percent needed.  Currently "
      "possesses %i percent to compensate for the need."

   player_Debug_playercanlearn_scarcity = \
      "Due to the scarcity of spells at that level in that school, "
      "the need has been reduced to %i more points."
   
   player_Debug_nokarma = "%s cannot learn %s due to karma restrictions."
   player_Debug_noway = "It is impossible for %s to ever get the %s spell."

   player_sound_sword1 = sword1.ogg
   player_sound_sword2 = sword2.ogg
   player_sound_sword3 = sword3.ogg

   player_sound_metal1 = swrdmtl1.ogg
   player_sound_metal2 = swrdmtl2.ogg
   player_sound_metal3 = swrdmtl3.ogg

   player_sound_hit_monster_flesh1 = fhit1b.ogg
   player_sound_hit_monster_flesh2 = fhit2b.ogg
   player_sound_hit_monster_flesh3 = fhit3b.ogg

   player_sound_hit_monster_leather1 = lhit1b.ogg
   player_sound_hit_monster_leather2 = lhit2b.ogg
   player_sound_hit_monster_leather3 = lhit3b.ogg

   player_sound_hit_monster_metal1 = mhit1b.ogg
   player_sound_hit_monster_metal2 = mhit2b.ogg
   player_sound_hit_monster_metal3 = mhit3b.ogg

   // in increasing order of agony
   player_sound_male_ouch1 = ouchm1.ogg
   player_sound_male_ouch2 = ouchm2.ogg
   player_sound_male_ouch3 = ouchm3.ogg
   player_sound_male_ouch4 = ouchm4.ogg

   player_sound_female_ouch1 = ouchf1.ogg
   player_sound_female_ouch2 = ouchf2.ogg
   player_sound_female_ouch3 = ouchf3.ogg
   player_sound_female_ouch4 = ouchf4.ogg

   player_admin_added_spell = "Spell added."
   player_admin_modified_spell = "Spell modified."
   player_admin_removed_spell = "Spell removed."
   player_admin_added_skill = "Skill added."
   player_admin_modified_skill = "Skill modified."
   player_admin_removed_skill = "Skill removed."

   player_logged_on_wav_rsc = player_login_or_out.ogg
   player_logged_off_wav_rsc = player_logout2.ogg

   death_rift_stayed_too_long = \
      "Having lingered too long while still alive, you find "
      "yourself ejected back into reality!"

   player_monster_attack_string = "monster attack"
   player_no_weapon_string = "no weapon"

   cannot_attack_ally = "You can't attack %s, %s's your ally!"
   cannot_attack_guildmate = "You can't attack %s, %s's your guildmate!"

   group_experience_rsc = \
      "You absorb a small amount of the energy released "
      "from %s's slaying of the %s."

   rod_gained_charge_msg = \
      "You sense that at least one of your magic items gained a "
      "charge from the released energy of your kill."
   rods_recharged_by_safe_place_msg = \
      "This place of safety has recharged your magical rods."

   player_truced = "Shal'ille's magic compels you to respect the truce."

   Jig_cannot_attack = \
      "It wouldn't feel right to attack %s%s while you two are "
      "dancing so well together!"

   phased_out_cant_use = \
      "You try to use your item, but your phased hands pass right through it."
   cannot_attack_phased_self_rsc = \
      "You can't attack anyone while phased out."
   cannot_attack_phased_player_rsc = \
      "Your strike would just go right through someone who is phased out."
   phase_fatigue_cleared = \
      "This area of peace lifts your phase fatigue."
   phased_player_description = \
      "This is the ghosted body of %q, whose consciousness has travelled to "
      "another plane of existence."
      
   bad_line_of_sight = \
      "Your hindered line of sight makes a successful hit more difficult."

   player_already_leader = \
      "You already have a mercenary under your command.  You will have to "
      "let them know that you need to ~Ipart ways~I, before you can take "
      "another under your tutelage.  "

   pvp_notify_wav = gong.ogg

   player_bonus_tp = "You are awarded ~B~k%i~v~B bonus training points for "
      "your impressive accomplishment!"

   player_honor_gain_kill = \
      "You gain %i honor points from your victory over %s."
   player_honor_gain_assist = \
      "You are awarded %i honor points for your role in %s's death."
   player_honor_loss_death = \
      "Your defeat in battle costs you %i honor points."

   player_honor_rank_1 = "PvP Rank: General\n"
   player_honor_rank_2 = "PvP Rank: Commander\n"
   player_honor_rank_3 = "PvP Rank: Knight\n"
   player_honor_rank_4 = "PvP Rank: Squire\n"
   player_honor_rank_5 = "PvP Rank: Aspirant\n"

   player_honor_rank_1_alt = "PvP Rank: Reaper\n"
   player_honor_rank_2_alt = "PvP Rank: Slayer\n"
   player_honor_rank_3_alt = "PvP Rank: Widowmaker\n"
   player_honor_rank_4_alt = "PvP Rank: Cutthroat\n"
   player_honor_rank_5_alt = "PvP Rank: Thug\n"

   player_honor_title_on = "Your honor rank is now being displayed."
   player_honor_title_off = "Your honor rank is no longer being displayed."
   player_honor_title_alt = "You're now displaying your alternate honor rank."

classvars:

   viHand_space = 2
   viBody_space = 1

   viQuiver_space = 1
   viNeck_space = 1
   viHead_space = 1
   viLeg_space = 1

   viFinger_space = 2
   viGauntlet_space = 1

   // Our actual max is this plus a bonus for might.
   viBulk_hold_max = 1700
   viWeight_hold_max = 1700

properties:

   vrIcon = player_male_icon_rsc

   poSession
   pbLogged_on = FALSE

   // This is used to determine raises in hit points only.
   poKill_target = $
   piXP_total = 0

   // This keeps track of training points that players accumulate when 
   // killing mobs.
   piTraining_points = 0

   // This keeps track of unbound energy, which isused for free spell casts.
   piUnbound_energy = 0

   // This keeps track of when we've last received our daily training points.
   piReward_timestamp = 0

   // For those crazy people who stay logged on 24/7 and may forget to relog
   // and cash in on their daily training points, we grant the points every 24
   // hours of online time.
   ptReward_timer = $

   // Flags for various character attributes.
   piFlags = 0
   piFlags2 = 0
   piFlags3 = 0

   // Set of flags with player preferences.
   piPreferences = CF_DEFAULT_PREF

   // player starts unguilded--doesn't do much yet
   poGuild = $
   piGuildRejoinTimestamp = 0

   // Evil twin object
   poEvilTwin = $

   // list of spells we know, in the form of a 3-part compound
   plSpells = $

   // list of skills we know, in the form of a 3-part compound
   plSkills = $

   // A list of the total percentage points the player has in the various
   //  spell and skill schools.
   plSchools = $

   // A list of the weighted casts the player has made in various schools.
   // Weighted because higher level spells will contribute more points to
   // the total. Used to give bonuses to improving spells.
   // See spell.kod for details.
   plSchoolCasts = $

   // The number of swings with the current weapon
   piWeaponSwings = 0

   // A compound of if the player can advance and the WC proficiency needed
   // to use the weapon. The proficiency number is the number / 1000, while
   // the bonus to advance is the number % 1000.
   piWeaponInfo = 0

   // converted guild commands list to a bitvector.
   piGuild_commands = 0

   piLast_restart_time = 0

   // Permanent character base stats.
   piMight = 0
   piIntellect = 0
   piStamina = 0
   piAgility = 0
   piMysticism = 0
   piAim = 0

   // Modifiers to those base stats.
   piMightMod = 0
   piIntellectMod = 0
   piStaminaMod = 0
   piAgilityMod = 0
   piMysticismMod = 0
   piAimMod = 0

   //// Variable character values.

   // All battlers use the same properties now, so
   // piHealth and piMax_health have been moved to battler.
   // The same is true for mana and vigor.
   // The player sees piMax_health in their client.
   // piBase_Max_Health is their base without any modifiers
   // IMPORTANT NOTE: For higher accuracy, a battler's current health 
   //(and only current health) is inflated by a factor of 100. Doing so 
   // avoids truncation errors but is not revealed to users in any way.
   // piBase_Max_Health can now go above 150, and is equivalent to
   // "player level". Max HP is determined by GetBaseMaxHealth, which
   // is bound to the game's max HP and should be called when this
   // number is needed. Greater/less/equal comparisons can still be
   // made directly with piBase_Max_Health, but it may not be an
   // accurate measure of max HP. Rationale: provide bonuses and room
   // for expansion over the classical max HP without introducing a
   // separate "max_level" variable that in the vast majority of cases
   // would equal piBase_Max_Health.
   piBase_Max_Health = 20

   // piKarma is measured in hundredths of karma units
   piKarma = 0

   // Percent stomach is full.
   piStomach = 0

   // This replaces a timer
   piTimeLastStomachUpdate = 0

   // stuff in use
   plUsing = $

   // Timers 
   ptAdvancement = $
   ptUnboundEnergy = $

   // List of objects adding overlays to us.
   plOverlays = $

   // List of objects with window overlays.
   plWindow_overlays = $

   // Object that set our icon (usually armor)
   poIcon_set = $

   // Object that ditched our hair (usually helmets)
   poHair_remove = $

   // object that set our legs (usually pants)
   poLegs_set = $
   poArms_set = $

   // Object that sets our entire look (overrides any part changes)
   poIllusion_set = $

   piBody_translations = 0
   piBody_translations2 = 0

   // Default: green shirt, brown pants.
   piDefault_Clothes = 143 | (121 * PANTS_MUL)

   // Light source at player.
   // Default strength of light source at player is 5
   piLight = 5

   // Attack modifiers to attack roll & damage (includes items & spells)
   plAttack_modifiers = $

   // Defense modifiers to defense roll & damage (includes items & spells)
   plDefense_modifiers = $

   // Gear preferences for 'set' and 'loadout'
   plLoadout_list = $

   piGender = GENDER_MALE

   // The user's string description, typed when created (and editable in game).
   psPlayerDescription = $

   // graphics stuff

   prLegs = player_legs_a_rsc
   prRight_arm = player_rightarm_a_rsc
   prLeft_arm = player_leftarm_a_rsc

   prHead = charinfo_head_ax_icon
   prEyes = charinfo_eyes_ax_icon
   prMouth = charinfo_mouth_ax_icon
   prNose = charinfo_nose_ax_icon
   prToupee = charinfo_hair_cd_icon

   // Animation type.  If none, then use piAction
   // piAnimation should be PANM_NONE in between KOD calls.
   piAnimation = PANM_NONE 

   // Action, such as "smiling", that player is currently doing
   piAction = 1

   // piNodeList is a bitvector of all of the mana nodes that the player has
   //  successfully melded with.  List of available nodelists in the
   //  blakston.khd constants file.
   piNodeList = 0

   piBorn_year = 0

   // Faction stuff.
   piFactionEffect = 0
   piFaction = FACTION_NEUTRAL
   piFactionServiceUpdate = 0
   piFactionTimeUpdated = 0
   ptFactionTimer = $

   piKill_count = 0
   piKill_count_decay = 0
   piJustified_kill_count = 0

   // Last time the player murdered someone.
   piTimeLastMurder = 0

   ptAttackTimer = $

   piLastTimeAttacked = 0

   plHonor = $

   piMonsterChasers = 0

   poBondedItem = $
   ptBondedItemReport = $

   piLastDeathTime = 0

   // Temp safe timer for giving players a period of safety after a death
   ptTempSafe = $

   // Measures how long we have to wait before we're rescued.
   ptRescue = $

   // piTimeAttackedPlayer records the last time we attacked a player.
   //  This is used in conjunction with the constant ATTACKED_PLAYER_WAIT
   //  to disallow casting by angeled "mules".
   piTimeAttackedPlayer = 0 

   // piTimeAttackedByPlayer records the last time we were attacked by a player.
   piTimeAttackedByPlayer = 0
   
   // piDeathcost is used to tell the underworld what percent of normal
   //  penalties to apply when the players leaves.  FALSE means no penalties.
   piDeathCost = 100

   // List of integer years in which the player has donated money to the game.
   // Used to construct a string for their description.
   plDonationYears = $

   // Some spells let players choose teleport destinations by binding a location.
   piBound_Room = $
   piBound_row = 0
   piBound_col = 0
   piBound_fine_row = 0
   piBound_fine_col = 0
   piBound_angle = ANGLE_SOUTH

   // Is the player currently using a Death Rift spell?
   ptDeathRiftTimer = $

   // This list keeps track of selfcast buffs for passive improvement.
   plPassiveImprovement = $

   // Crystalize Mana Surge timer
   ptCrystalizeManaSurgeTimer = $

   // Players will naturally fall out of groups if they aren't getting kills
   ptLeaveBuilderGroupTimer = $

   // Time remaining phased out
   ptPhaseTimer = $
   ptPhaseRegenTimer = $
   ptPhaseVisualEffectTimer = $
   piRemainingPhaseTime = 60000 * 8
   ptCanPhaseTimer = $

   // Our current sidekick
   poMercenary = $

   // Our stored follower in case of the feature being disabled temporarily.
   poSavedFollower = $

   piHonorPoints = 0
   piHonorRank = 0
   // 0 = don't show title, 1 = show title, 2 = alternative title
   piHonorTitle = 1
   piLastHonorChangeTime = 0

   plPeriodicSounds = $

messages:

   Constructor()
   {
      // Let the poor bastards eat something.
      piTimeLastStomachUpdate = GetTime();
      piReward_timestamp = GetTime();

      propagate;
   }

   Delete()
   {
      local i;

      Send(self,@QuitGuild);
      foreach i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      if ptUnboundEnergy <> $
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = $;
      }

      if ptAdvancement <> $
      {
         DeleteTimer(ptAdvancement);
         ptAdvancement = $;
      }

      if ptTempSafe <> $
      {
         if (IsTimer(ptTempSafe))
         {
            DeleteTimer(ptTempSafe);
         }
         ptTempSafe = $;
      }

      if ptCrystalizeManaSurgeTimer <> $
      {
         DeleteTimer(ptCrystalizeManaSurgeTimer);
         ptCrystalizeManaSurgeTimer = $;
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSpellByNum,
               #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
         piFlags2 &= ~PFLAG2_CRYST_MANA_SURGE;
      }

      if ptReward_timer <> $
      {
         DeleteTimer(ptReward_timer);
         ptReward_timer = $;
      }

      Send(self,@CancelRescue);

      if (ptPhaseRegenTimer <> $)
      {
         DeleteTimer(ptPhaseRegenTimer);
         ptPhaseRegenTimer = $;
      }

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      Send(self,@DeleteAllOverTimeEffects);

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);

      Send(Send(SYS,@GetAssassinGame),@RemoveFromGame,#who=self);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);
      plSchools = $;

      if poMercenary <> $
      {
         if IsTimer(poMercenary)
         {
            DeleteTimer(poMercenary);
            poMercenary = $;
         }
         else
         {
            Send(poMercenary,@Delete,#bConfirm=TRUE);
         }
      }

      // Clear minion control list. Delete each of our minions
      // unless they are reflections, which are handled separately.
      // Deleted minions will remove themselves from our list, we
      // just need to let them know they're to be deleted.
      if plControlledMinions <> $
      {
         foreach i in plControlledMinions
         {
            if IsClass(i,&Monster)
               AND NOT IsClass(i,&Reflection)
            {
               Send(i,@Delete);
            }
         }
         plControlledMinions = $;
      }

      Send(self,@PeriodicSounds,#bSuspend=TRUE);

      propagate;
   }

   //// Player flags

   SetDMFlag()
   {
      Debug("Tried to set DM flag on player ",Send(self,@GetTrueName));

      return;
   }

   CheckDMFlag()
   {
      return 0;
   }

   SetPlayerFlag(flag=0,value=FALSE,flagset=1)
   "This always requires the POSITIVE flag name."
   {
      local ccond;

      if flagset = 1
      {
         if (flag & PFLAG_PKILL_ENABLE) AND value
         {
            if (piFlags & PFLAG_PKILL_ENABLE)
            {
               return;
            }
            else
            {
               ccond = player_safety_off_mail;
               if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
               {
                  ccond = player_safety_on_mail;
               }

               if Send(SYS,@IsPKAllowed)
               {
                  Send(self,@ReceiveNestedMail,#from=player_angel,
                    #dest_list=[self],#nest_list=[4,player_ready_to_kill,4,ccond]);
               }
               else
               {
                  Send(self,@ReceiveNestedMail,#from=player_angel,
                    #dest_list=[self],#nest_list=[4,player_ready_to_guild,4,ccond]);
               }
            }
         }

         if NOT Value
         {
            piFlags = piFlags & ~flag;
         }
         else
         {
            piFlags = piFlags | flag;
         }
      }
      else if flagset = 2
      {
         if NOT Value
         {
            piFlags2 = piFlags2 & ~flag;
         }
         else
         {
            piFlags2 = piFlags2 | flag;
         }
      }
      else if flagset = 3
      {
         if NOT Value
         {
            piFlags3 = piFlags3 & ~flag;
         }
         else
         {
            piFlags3 = piFlags3 | flag;
         }
      }

      if (poOwner <> $)
         AND (flagset = 1)
         AND (flag & (PFLAG_MURDERER | PFLAG_OUTLAW | PFLAG_INVISIBLE))
      {
         // Tell room about change in case there are ramifications.
         Send(poOwner,@SomethingChanged,#what=self);
      }

      if flag = PFLAG_MORPHED
      {
         Post(self,@DrawOffense);
      }

      if flag = PFLAG_NO_MOVE
         OR flag = PFLAG_NO_FIGHT
         OR flag = PFLAG_NO_MAGIC
         OR flag = PFLAG_MORPHED
      {
         Post(self,@DrawDefense);
      }

      return;
   }

   CheckPlayerFlag(flag=0,flagset=1)
   "This always checks to be sure that the flag exists."
   {
      if flagset = 1
      {
         return (piFlags & flag);
      }

      if flagset = 2
      {
         return (piFlags2 & flag);
      }

      if flagset = 3
      {
         return (piFlags3 & flag);
      }

      return FALSE;
   }

   // Player preference flags (e.g. safety, tempsafe etc.)
   SetPlayerPreference(flag = 0, value = 0)
   {
      if value
      {
         piPreferences = piPreferences | flag;
      }
      else
      {
         piPreferences = piPreferences & ~flag;
      }

      return;
   }

   CheckPlayerPreference(flag = 0)
   {
      if (flag = CF_SAFETY_OFF) AND NOT Send(SYS,@IsPKAllowed)
      {
         return FALSE;
      }

      return (piPreferences & flag);
   }

   ResetPlayerFlagList()
   {
      local i;

      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=FALSE);

      piFlags = (piFlags & PFLAG_MASK);
      piFlags2 = (piFlags2 & PFLAG2_MASK);
      piFlags3 = (piFlags3 & PFLAG3_MASK);
      if Send(self,@IsResting)
      {
         piFlags = piFlags | PFLAG_NO_MOVE;
         piFlags = piFlags | PFLAG_NO_FIGHT;
         piFlags = piFlags | PFLAG_NO_MAGIC;
      }

      foreach i in plEnchantments
      {
         Send(Nth(i,2),@SetSpellPlayerFlag,#who=self);
      }

      foreach i in plUsing
      {
         Send(i,@SetItemPlayerFlag,#who=self);
      }

      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetEnchantmentList)
         {
            Send(Nth(i,2),@SetSpellPlayerFlag,#who=self,#state=Nth(i,3));
         }
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      if (pbLogged_on)
      {
         Post(self,@DrawOffense);
         Post(self,@DrawDefense);
      }

      return;
   }

   GetGameSecurityFlag(flag = 0)
   {
      return 0;
   }

   GetLastRestartTime()
   {
      return piLast_restart_time;
   }

   SetLastRestartTime(time = 0)
   {
      piLast_restart_time = time;

      return piLast_restart_time;
   }

   UpdateStomach()
   "Removes consumed food from stomach"
   {
      local now, iTime;

      now = GetTime();

      iTime = now - piTimeLastStomachUpdate;

      // Need to account for overflows. If we get a large number here we can
      // assume the user has not logged on in a while or had stomach reset
      // via e.g. timeoverflow fix so we can just let them eat.
      if (iTime >= MAX_KOD_INT / FOOD_USE_RATE)
      {
         piStomach = 1;
      }
      else
      {
         piStomach -= (iTime * FOOD_USE_RATE / 100);
         piStomach = Bound(piStomach,1,100);
      }

      piTimeLastStomachUpdate = now;

      return;
   }

   StartRescueTimer(time=5000)
   "Starts a timer which will rescue the player after time ms."
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      ptRescue = CreateTimer(self,@EndRescueTimer,time);

      return TRUE;
   }

   EndRescueTimer()
   {
      ptRescue = $;
      Send(self,@EndRescue);

      return;
   }

   EndRescue()
   "Deletes rescue timer if it exists and does the rescue operation."
   {
      Send(self,@CancelRescue);

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) <> RID_OUTOFGRACE
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_RESCUE),@DoRescue,#who=self);
      }

      return;
   }

   CancelRescue()
   "Cancels the rescue timer if it exists and does not execute "
   "the rescue operation."
   {
      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }
      return;
   }

   CanRescue()
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   TryDeflect(what = $,caster=$)
   {
      local oDeflect;

      oDeflect = Send(SYS,@FindSpellByNum,#Num=SID_DEFLECT);
      if Send(self,@IsEnchanted,#what=oDeflect)
      {
         return Send(oDeflect,@TryDeflect,#caster=caster,#victim=self,
                     #oSpell=what);
      }

      return FALSE;
   }

   NewOwner(what = $)
   {
      local iBasePhaseTime, iMaxHealth;

      Send(self,@ResetGainFlags);

      // Are we moving somewhere "safe" or in a frenzy??
      if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         AND NOT Send(SYS,@GetChaosNight)
      {
         // Don't set the "haven't moved" flag if we're in a safe area.
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

         // Don't create the revenant if we're in a safe location.
         if (piFlags & PFLAG_HAUNTED)
         {
            iMaxHealth = Send(self,@GetBaseMaxHealth);
            Create(&Revenant,#target=self,#location=poOwner,
                   #level=Bound((((iMaxHealth * 150) / 100)
                              + (5 * piKill_Count_decay)),95,215),
                   #diff=Bound(iMaxHealth / 10,4,9),#karmic=-piKarma / 100);
         }
      }

      Send(self,@BreakTrance,#event=EVENT_NEWOWNER);

      if (piFlags2 & PFLAG2_HUNTED)
      {
         Send(self,@InformHunters);
      }

      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
      {
         iBasePhaseTime = Send(self,@GetBasePhaseTime);
         if piRemainingPhaseTime <> iBasePhaseTime
         {
            Send(self,@MsgSendUser,#message_rsc=phase_fatigue_cleared);
            Send(self,@RefreshPhaseTimeToBase);
         }

         if poMercenary <> $
            AND NOT IsTimer(poMercenary)
            AND IsClass(poMercenary,&Follower)
            AND Send(poMercenary,@IsAbsent)
            AND Send(poOwner,@IsAccessibleForFollowers)
         {
            Send(poMercenary,@FollowerReturn);
         }
      }

      // Stop any rescue attempts if the user changes rooms.
      if ptRescue <> $
      {
         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue_newowner);
         }
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      return;
   }

   InformHunters()
   {
      local i, j, oSpell, state, oSpellCloak, rLocation, lRoomlist, oRoom;

      oSpell = Send(SYS,@FindSpellByNum,#Num=SID_HUNT);
      oSpellCloak = Send(SYS,@FindSpellByNum,#Num=SID_CLOAK);
      rLocation = Send(poOwner,@GetName);

      if Send(self,@IsEnchanted,#what=oSpellCloak)
         AND (Random(1,100) < Send(self,@GetEnchantedState,#what=oSpellCloak))
      {
         // Will mislead hunters with random room if Cloak is on
         // and passes state check.
         oRoom = Send(oSpellCloak,@GetWrongRoom);
         rLocation = Send(oRoom,@GetName);
      }

      foreach i in plEnchantments
      {
         if Nth(i,2) = oSpell
         {
            state = Nth(i,3);
            if NOT IsClass(First(state),&Prism)
            {
               foreach j in state
               {
                  Send(j,@MsgSendUser,#message_rsc=player_to_hunters,
                        #parm1=Send(self,@GetDef),
                        #parm2=Send(self,@GetTrueName),
                        #parm3=rLocation);
               }
            }
         }
      }

      return $;
   }

   ShowDesc()
   {
      local i,oEnchanter, rank, HitPoint_Percent;

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         // Since piHealth is internally inflated by a factor of 100, this 
         // returns the percentage correctly.
         HitPoint_Percent = piHealth / piMax_health;
         Send(poIllusion_set,@IllusionShowDesc,#who=self,
               #iHitPoint_Percent=HitPoint_Percent);

         return;
      }

      if psPlayerDescription <> $
      {
         AddPacket(4,player_desc_enchanted_none, 0,psPlayerDescription);

         return;
      }

      propagate;
   }

   GetAge()
   {
      local age;

      age = Send(SYS,@GetYear) - Send(self,@GetBirthYear);

      // No more tutorial messages and bonuses if you've been around
      // for about 2 months. Clear the newbie string, too. Do a bit flag
      // check instead of a function call since this is called EVERY time
      // someone gets looked at.
      if age >= 2
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
         Send(self,@RemoveHonorString,#string=player_newbie_honor_string);
      }

      return age;
   }

   SetAge(age = 0)
   "Admin supported."
   {
      age = Bound(age, 0, Send(SYS,@GetYear));
      piBorn_year = Send(SYS,@GetYear) - age;

      return age;
   }

   DoesPlayerTakeNewbieDeath()
   {
      // Always newbie death if honor string, but after it disappears
      // this is dependent on not having PFLAG_PKILL_ENABLE.
      return Send(self,@HasHonorString,#string=player_newbie_honor_string)
         OR (NOT (piFlags & PFLAG_PKILL_ENABLE)
            AND NOT Send(SETTINGS_OBJECT,@NewbiesDropLoot));
   }

   GetHonorStringList()
   {
      return plHonor;
   }

   HasHonorString(string = $)
   "Checks the plHonor list for the given string."
   {
      local i;

      if plHonor = $
         or string = $
      {
         return FALSE;
      }

      // Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      foreach i in plHonor
      {
         if StringContain(i,string)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   AppendHonorStrings()
   "Appends all the honor strings to the temp string. Adds newline "
   "between strings."
   {
      local i;

      if plHonor <> $
      {
         foreach i in plHonor
         {
            // Add newbie tag separately so it gets translated.
            if i <> player_newbie_honor_string
            {
               AppendTempString(i);
               AppendTempString("\n");
            }
         }
      }

      return;
   }

   AddHonorString(string=$,iPosition = 1)
   "Adds string to plHonor list. iPosition allows string position "
   "to be chosen."
   {
      if string = $
      {
         return;
      }

      // Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      if plHonor = $
      {
         plHonor = [string];
      }
      else
      {
         plHonor = InsertListElem(plHonor,iPosition,string);
      }

      return;
   }

   RemoveHonorString(string=$)
   "Removes the given string from plHonor. Searches the entire list, "
   "so it will remove any duplicates."
   {
      local i;

      if plHonor = $
         OR string = $
      {
         return;
      }

      // Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      foreach i in plHonor
      {
         if StringContain(i,string)
         {
            plHonor = DelListElem(plHonor,i);
         }
      }

      return;
   }

   ClearHonorStrings()
   "Removes all the honor strings."
   {
      plHonor = $;

      return;
   }

   ShowExtraInfo()
   {
      local i, j, obj, year, rCargoNum;

      // Master fixed info resource.
      AddPacket(4,player_fixed_info);

      //
      // Add hometown and age, or DM rank.
      //
      if NOT IsClass(self,&DM)
      {
         switch(Send(self,@GetHomeRoom))
         {
            case RID_RAZA_INN:
               j = player_citizen_raza;
               break;
            case RID_BAR_INN:
               j = player_citizen_barloque;
               break;
            case RID_COR_INN:
               j = player_citizen_cornoth;
               break;
            case RID_MAR_INN:
               j = player_citizen_marion;
               break;
            case RID_JAS_INN:
               j = player_citizen_jasper;
               break;
            case RID_TOS_INN:
               j = player_citizen_tos;
               break;
            case RID_KOC_INN:
               j = player_citizen_kocatan;
               break;
            default:
               j = player_citizen_unknown;
               break;
         }

         AddPacket(4,player_hometown_rsc,4,Send(self,@GetHeShe,#cap=TRUE),4,j);
         ClearTempString();
         i = Send(self,@GetAge);
         if (i < 1)
         {
            AddPacket(4,system_blank_resource,4,GetTempString(),
                      4,player_under_one_year);
         }
         else
         {
            AddPacket(4,player_for);

            Send(SYS,@AppendCardinalToTempString,#number=i);
            AddPacket(4,GetTempString());
            if i = 1
            {
               AddPacket(4,player_year);
            }
            else
            {
               AddPacket(4,player_years);
            }
         }
      }
      else
      {
         // For DMs
         i = Send(self,@GetRankRsc);
         if i <> $
         {
            AddPacket(4,i);
         }
         else
         {
            AddPacket(4,system_blank_resource);
         }
      }

      //
      // Add guild affiliation.
      //
      if poGuild <> $ AND NOT Send(poGuild,@IsSecret)
      {
         i = Send(poGuild,@GetRank,#who=self);
         // (example) Squire of the BootLickers.
         AddPacket(4,player_guild_rsc, 4,Send(poGuild,@GetRankName,#rank=i,#sex=piGender),
                   4,player_of, 4,Send(poGuild,@GetDef),4,Send(poGuild,@GetName));
      }
      else
      {
        AddPacket(4,system_blank_resource);
      }

      //
      // Add faction affiliation.
      //
      i = Send(self,@GetFaction);
      if (i = FACTION_DUKE)
      {
         AddPacket(4,player_faction_duke);
      }
      else if (i = FACTION_PRINCESS)
      {
         AddPacket(4,player_faction_princess);
      }
      else if (i = FACTION_REBEL)
      {
         AddPacket(4,player_faction_rebel);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      if piHonorTitle = 1
      {
         if piHonorRank = 1
         {
            AddPacket(4,player_honor_rank_1);
         }
         else if piHonorRank = 2
         {
            AddPacket(4,player_honor_rank_2);
         }
         else if piHonorRank = 3
         {
            AddPacket(4,player_honor_rank_3);
         }
         else if piHonorRank = 4
         {
            AddPacket(4,player_honor_rank_4);
         }
         else if piHonorRank = 5
         {
            AddPacket(4,player_honor_rank_5);
         }
         else
         {
            AddPacket(4,system_blank_resource);
         }
      }
      else if piHonorTitle = 2
      {
         if piHonorRank = 1
         {
            AddPacket(4,player_honor_rank_1_alt);
         }
         else if piHonorRank = 2
         {
            AddPacket(4,player_honor_rank_2_alt);
         }
         else if piHonorRank = 3
         {
            AddPacket(4,player_honor_rank_3_alt);
         }
         else if piHonorRank = 4
         {
            AddPacket(4,player_honor_rank_4_alt);
         }
         else if piHonorRank = 5
         {
            AddPacket(4,player_honor_rank_5_alt);
         }
         else
         {
            AddPacket(4,system_blank_resource);
         }
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      obj = Send(SYS,@GetCaramo);
      if (obj <> $
         AND Send(obj,@GetJusticar) = self)
      {
         AddPacket(4, player_is_justicar);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      //
      // Add visible cargo types. The number of these doesn't really change,
      // but this section has error checking anyway just in case we change it.
      //
      j = Send(SYS,@GetVisibleCargoTypes);
      if j = $
      {
         AddPacket(4,system_blank_resource);
      }
      else
      {
         switch(Length(j))
         {
            case 5:
               rCargoNum = system_rsc_template_5;
               break;
            case 1:
               rCargoNum = system_rsc_template_1;
               break;
            case 2:
               rCargoNum = system_rsc_template_2;
               break;
            case 3:
               rCargoNum = system_rsc_template_3;
               break;
            case 4:
               rCargoNum = system_rsc_template_4;
               break;
            case 6:
               rCargoNum = system_rsc_template_6;
               break;
            case 7:
               rCargoNum = system_rsc_template_7;
               break;
            default:
               rCargoNum = system_rsc_template_1;
               break;
         }

         AddPacket(4,rCargoNum);

         foreach i in j
         {
            // (example) He is holding a purple pickle princess figurine.
            obj = GetListElemByClass(plPassive,i);
            if obj <> $
            {
               if IsClass(obj,&Ring)
               {
                  AddPacket(4,player_is_wearing, 4,Send(self,@GetHeShe,#cap=TRUE),
                            4,Send(obj,@GetIndef), 4,Send(obj,@GetName));
               }
               else
               {
                  AddPacket(4,player_is_holding, 4,Send(self,@GetHeShe,#cap=TRUE),
                            4,Send(obj,@GetIndef), 4,Send(obj,@GetName));
               }
            }
            else
            {
              AddPacket(4,system_blank_resource);
            }
         }
      }

//// Option turned off for review.
// Works with //q placed in the master fixed description resource.
//      ClearTempString();
//      if NOT Send(self,@PlayerIsImmortal)
//      {
//         // (example) Known far and wide for mastery of Jala and Kraanan magics 
//         // and weaponcraft skills.
//
//         j = FALSE;
//
//         // magic school masteries first
//         obj = Send(SYS,@FindSpellByNum,#num=SID_BONK); // any real spell will do
//         foreach i in [SS_JALA,SS_RIIJA,SS_QOR,SS_SHALILLE,SS_KRAANAN,SS_FAREN]
//         {
//            if Send(self,@CountKnownAtLevel,#school=i,#level=6) >= 1
//            {
//               if NOT j
//               {
//                  AppendTempString(player_known_for_mastery);
//                  j = TRUE;
//               }
//               else
//               {
//                  AppendTempString(player_and);
//               }
//               AppendTempString(Send(obj,@GetSchoolStr,#ischool=i));
//            }
//         }
//         
//         if j
//         {
//            AppendTempString(player_magics);
//         }
//
//         // weaponcraft
//         if Send(self,@CountKnownAtLevel,#school=SKS_WEAPONCRAFT,#level=5) >= 1
//         {
//            if NOT j
//            {
//               AppendTempString(player_known_for_mastery);
//               j = TRUE;
//            }
//            else
//            {
//               AppendTempString(player_and);
//            }
//            AppendTempString(player_skills);
//         }
//
//         AppendTempString(player_dot);
//         AppendTempString(system_newline_resource);
//      }
//      AddPacket(4,GetTempString());

      //
      // Add newbie tag resource ID, so client can translate it.
      //
      if Send(self,@HasHonorString,#string=player_newbie_honor_string)
      {
         AddPacket(4,player_newbie_honor_string);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      //
      // Append all honor strings (except newbie tag) to the temp string.
      //
      ClearTempString();
      Send(self,@AppendHonorStrings);
      AddPacket(4,GetTempString());

      //
      // Add donation years.
      //
      ClearTempString();
      if plDonationYears <> $
      {
         i = 0;
         foreach year in plDonationYears
         {
            if i <> 0
            {
               AppendTempString(player_donation_separator);
            }
            AppendTempString(year);
            ++i;
         }
         AddPacket(4,player_donation_title,4,GetTempString());
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      return;
   }

   UserLogonHook()
   {
      local i, oObj, iBonus, iDefaultBonus, iTimespan;

      SendList(plPassive, 0, @UserLogon);
      SendList(plActive, 0, @UserLogon);

      // Restart Unbound Energy, Health and Mana timers
      Send(self,@NewUnboundEnergy);
      Send(self,@NewVigor);
      Send(self,@SendUserAllWindowOverlays);

      oObj = Send(SYS,@GetParliament);
      if oObj <> $
      {
         if piFaction <> FACTION_NEUTRAL 
            AND (NOT Send(oObj,@IsShutdown))
         {
            piFactionTimeUpdated=GetTime();
            Send(self,@FactionServiceTimer);
         }

         if Send(self,@PlayerIsIntriguing)
         {
            Send(oObj,@UpdateEffects,#who=self); 
         }
      }

      oObj = Send(SYS,@GetAssassinGame);
      if oObj <> $
         AND Send(oObj,@InAcceptMode)
         AND (NOT Send(oObj,@IsCombatant,#who=self))
         AND Send(oObj,@IsAdvertised,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=player_assgame_soon);
      }

      oObj = Send(SYS,@GetCaramo);
      if oObj <> $
      {
         Send(oObj,@UserLogon,#who=self);
      }

      if poGuild <> $
      {
         Send(poGuild,@SendUserMOTD,#who=self);
      }

      if ptTempSafe <> $
      {
         Send(self,@UnpauseTempSafe);
      }

      // Possibly start phase time regen.
      if (piRemainingPhaseTime < Send(self,@GetBasePhaseTime))
      {
         if (ptPhaseRegenTimer <> $)
         {
            DeleteTimer(ptPhaseRegenTimer);
         }
         // 5 sec delay so flashing on/off doesn't regen time.
         ptPhaseRegenTimer = CreateTimer(self,@RegenPhaseTime,5000);
      }

      // Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

      // If we log into the Raza inn and aren't past the tutorial,
      // then give us a commands list.
      // TODO: update this to not require a room check.
      if (IsClass(poOwner,&RazaInn)
            AND NOT (piFlags & PFLAG_TUTORIAL))
      {
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      // Max mana could have changed while offline (e.g. mana node changes).
      // We used to do this when the mana nodes changed, but iterating
      // over all players became far too expensive.
      Send(self,@ComputeMaxMana);

      // Tell others that we're here
      if poOwner <> $ AND NOT IsClass(self, &DM)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
               #wave_rsc=player_logged_on_wav_rsc);
      }

      // Reward people for logging on by granting them some free training points!
      // We take the absolute value to automatically fix bugs with people
      // mysteriously ending up with a timestamp in the distant future.
      iTimespan = Abs(GetTime() - piReward_timestamp);

      // We restrict the timespan to reasonable limits here since the bonus to
      // training points scales with the time since the last bonus has been
      // received. 36 hours means that players have a decent leeway to log on
      // again before missing out on training points, but are still encouraged
      // to log on daily to cash in maximum points.
      iTimespan = Bound(iTimespan,0,36*60*60);

      if iTimespan > 16*60*60
      {
         if piTraining_points >= 1000
         {
            return;
         }

         // Retrieve the daily logon bonus from settings.
         iDefaultBonus = Send(SETTINGS_OBJECT,@GetLogonBonus);

         // Scale the logon bonus with the time that has passed since it has last
         // been received for a total bonus of up to 150 percent.
         iBonus = iDefaultBonus * iTimespan / (24*60*60);

         Send(self,@MsgSendUser,#message_rsc=player_logon_bonus,#parm1=iBonus);
         Send(self,@AddTrainingPoints,#points=iBonus,#report=FALSE);

         piReward_timestamp = GetTime();
      }

      // For people who never log off, start the reward timer that will grant
      // them the daily training bonus every 24 hours, even if they don't log
      // off and back on.
      ptReward_timer = CreateTimer(self,@GetDailyTrainingReward,24*60*60*1000);

      return;
   }

   UserLogoffHook()
   {
      local i;

      SendList(plPassive,0,@UserLogoff);
      SendList(plActive,0,@UserLogoff);

      // If this player has created any evil twins, delete them.
      Send(self,@RemoveAllCreatedEvilTwins);

      // Release our minions.
      Send(self,@RemoveAllMinions);

      // client assumes not resting upon login
      Send(self,@StopResting);

      if piFaction <> FACTION_NEUTRAL
      {
         Send(self,@FactionServiceTimer,#renew=FALSE);
      }

      // Stop unbound energy, health and mana timers.
      if ptUnboundEnergy <> $
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = $;
      }

      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth=$;
      }

      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptVigor <> $
      {
         DeleteTimer(ptVigor);
         ptVigor = $;
      }

      if ptReward_timer <> $
      {
         DeleteTimer(ptReward_timer);
         ptReward_timer = $;
      }

      if (ptTempSafe <> $)
      {
         Send(self,@PauseTempSafe);
      }

      Send(self,@CancelRescue);

      // If phase time regen timer is active, delete it.
      if (ptPhaseRegenTimer <> $)
      {
         DeleteTimer(ptPhaseRegenTimer);
         ptPhaseRegenTimer = $;
      }

      // Tell others that we're leaving
      if poOwner <> $ AND NOT IsClass(self,&DM)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
               #wave_rsc=player_logged_off_wav_rsc);
      }

      // Make our follower linger for a while, then poof.
      if poMercenary <> $
         AND NOT IsTimer(poMercenary)
         AND IsClass(poMercenary,&Follower)
         AND NOT Send(poMercenary,@IsAbsent)
      {
         Send(poMercenary,@FollowerAbsence,#iDelay=30000);
      }

      return;
   }

   SendUserAllWindowOverlays()
   "Send the user any overlays that they might have.  Called when they logon "
   "or when garbage collected."
   {
      local i;

      foreach i in plWindow_overlays
      {
         Send(self,@SetWindowOverlay,#what=i);
      }

      return;
   }

   RestrictToResourceList(res = $, res_list = $)
   "If res is in res_list, return it.  Otherwise return the first element "
   "of res_list."
   {
      if FindListElem(res_list, res)
      {
         return res;
      }

      return Nth(res_list, 1);
   }

   PlayerNewCharInfo(desc = $,charinfo = $,gender = $)
   "This message is received when the user (re)started a character.\n"
   "<desc> contains a string with the description, charinfo is a list "
   "of values selected.  See system.kod, SendCharInfo(), for what these "
   "values mean."
   {
      local i, j, lFaceparts, lStats, lSpells, lSkills, iPoints, iLevel, oSpell,
            iHair_translation, iSkin_translation, bQor, bShalille, oSkill,
            oSchool, iCount, bAdded;

      psPlayerDescription = desc;

      if Length(charinfo) <> 6
      {
         Debug("Bad charinfo message, length ",Length(charinfo));

         return;
      }

      // charinfo is a list of 4 elements:
      // list of face part resources
      // list of stats (might, intellect, etc.)
      // list of initial spells
      // list of initial skills

      lFaceparts = First(charinfo);
      if (Length(lFaceparts) <> 5)
      {
         // Hacking the protocol -> default char
         gender = GENDER_MALE;
         lFaceparts = [charinfo_head_ax_icon,charinfo_hair_ac_icon,
                       charinfo_eyes_ax_icon,charinfo_nose_ax_icon,
                       charinfo_mouth_ax_icon];
      }

      // Validate that all face parts were in the list of choices
      prHead = Send(self, @RestrictToResourceList, #res = First(lFaceparts),
          #res_list = Send(SYS, @GetAllowedHeadIcons, #iGender = gender));

      prToupee = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,2), 
          #res_list = Send(SYS, @GetAllowedHairIcons, #iGender = gender));

      prEyes = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,3), 
          #res_list = Send(SYS, @GetAllowedEyeIcons, #iGender = gender));

      prNose = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,4), 
          #res_list = Send(SYS, @GetAllowedNoseIcons, #iGender = gender));

      prMouth = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,5), 
          #res_list = Send(SYS, @GetAllowedMouthIcons, #iGender = gender));

      iHair_translation = Nth(charinfo,2);
      iSkin_translation = Nth(charinfo,3);

      if iHair_translation <> 0
         AND iHair_translation <> PT_GRAY_TO_ORANGE
         AND iHair_translation <> PT_GRAY_TO_RED
         AND iHair_translation <> PT_GRAY_TO_SKIN1
         AND iHair_translation <> PT_GRAY_TO_SKIN2
         AND iHair_translation <> PT_GRAY_TO_SKIN3
         AND iHair_translation <> PT_GRAY_TO_SKIN4
         AND iHair_translation <> PT_GRAY_TO_SKIN5
         AND iHair_translation <> PT_GRAY_TO_PLATBLOND
         AND iHair_translation <> PT_GRAY_TO_KORANGE
         AND iHair_translation <> PT_GRAY_TO_KRED
         AND iHair_translation <> PT_GRAY_TO_KGRAY
         AND iHair_translation <> PT_GRAY_TO_BLACK
         AND iHair_translation <> PT_GRAY_TO_BLOND
      {
         // if they hacked char.dll...
         iHair_translation = PT_GRAY_TO_BLOND;
      }
      
      Send(self,@SetHairTranslation,#translation=iHair_translation);

      if iSkin_translation <> PT_BLUE_TO_SKIN1
         AND iSkin_translation <> PT_BLUE_TO_SKIN2
         AND iSkin_translation <> PT_BLUE_TO_SKIN3
         AND iSkin_translation <> PT_BLUE_TO_SKIN4
      {
         // if they hacked char.dll...
         iSkin_translation = PT_BLUE_TO_SKIN3;
      }

      Send(self,@SetSkinTranslation,#translation=iSkin_translation);
      Send(self,@SetDefaultClothes,#rand=TRUE);
      Send(self,@ResetPlayerIcon);
      Send(self,@ResetPlayerArms);
      Send(self,@ResetPlayerLegs);

      lStats = Nth(charinfo,4);
      if (Length(lStats) <> 6)
      {
         // Hacking the protocol -> junk char for you
         lStats = [1, 1, 1, 1, 1, 1];
      }

      iPoints = First(lStats) + Nth(lStats,2) + Nth(lStats,3)
               + Nth(lStats,4) + Nth(lStats,5) + Nth(lStats,6);

      if First(lStats) < 1 OR First(lStats) > 50
         OR Nth(lStats,2) < 1 OR Nth(lStats,2) > 50
         OR Nth(lStats,3) < 1 OR Nth(lStats,3) > 50
         OR Nth(lStats,4) < 1 OR Nth(lStats,4) > 50
         OR Nth(lStats,5) < 1 OR Nth(lStats,5) > 50
         OR Nth(lStats,6) < 1 OR Nth(lStats,6) > 50
         OR iPoints > 200
      {
         // they hacked their char.dll
         piMight = 3;
         piIntellect = 1;
         piStamina = 4;
         piAgility = 1;
         piMysticism = 5;
         piAim = 9;
      }
      else
      {
         piMight = First(lStats);
         piIntellect = Nth(lStats,2);
         piStamina = Nth(lStats,3);
         piAgility = Nth(lStats,4);
         piMysticism = Nth(lStats,5);
         piAim = Nth(lStats,6);
      }

      // Set some other stats based on these

      piHealth = 2000;
      Send(self,@NewHealth);
      piBase_Max_Health = 20;
      piMax_health = piBase_max_health;
      Send(self,@GainBaseMaxHealth);
      
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," restarted character: ",piMax_health,
               pibase_max_health);
      }

      Send(self,@ComputeMaxMana);
      piMana = 100 * piMax_mana;

      // need to determine male/female
      if gender = GENDER_MALE
      {
         piGender = GENDER_MALE;
         vrIcon = player_male_icon_rsc;
         prLegs = player_legs_a_rsc;
         prRight_arm = player_rightarm_a_rsc;
         prLeft_arm = player_leftarm_a_rsc;
      }
      else
      {
         piGender = GENDER_FEMALE;
         vrIcon = player_female_icon_rsc;
         prLegs = player_legs_b_rsc;
         prRight_arm = player_rightarm_b_rsc;
         prLeft_arm = player_leftarm_b_rsc;
      }

      Send(self,@ResetCharacter);

      // Setup default stuff

      Send(self,@AddDefaultSpells);
      Send(self,@AddDefaultSkills);

      lSpells = Nth(charinfo,5);
      lSkills = Nth(charinfo,6);

      iPoints = 0;
      foreach i in lSpells
      {
         iLevel = Send(Send(SYS,@FindSpellByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints += 25;
         }
         else
         {
            iPoints += 10;
         }
      }

      foreach i in lSkills
      {
         iLevel = Send(Send(SYS,@FindSkillByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints += 25;
         }
         else
         {
            iPoints += 10;
         }
      }

      // We start out as neutral, let's see if our spells change that.
      bQor = FALSE;
      bShalille = FALSE;

      if iPoints > 125
      {
         // they hacked their char.dll
      }
      else
      {
         foreach i in lSpells
         {
            oSpell = Send(SYS, @FindSpellByNum, #num=i);

            // Gotta have a valid spell.
            if oSpell = $
            {
               continue;
            }

            // Spell must be available to new players.
            if NOT Send(oSpell,@OfferToNewCharacters)
            {
               continue;
            }

            // Let's check what school we are dealing with here.
            oSchool = Send(oSpell,@GetSchool);

            // Spell must not conflict with our alignment.
            if ((oSchool = SS_QOR) AND bShalille)
               OR ((oSchool = SS_SHALILLE) AND bQor)
            {
               continue;
            }

            // Level 2 spells require at least 2 level 1 spells of that school.
            iLevel = Send(oSpell,@GetLevel);
            iCount = 0;
            bAdded = FALSE;

            if (iLevel = 1)
            {
               Send(self,@AddSpell,#num=i,#initial=TRUE);
               bAdded = TRUE;
            }
            else if (iLevel = 2)
            {
               foreach j in lSpells
               {
                  oSpell = Send(SYS,@FindSpellByNum,#num=j);

                  if (oSchool = Send(oSpell,@GetSchool))
                     AND (Send(oSpell,@GetLevel) = 1)
                  {
                     ++iCount;
                  }
               }

               if iCount >= 2
               {
                  Send(self,@AddSpell,#num=i,#initial=TRUE);
                  bAdded = TRUE;
               }
            }

            // This sets our alignment in stone, grants karma and blocks
            // spells of opposite alignment from making it into our list.
            if bAdded AND (oSchool = SS_QOR)
            {
               bQor = TRUE;
            }

            if bAdded AND (oSchool = SS_SHALILLE)
            {
               bShalille = TRUE;
            }
         }

         foreach i in lSkills
         {
            oSkill = Send(SYS,@FindSkillByNum,#num=i);
            oSchool = Send(oSkill,@GetSchool);
            iLevel = Send(oSkill,@GetLevel);

            iCount = 0;

            if (iLevel = 1)
            {
               Send(self,@AddSkill,#num=i,#initial=TRUE);
            }
            else if (iLevel = 2)
            {
               foreach j in lSkills
               {
                  oSkill = Send(SYS,@FindSkillByNum,#num=j);

                  if (oSchool = Send(oSkill,@GetSchool))
                     AND (Send(oSkill,@GetLevel) = 1)
                  {
                     ++iCount;
                  }
               }

               if iCount >= 2
               {
                  Send(self,@AddSkill,#num=i,#initial=TRUE);
               }
            }
         }

         Send(self,@RefigureSchoolsLists);
      }

      // Do this after we add spells so that we can give reagents if appropriate.
      Send(self,@AddDefaultObjects);

      // If the player chose either a Qor spell or a Shalille spell to start,
      // give him a favorable karma to start from. However, if he chose both,
      // or if he chose neither, do nothing.

      piKarma = 0;
      if bQor AND NOT bShalille
      {
         piKarma = -2000;
      }

      if bShalille AND NOT bQor
      {
         piKarma = 2000;
      }

      Send(self,@SetInitialHomeroom);
      Send(self,@TeleportToInitialLocation);

      piBorn_year = Send(SYS,@GetYear);

      // Send first mail the first time player plays.
      // Set their honor strong if this is a truly new character (max 1 reroll)
      if NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_first_mail]);
         Send(self,@AddHonorString,#string=player_newbie_honor_string);
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      // Reset their non-pvp flag if present.
      piflags &= ~PFLAG_PERMA_NO_PVP;

      // Update stomach so it starts ticking down properly
      Send(self,@UpdateStomach);

      // Give them a new start on life, so that their newbie
      // friends can buff and heal them.
      piTimeAttackedPlayer = 0;
      piTimeAttackedByPlayer = 0;
      piTimeLastMurder = 0;

      // Give them the default amount of honor points.
      Send(self,@SetHonorPoints,#honor=Send(SETTINGS_OBJECT,@GetDefaultHonor));


      return;
   }

   GetBirthYear()
   {
      return piBorn_year;
   }

   SetBirthYear(year=0)
   {
      piBorn_Year = year;

      return;
   }

   ResetCharacter()
   "Setup default stuff"
   {
      local i;

      // first, kill all their items

      foreach i in plActive
      {
         Send(i,@Delete);
      }

      foreach i in plPassive
      {
         Send(i,@Delete);
      }

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      plSpells = $;
      plSkills = $;

      if Send(self,@CheckLog)
      {
         Debug("LOG: ",vrName," restarted character, spells & skills are nil");
      }

      // Setup some stats
      piBase_max_health = 20;
      piMax_health = piBase_max_health;
      Send(self,@ComputeMaxMana);
      piMana = 100 * piMax_mana;

      poKill_target = $;
      piKarma = 0;

      // percent stomach is full
      piStomach = 0;
      piTimeLastStomachUpdate = 0;

      piKill_count = 0;
      piKill_count_decay = 0;
      piJustified_kill_count = 0;

      Send(self,@ZeroMods);

      Send(self,@PlayerIsIntriguing);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_TEMPSAFE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PERMA_NO_PVP,#value=FALSE);

      // quit the guild, then be sure any guild commands are set to nil
      // important, keep this after the player flags part above.
      Send(self,@QuitGuild);
      piGuild_commands = 0;

      Send(Send(sys,@GetAssassinGame),@RemoveFromGame,#who=self);
      // Remove the guy from the Assassin's game.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      Send(self,@DeleteAllOverTimeEffects);
      piLight = 5;

      // Be sure they aren't declared a 'former member' by any existing guilds.
      foreach i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      piNodelist = 0;

      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);

      if Send(SYS,@GetLastMurderer) = self
      {
         Send(SYS,@ClearLastMurderer);
      }

      Send(self,@UpdateRates);
      Send(self,@PeriodicSounds,#bSuspend=TRUE);

      return;
   }

   AddDefaultSpells()
   "Add the spells a player is given when creating a character"
   {
      Send(self,@AddSpell,#num=SID_BLINK,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_CONVEYANCE,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_PHASE,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_MEDITATE,#initial=TRUE,#iability=1);

      return;
   }

   AddDefaultSkills()
   "Add the skills that all players have."
   {
      return;
   }

   AddDefaultObjects()
   "Add the objects a player is given when creating a character in newbie zone"
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      // Give the poor newbie an weapon and a bit of cash.
      Send(self,@NewHold,#what=Create(&Mace));
      Send(self,@NewHold,#what=Create(&Shillings,#number=500));
      Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=500);
      Send(self,@AddReagentsForSpells,#iNumCasts=10);

      // If player hasn't suicided in last 5 hours, give them cash and prizes!
      if (GetTime() - piLast_restart_time) > (5*60*60)   
      {
         Send(self,@NewHold,#what=Create(&Shillings,#number=500));
         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=500);
         Send(self,@AddReagentsForSpells,#iNumCasts=10);
      }

      return;
   }

   StripInventory()
   {
      local lItems,oItem;

      // Delete the old stuff.
      foreach lItems in [plActive,plPassive]
      {
         foreach oItem in lItems
         {
            Send(oItem,@Delete);
         }
      }

      return;
   }

   AddReagentsForSpells(iNumCasts=5)
   "Add reagents to the player for the spells they have. Enough "
   "reagents for iNumCasts casts."
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      foreach iInfo in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,
                     #num=Send(self,@DecodeSpellNum,#compound=iInfo));
         lReagents = Send(oSpell,@GetReagents);

         foreach lItems in lReagents
         {
            cReagent = first(lItems);
            iNumber = Nth(lItems,2);

            Send(self,@NewHold,
                  #what=Create(cReagent,#number=(iNumber*iNumCasts)));
         }
      }

      return;
   }

   GetNumItemsInInventory()
   {
      return (length(plActive) + length(plPassive));
   }

   DropItem(droppedItem=$, targetGhost=$, dropRoom=$, dropRow=0, dropCol=0,
            dropFineRow=32,dropFineCol=32,index=$, merge=TRUE)
   {
      local oItem, oDropRoom, iDropRow, iDropCol, iDropFineRow, iDropFineCol,
            oItemAtt;

      if droppedItem <> $
      {
         oItem = droppedItem;
      }
      else if index = $
      {
         return FALSE;
      }

      oItem = Send(self,@FindItemByIndex,#index=index);

      // Can't drop nothing.
      if (oItem = $)
      {
         return FALSE;
      }

      if targetGhost = $
      {
         if dropRoom = $
         {
            oDropRoom = poOwner;
            iDropRow = piRow;
            iDropCol = piCol;
            iDropFineRow = piFine_row;
            iDropFineCol = piFine_col;
         }
         else
         {
            oDropRoom = dropRoom;
            iDropRow = dropRow;
            iDropCol = dropCol;
            iDropFineRow = dropFineRow;
            iDropFineCol = dropFineCol;
         }
      }
      else
      {
         // This is the result of a logoff ghost penalty.
         oDropRoom = Send(targetGhost,@GetOwner);
         iDropRow = Send(targetGhost,@GetRow);
         iDropCol = Send(targetGhost,@GetCol);
         iDropFineRow = Send(targetGhost,@GetFineRow);
         iDropFineCol = Send(targetGhost,@GetFineCol);
      }

      if Send(oItem,@ReqNewOwner,#what=oDropRoom)
         AND Send(oDropRoom,@ReqNewHold,#what=oItem,
                  #new_row=iDropRow,#new_col=iDropCol)
      {
         if Send(oItem,@DropOnDeath)
         {
            if targetGhost <> $
            {
               // Put the PK pointer attribute on the item to prevent
               // mules from grabbing penalty drops from ghosts.
               oItemAtt = Send(sys,@FindItemAttByNum,#num=IA_PKPOINTER);
               Send(oItemAtt,@AddToItem,#oItem=oItem,
                     #timer_duration=PKPOINTER_TIME,
                     #state1=self);
            }

            Send(oDropRoom,@NewHold,#what=oItem,#merge=merge,
                  #new_row=iDropRow,#new_col=iDropCol,
                  #fine_row=iDropFineRow,#fine_col=iDropFineCol);

            return TRUE;
         }
      }

      return FALSE;
   }

   FindItemByIndex(index = $)
   {
      local lInv;

      if index = $
      {
         return $;
      }

      if index <= length(plActive)
      {
         lInv = plActive;
      }
      else
      {
         lInv = plPassive;
         index = index - length(plActive);
      }

      if (lInv = $)
      {
         return $;
      }

      return Nth(lInv,index);
   }

   GetGuild()
   {
      return poGuild;
   }

   GetGuildHall()
   "Return this player's guild hall, or NIL if none"
   {
      if poGuild = $
      {
         return $;
      }

      return Send(poGuild,@GetGuildHall);
   }

   HasLeftAGuildTooRecently()
   {
      return (GetTime() < piGuildRejoinTimestamp);
   }

   SetGuildRejoinTime(delayMinutes=0)
   {
      piGuildRejoinTimestamp = GetTime() + (delayMinutes*60);

      return;
   }

   GetAnimation()
   {
      return piAnimation;
   }

   GetGender()
   {
      return piGender;
   }

   LoseHealth(amount = 0)
   "Handles phase/spectate and trance breaking, Battler handles piHealth."
   {
      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@NewHealth);

         return 0;
      }

      if (amount > 0
         AND (piFlags & PFLAG_TRANCE))
      {
         // Losing 10 percent of our max health causes 100 percent disruption.
         amount = 10*amount/piMax_health;
         Send(self,@BreakTrance,#event=EVENT_DAMAGE,#disruption=amount);
      }

      propagate;
   }

   GetBaseMaxHealth()
   {
      local iStamina;

      iStamina = Send(self,@GetStamina);

      // Bound twice - once for max HP this player can get, once for
      // max HP allowable by the game.
      return Bound(Bound(piBase_max_health,MIN_HEALTH,100 + iStamina),MIN_HEALTH,MAX_HEALTH);
   }

   GetUncappedBaseMaxHealth()
   {
      return piBase_max_health;
   }

   GetLevel()
   {
      return Send(self,@GetBaseMaxHealth);
   }

   GetKillTarget()
   {
      return poKill_target;
   }

   GetTarget()
   {
      return poKill_target;
   }

   SetKillTarget(target=$)
   {
      poKill_target = target;

      return;
   }

   UnboundEnergyTimer()
   {
      ptUnboundEnergy = $;

      Send(self,@LoseUnboundEnergy);

      return;
   }

   EnchantmentTimer(timer = $)
   {
      local i, j, oEnchanter, oSpell;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if First(i) = timer
         {
            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               Send(oSpell,@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(oSpell,@EndEnchantment,#who=self);
            }

            Send(self,@ShowRemoveEnchantment,#what=oSpell,
                  #type=ENCHANTMENT_PLAYER);

            // TODO: i no longer exists at this point?
            // EndEnchantment removing it?

            // Temporary debug log check for errors here.
            if (NOT FindListElem(plEnchantments, i))
            {
               Debug("Player ",vrName," had missing enchantment ",oSpell,
                     Send(oSpell,@GetName)," in EnchantmentTimer.");

               // Print extra info for trance errors.
               if (IsClass(oSpell,&Trance))
               {
                  Debug("Invoking spell is ",Send(First(Nth(i,3)),@GetName));
               }
            }

            plEnchantments = DelListElem(plEnchantments,i);

            // Also remove from passive improvement list.
            foreach j in plPassiveImprovement
            {
               if First(j) = oSpell
               {
                  plPassiveImprovement = DelListElem(plPassiveImprovement,j);
               }
            }

            if Send(oSpell,@IsLightSource)
            {
               Send(self,@RecalcFlickerFlag);
            }

            // Calls SomethingChanged.
            Send(self,@ResetPlayerFlagList,#who=self);

            return;
         }
      }

      foreach i in plRadiusEnchantments
      {
         oSpell = Nth(i,2);
         if First(i) = timer
         {
            if (First(Nth(i,3)) = self) // Nth(state,RE_STATE_CASTER)
            {
               Send(self,@ShowRemoveEnchantment,#what=oSpell,
                     #type=ENCHANTMENT_PLAYER);
            }
            Send(self,@ShowRemoveEnchantment,#what=oSpell,
                  #type=ENCHANTMENT_ROOM);

            Send(oSpell,@EndEnchantment,#who=self,#state=Nth(i,3));

            plRadiusEnchantments = DelListElem(plRadiusEnchantments,i);

            // Also remove from passive improvement list.
            foreach j in plPassiveImprovement
            {
               if First(j) = oSpell
               {
                  plPassiveImprovement = DelListElem(plPassiveImprovement,j);
               }
            }

            // Calls SomethingChanged
            Send(self,@ResetPlayerFlagList,#who=self);

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   PeriodicEnchantmentTimer(timer = $)
   {
      local i ;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            plEnchantments = DelListElem(plEnchantments,i);

            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,
                     #who=self,#state=Nth(i,3),#iSpellPower=Nth(i,4));
            }
            else
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=$,
                     #iSpellPower=Nth(i,3));
            }

            return;
         }
      }

      foreach i in plRadiusEnchantments
      {
         if First(i) = timer
         {
            plRadiusEnchantments = DelListElem(plRadiusEnchantments,i);

            Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=Nth(i,3),
                  #iSpellPower=Nth(i,4));

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   StartEnchantment(what=$,who=$,time=$,state=$,lastcall=TRUE,addicon=TRUE,
                    ltype=$,bItemCast=FALSE,iSpellPower=0,bRadiusEnchant=FALSE)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ OR time = SPELL_INDEFINITE_DURATION 
      {
         oTimer = $;
      }
      else if NOT pbLogged_on
      {
         oTimer = time;
      }
      else if lastcall
      {
         oTimer = CreateTimer(self,@EnchantmentTimer,time);
      }
      else
      {
         oTimer = CreateTimer(self,@PeriodicEnchantmentTimer,time);
      }

      if state = $
      {
         lNew_enchantment = [oTimer, what, iSpellPower];
      }
      else
      {
         lNew_enchantment = [oTimer, what, state, iSpellPower];
      }

      if (bRadiusEnchant)
      {
         plRadiusEnchantments = Cons(lNew_enchantment,plRadiusEnchantments);
      }
      else
      {
         plEnchantments = Cons(lNew_enchantment,plEnchantments);
      }

      // If we are also the source of the enchantment, add the enchantment
      // to our passive improvement list. ltype has the form:
      // [oSpell,Defensive,Offensive,Resistance]
      if who = self
         AND NOT bItemCast
         AND lType <> $
      {
         plPassiveImprovement = Cons(ltype,plPassiveImprovement);
      }

      if Send(what,@IsLightSource)
      {
         Send(self,@SetFlickerFlag);
      }

      Send(self,@ResetPlayerFlagList,#who=self);

      if addicon
      {
         if (bRadiusEnchant)
         {
            Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_ROOM);
            // Show icon if we cast the spell.
            if (who = self)
            {
               Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_PLAYER);
            }
         }
         else
         {
            Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_PLAYER);
         }
      }

      Post(self,@DrawResistances);

      return;
   }

   RemoveAllEnchantments(report=TRUE)
   "Remove all current enchantments and reset the passive improvement list."
   {
      local i;

      foreach i in plEnchantments
      {
         Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
      }

      Send(self,@RemoveAllRadiusEnchantments,#report=report);

      plPassiveImprovement = $;

      return;
   }

   RemoveAllPersonalEnchantments(report=TRUE,override=FALSE)
   "Remove all current *personal* enchantments and reset "
   "the passive improvement list."
   {
      local i, oSpell, removedSomething;

      removedSomething = FALSE;

      // TODO: Need to remove any personal radius enchantments.
      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsPersonalEnchantment)
            AND ((NOT IsClass(oSpell,&DMSpell)) OR override)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
            removedSomething = TRUE;
         }
      }

      // Just to be sure, reset the player's flag list.
      // this should remove any excess flags like invis or shadowform.
      Send(self,@ResetPlayerFlagList);
      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=TRUE);

      plPassiveImprovement = $;

      return removedSomething;
   }

   FreezeAllEnchantments()
   "Called when a player logs off."
   {
      local i, tTimer, iTime, oSpell, iIllusion;

      if (piFlags & PFLAG_PHASED)
      {
         // Rare case where a user can log off while phased, e.g. system restart
         // Phase already froze the enchantments, so we don't need to do it again

         return;
      }

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);

         // If we have the spectate enchantment, remove it.
         if IsClass(oSpell,&Spectate)
         {
            Send(oSpell,@RemoveEnchantmentEffects,#who=self,#report=FALSE);
            Send(self,@ShowRemoveEnchantment,#what=oSpell,
                  #type=ENCHANTMENT_PLAYER);
            plEnchantments = DelListElem(plEnchantments,i);
            Send(self,@ResetPlayerFlagList,#who=self);

            continue;
         }

         tTimer = First(i);
         if tTimer <> $
         {
            if NOT IsClass(oSpell,&Boon)
            {
               // Convert timer to integer if we have a timer,
               // otherwise log for debugging.
               if IsTimer(tTimer)
               {
                  iTime = GetTimeRemaining(tTimer);
                  DeleteTimer(tTimer);

                  // If it's a negative enchantment, add a bit to the time in
                  // order to prevent people from just "flashing" on and off
                  // to wait out an enchantment and be relatively unhittable.
                  // Stateless hold, which is used for logon/phase delay should
                  // be reset to the logon delay time.
                  if (IsClass(oSpell,&Hold) AND Nth(i,3) = 0)
                  {
                     iTime = Send(SETTINGS_OBJECT,@GetLogonDelay);
                  }
                  else if Send(oSpell,@IsHarmful)
                  {
                     // Time is measured in milliseconds, 3000 = 3 seconds.
                     iTime += 3000;
                  }
               }
               else
               {
                  // We probably have an integer when we shouldn't have this
                  // here, and we should log it for debugging.
                  // $ values handled when the player logs in.
                  iTime = First(i);
                  Debug(self, " player ",Send(self,@GetTrueName),
                     " called FreezeAllEnchantments with invalid timer for ",
                     Send(oSpell,@GetName), " timer value ",iTime);
               }

               SetFirst(i,iTime);
            }
         }
      }

      foreach i in plOverTimeEffects
      {
         tTimer = First(i);
         if tTimer <> $
         {
            // Convert timer to integer if we have a timer.
            if IsTimer(tTimer)
            {
               iTime = GetTimeRemaining(tTimer);
               DeleteTimer(tTimer);

               // Special case: Suspending an illusionary effect.
               // For balancing health upon expiration, we need to keep track
               // of how much health has been gained or lost. To do so, we log
               // when the effect has started and calculate the time difference
               // upon expiration. Naturally, this doesn't work well, when the
               // effect is suspended and the time delta keeps growing meanwhile.
               // Instead, we convert the timestamp into a timedelta that can be
               // subtracted from the fresh timestamp when reactivated.
               iIllusion = Nth(i,10);

               if iIllusion > 0
               {
                  SetNth(i,10,Bound(GetTime()-iIllusion,1,$));
               }
            }
            else
            {
               // We should really have had a timer at this stage. Since
               // we haven't, let's assume that the timer has already been
               // converted to an integer. Leave it.
               iTime = tTimer;
            }

            SetFirst(i,iTime);
         }
      }

      // Also stop trying to play periodic sounds stemming from over time effects.
      Send(self,@PeriodicSounds,#bSuspend=TRUE);

      foreach i in plHurtMeRecently
      {
         // Increase time that player attackers are kept track of so that
         // they can be awarded honor points if we pen.
         if (IsClass(First(i),&Player))
         {
            tTimer = Nth(i,3);
            if (tTimer <> $
               AND IsTimer(tTimer))
            {
               iTime = GetTimeRemaining(tTimer);

               if (iTime <= piRemainingPhaseTime)
               {
                  DeleteTimer(tTimer);
                  iTime += piRemainingPhaseTime;
                  SetNth(i,3,CreateTimer(self,@RemoveHurtMeRecently,iTime));
               }
            }
         }
      }

      return;
   }

   ReactivateAllEnchantments()
   "Called when a player logs on."
   {
      local i, iTime, state, oSpell;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);

         // Phase reactivates enchantments while it is still in plEnchantments
         if IsClass(oSpell,&Phase)
            OR IsClass(oSpell,&Spectate)
         {
            continue;
         }

         iTime = First(i);
          // Skip always active timers (e.g. boons).
         if (IsTimer(iTime))
         {
            continue;
         }

         if Length(i) > ENCHANTMENT_LIST_NO_STATE
         {
            state = Nth(i,3);
         }
         else
         {
            state = $;
         }

         if iTime = $
            OR iTime < 1
         {
            // Give them a short timer, and log this for debugging purposes.
            Debug("Trying to make an invalid timer ",iTime," for ",
                  Send(oSpell,@GetTrueName)," on player ",
                  self,Send(self,@GetTrueName));
            if Send(oSpell,@IsHarmful)
            {
               iTime = 5000;
            }
            else
            {
               iTime = 20000;
            }
         }

         if Send(oSpell,@IsPeriodic,#state=state,#who=self)
         {
            SetFirst(i,CreateTimer(self,@PeriodicEnchantmentTimer,iTime));
         }
         else
         {
            SetFirst(i,CreateTimer(self,@EnchantmentTimer,iTime));
         }

         Send(oSpell,@RestartEnchantmentEffect,#who=self,#state=state);
      }

      foreach i in plOverTimeEffects
      {
         iTime = First(i);

         // Nil means that the over time effect has infinite duration. Skip.
         if iTime <> $
         {
            // Well. That is odd. Oh well, let's clean up and get out.
            if IsTimer(iTime) 
            {
               DeleteTimer(iTime);
               iTime = $;
               plOverTimeEffects = DelListElem(plOverTimeEffects,i);
            }
            // Also odd: Should have been deleted already. We know the drill.
            else if iTime < 1
            {
               plOverTimeEffects = DelListElem(plOverTimeEffects,i);
            }
            // That's better. We got a reasonable integer that we can turn into
            // a timer. Create the timer and save it in list initial position.
            else
            {
               SetFirst(i,CreateTimer(self,@DeleteOverTimeEffect,iTime));

               // Special case: We reactivate an illusionary effect. To keep
               // things tidy, we need to create a new time stamp that is extended
               // by the amount of time the DoT has previously been active.
               iTime = Nth(i,10);

               if iTime > 0
               {
                  SetNth(i,10,GetTime()-iTime);
               }
            }
         }
      }

      // Restart periodic sounds stemming from overtime effects.
      Send(self,@PeriodicSounds);

      Send(self,@ResetPlayerFlagList,#who=self);

      return;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj, iIllusion;

      foreach i in plEnchantments 
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      foreach i in plOverTimeEffects 
      {
         iIllusion = Nth(i,10);
         if iIllusion > 0
            AND Random(1,100) <= iChance
         {
            Send(self,@DeleteOverTimeEffect,#removal=iIllusion);
         }
      }

      // Kludgy, but oh well.  Not like any other code from this era is
      // exactly well-engineered or even "good", really.
      foreach i in plActive
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&NecromancerAmulet)
         {
            Send(each_obj,@DispelIllusions);
         }
      }

      return;
   }

   RemoveSchoolEnchantments(school = $,report=TRUE)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   RemoveEnchantment(what = $, report=TRUE)
   "If have a current enchantment set by <what>, end it."
   {
      local i, state;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if pbLogged_On
               OR IsClass(what,&Phase)
               OR IsClass(what,&Boon)
            {
               if First(i) <> $
               {
                  if IsTimer(First(i))
                  {
                     DeleteTimer(First(i));
                  }
                  SetFirst(i,$);
               }
            }
            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               state = Nth(i,3);
            }

            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,
                  #state=state,#report=report);

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);

            plEnchantments = DelListElem(plEnchantments,i);

            if Send(what,@IsLightSource)
            {
               Send(self,@RecalcFlickerFlag);
            }

            Send(self,@ResetPlayerFlagList,#who=self);
         }
      }

      // Also remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if First(i) = what
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

      return;
   }

   RemoveRadiusEnchantment(what=$,state=$,report=TRUE,recheck=FALSE)
   {
      local i, lState;

      foreach i in plRadiusEnchantments
      {
         if (what = Nth(i,2))
         {
            lState = Nth(i,3);
            if (First(state) = First(lState)
               AND Nth(state,2) = Nth(lState,2))
            {
               if First(i) <> $
               {
                  if IsTimer(First(i))
                  {
                     DeleteTimer(First(i));
                  }
                  SetFirst(i,$);
               }

               // Everyone has the room icon, only caster has player icon.
               Send(self,@ShowRemoveEnchantment,#what=what,
                     #type=ENCHANTMENT_ROOM);
               if (First(lState) = self) // Nth(state,RE_STATE_CASTER)
               {
                  Send(self,@ShowRemoveEnchantment,#what=what,
                        #type=ENCHANTMENT_PLAYER);
               }

               plRadiusEnchantments = DelListElem(plRadiusEnchantments,i);

               Send(what,@RemoveEnchantmentEffects,#who=self,
                     #state=lState,#report=report,#recheck=recheck);

               Send(self,@ResetPlayerFlagList,#who=self);
            }
         }
      }

      // Also remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if First(i) = what
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

      // If logged on, see if we should get enchanted by another radius
      // enchantment.
      if (recheck AND poOwner <> $)
      {
         SendListByClass(Send(poOwner,@GetHolderActive),1,&NoMoveOn,
               @NoMoveOnRadiusEnchCheckOne,#who=self);
      }

      return;
   }

   RemoveEnchantmentClass(class = &Object)
   "If have a current enchantment set by anything in class, end it."
   {
      local i;

      // Remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if IsClass(First(i),class)
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

      // Rest of this now done in Battler.
      propagate;
   }

   GetPassiveImprovementList()
   "Returns the list of currently active, self-cast buffs, that "
   "the player is eligible to improve in passively."
   {
      return plPassiveImprovement;
   }

   SendEnchantmentIcons()
   "Users do this after GC to redisplay their enchantments"
   {
      local i,each_obj;

      foreach i in plEnchantments
      {
         each_obj = Nth(i,2);
         if NOT (IsClass(each_obj,&Seance)
            OR IsClass(each_obj,&IllusionaryWounds))
         {
            Send(self,@ShowAddEnchantment,#what=each_obj,
                  #type=ENCHANTMENT_PLAYER);
         }
      }

      // Just send the ones we are the source for, Room handles all others.
      foreach i in plRadiusEnchantments
      {
         if (Nth(Nth(i,3),RE_STATE_SOURCE) = self)
         {
            Send(self,@ShowAddEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);
         }
      }

      // Just send the ones we are the source for, Room handles all others.
      foreach i in plOverTimeEffects
      {
         if Nth(i,8)
         {
            Send(self,@ShowAddEnchantment,#what=Nth(i,5),#type=ENCHANTMENT_PLAYER);
         }
      }

      if ptCrystalizeManaSurgeTimer <> $
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSpellByNum,
            #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
      }

      return;
   }

   AddAttackModifier(what = $)
   "Adds <what> to plAttack_modifiers, which can modify attack "
   "strength and damage."
   {
      plAttack_modifiers = Cons(what,plAttack_modifiers);
      if (pbLogged_on)
      {
         Post(self,@DrawOffense);
      }

      return;
   }

   RemoveAttackModifier(what = $)
   "Removes <what> from plAttack_modifiers."
   {
      if (FindListElem(plAttack_modifiers, what))
      {
         plAttack_modifiers = DelListElem(plAttack_modifiers,what);
         if (pbLogged_on)
         {
            Post(self,@DrawOffense);
         }
      }
      else if (NOT (IsClass(what,&KillingFields)
                 OR IsClass(what,&ForcesOfLight)))
      {
         Debug(self,vrName, "Tried to remove attack modifier",what,
               Send(what,@GetName)," not in list",plAttack_modifiers);
      }

      return;
   }

   AddDefenseModifier(what = $)
   "Adds <what> to plDefense_modifiers, which can modify defense strength "
   "and damage."
   {
      plDefense_modifiers = Cons(what,plDefense_modifiers);
      if pbLogged_on
      {
         Post(self,@DrawDefense);
         Post(self,@DrawArmor);
      }

      return;
   }

   RemoveDefenseModifier(what = $)
   "Removes <what> from plDefense_modifiers. If <what> is present more than "
   "once in the defense modifier list, removes only one copy."
   {
      if (FindListElem(plDefense_modifiers, what))
      {
         plDefense_modifiers = DelListElem(plDefense_modifiers,what);
         if pbLogged_on
         {
            Post(self,@DrawDefense);
            Post(self,@DrawArmor);
         }
      }
      else
      {
         Debug(self,vrName, "Tried to remove defense modifier",what,
               Send(what,@GetName)," not in list",plDefense_modifiers);
      }

      return;
   }

   //
   // Squelch functions.
   //

   SquelchPlayer(value=$,type=PFLAG2_SQUELCHED_ALL)
   "Sets if a player can communicate or not.  Toggles condition by default."
   {
      local bSquelched;

      bSquelched = value;

      if bSquelched = $
      {
         // Toggle the current state.
         bSquelched = NOT Send(self,@CheckPlayerFlag,#flag=type,#flagset=2);
      }

      Send(self,@SetPlayerFlag,#flag=type,#value=bSquelched,#flagset=2);

      return bSquelched;
   }

   IsPlayerSquelched()
   {
      return ((PFLAG2_SQUELCHED_ALL & piFlags2)
         OR (piFlags2 & PFLAG2_SQUELCHED_APPEAL));
   }

   TrySay()
   "Called when user wants to say something. Return TRUE/FALSE.  "
   "If this returns FALSE, it will also block broadcasts and guild sends."
   {
      if piFlags2 & PFLAG2_SQUELCHED_SAYS
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      return TRUE;
   }

   TryBroadcast()
   "Called when the user wants to broadcast a string.  Return TRUE/FALSE, "
   "and use some mana too."
   {
      local iCost;

      if (piFlags2 & PFLAG2_SQUELCHED_BCAST)
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      // Percent, 0-100 (101+ means broadcasts off).
      iCost = Send(SETTINGS_OBJECT,@GetBroadcastManaCost);

      if (iCost > 100)
      {
         Send(self,@MsgSendUser,#message_rsc=player_broadcasts_off);

         return FALSE;
      }

      // Don't need to divide by 100 as piMana is scaled by a factor of 100.
      iCost *= piMax_mana;

      if (iCost > 0)
      {
         if (piMana < iCost)
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_broadcast);

            return FALSE;
         }

         // Override so phased players lose mana too.
         Send(self,@LoseMana,#amount=iCost,#precision=TRUE,#override=TRUE);
      }

      return TRUE;
   }

   TrySayGroup(users=$)
   "Called when the user wants to say a string to a list of people.  "
   "Return TRUE/FALSE."
   {
      if piFlags2 & PFLAG2_SQUELCHED_TELLS
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      return TRUE;
   }

   //
   // End squelch functions.
   //

   CheckPosition(what=$,type=$,space=0)
   {
      local i, iSpace, bToken;

      if space = 0 OR type = $ OR what = $
      {
         return FALSE;
      }

      bToken = FALSE;

      iSpace = space;
      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & type
         {
            iSpace -= Send(i,@GetItemUseAmount);
         }

         if (IsClass(i,&Token) OR IsClass(i,&Totem))
         {
            bToken = TRUE;
         }
      }

      if iSpace < Send(what,@GetItemUseAmount)
      {
         if IsClass(what,&Token) OR IsClass(what,&Totem)
         {
            return FALSE;
         }

         // These unequip amongst themselves automatically.
         if IsClass(what,&Gauntlet)
         {
            return TRUE;
         }

         // Defense modifiers unequip the competing item, but if the player
         // has a token or totem they cannot equip another hand slot item.
         if IsClass(what,&DefenseModifier)
            AND NOT (bToken
               AND type = ITEM_USE_HAND)
         {
            return TRUE;
         }

         if type = ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full_hands);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full);
         }

         return FALSE;
      }

      return TRUE;
   }

   TryUseItem(what = $)
   {
      local i,iSpace,iUse_type;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_use);

         return FALSE;
      }

      if (piFlags & PFLAG_MORPHED)
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);

         return FALSE;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return FALSE;
      }

      if IsClass(what,&ReagentBag)
      {
         if Send(what,@GetReagentBagContents) = $
         {
            Send(self,@MsgSendUser,#message_rsc=player_regbag_empty);

            return FALSE;
         }

         Send(self,@UserObjectContents,#what=what);

         return TRUE;
      }

      iUse_type = Send(what,@GetItemUseType);

      if iUse_type & ITEM_SINGLE_USE
      {
         return Send(self,@TryApplyItem,#what=what,#apply_on=self);
      }

      if iUse_type & ITEM_BROKEN
      {
         Send(self,@MsgSendUser,#message_rsc=player_use_broken,
               #parm1=Send(what,@GetDef),
               #parm2=Send(what,@GetName));

         return FALSE;
      }

      if iUse_type & ITEM_CANT_USE
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);

         return FALSE;
      }

      if NOT Send(what,@ReqUse,#what=self)
      {
         return FALSE;
      }

      // make sure nothing in room disallows
      if poOwner <> $
         AND NOT Send(poOwner,@ReqSomethingUse,#what=self,#use_item=what)
      {
         return FALSE;
      }

      // make sure not already using or something using disallows
      foreach i in plUsing
      {
         if i = what
         {
            Send(self,@MsgSendUser,#message_rsc=player_using_already);

            return FALSE;
         }

         if NOT Send(i,@ReqUseSomething,#what=what)
         {
            return FALSE;
         }
      }

      if (iUse_type & ITEM_USE_HAND)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_HAND,#space=viHand_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_BODY)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_BODY,#space=viBody_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_NECK)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_NECK,#space=viNeck_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_QUIVER)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_QUIVER,#space=viQuiver_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_FINGER)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_FINGER,#space=viFinger_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_GAUNTLET)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_GAUNTLET,#space=viGauntlet_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_HEAD)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_HEAD,#space=viHead_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_LEGS)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_LEGS,#space=viLeg_space)
      {
         return FALSE;
      }

      plUsing = Cons(what,plUsing);
      Send(self,@NewUsing,#what=what);
      Send(what,@NewUsed,#what=self);

      if poOwner
      {
         Send(poOwner,@SomethingUsed,#what=self,#use_item=what);
      }

      Send(self,@ResetPlayerFlagList);
      Post(self,@DrawResistances);

      return TRUE;
   }

   TryUnuseItem(what = $)
   {
      local bFound, i;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_use);

         return FALSE;
      }

      bFound = FALSE;

      //check and see if item disallows
      foreach i in plUsing
      {
         if i = what
         {
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         // This can happen if TryUnuseItem is called in, for example,
         // a ring of invisibility when you log off.
         return FALSE;
      }

      if Send(what,@ReqUnuse)
      {
         Post(self,@ResetPlayerFlagList);

         return Send(self,@UnuseItem,#what=what);
      }

      return FALSE;
   }

   UnuseItem(what = $, Recalibrate = FALSE)
   {
      local i;

      foreach i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            Send(self,@NewUnusing,#what=what);
            
            if Recalibrate
            {
               Send(what,@NewUnused,#what=self,#Recalibrate=TRUE);
            }
            else
            {
               Send(what,@NewUnused,#what=self);
            }

            if pbLogged_on
            {
               Post(self,@DrawResistances);
            }

            return TRUE;
         }
      }

      Send(self,@MsgSendUser,#message_rsc=player_not_using);

      return FALSE;
   }

   TryApplyItem(what = $,apply_on = $)
   {
      local i,iUse_type;

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
               #parm1=Send(what,@GetName));

         return FALSE;
      }

      iUse_type = Send(what,@GetItemUseType);
      if iUse_type <> ITEM_SINGLE_USE
      {
         if iUse_type = ITEM_BROKEN
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_broken,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_apply,
                  #parm1=Send(what,@GetIndef),#parm2=Send(what,@GetName));
         }

         // Error
         return FALSE;
      }

      // make sure nothing in room disallows
      if NOT Send(poOwner,@ReqSomethingApply,#what=self,#use_item=what,#apply_on=apply_on)
      {
         return FALSE;
      }

      if Send(what,@ReqNewApply,#what=self,#apply_on=apply_on)
      {
         Send(what,@NewApplied,#what=self,#apply_on=apply_on);
         Send(poOwner,@SomethingApplied,#what=self,#use_item=what,#apply_on=apply_on);
      }

      Send(self,@ResetPlayerFlagList);

      return TRUE;
   }

   CanAdvance()
   {
      return TRUE;
   }

   AllowBattlerAttack(victim=$,stroke_obj=$,use_weapon=$,report=TRUE,
                     actual=TRUE,minion=FALSE,oRoomOverride=$)
   "Will not let a person attack someone who isn't pkill_enabled."
   "Will not let a person who isn't pkill_enabled attack another person."
   {
      local oRoom, oGuild, oSpell, oVictimGuild;

      // Must have a target.
      if (victim = $)
      {
         return FALSE;
      }

      // Default location to check is the room the victim is in.
      // This allows X-room atacks (such as firewalls) to work.
      oRoom = Send(victim,@GetOwner);

      // Check if we are in the same room as our victim.
      if oRoom <> poOwner
      {
         // If we are not, check if we have been fed an override.
         if (oRoomOverride <> $)
         {
            oRoom = oRoomOverride;
         }
      }

      // Our victim has left the world of the living since we started plotting
      // our attack. Let's leave it in peace.
      if oRoom = $
      {
         return FALSE;
      }

      // No attacking NPCs.
      if (IsClass(victim,&Monster)
         AND NOT Send(victim,@CanMonsterFight,#who=self,#oStroke=stroke_obj,
                        #use_weapon=use_weapon))
      {
         return FALSE;
      }

      // Can always attack Escaped Convict regardless of room
      if IsClass(victim,&EscapedConvict)
      {
         return TRUE;
      }

      // Make sure room allows the attack. Check if room has
      // special combat affects.
      if actual
         AND NOT Send(oRoom,@ReqSomethingAttack,#what=self,#victim=victim,
                     #use_weapon=use_weapon,#stroke_obj=stroke_obj,
                     #report=report,#actual=actual)
      {
         return FALSE;
      }

      // Don't halo non-attackables in guild_pk_only zones (typically an
      // unguilded outlaw). Necessary because it just looks confusing
      if NOT actual
         AND NOT Send(oRoom,@AllowGuildAttack,#what=self,#victim=victim)
      {
         return FALSE;
      }

      // If we're in an arena or chaos zone and it let us attack, then
      // it's a legal attack.
      if Send(oRoom,@IsArena)
         OR Send(oRoom,@GetChaosZone)
      {
         return TRUE;
      }

         // If snowballs are set to do 0 damage, bypass checks.
         if (actual
            AND use_weapon <> $
            AND IsClass(use_weapon,&Snowball)
            AND NOT Send(use_weapon,@CanDoDamage))
         {
            return TRUE;
         }

      // Frenzies!  Anything goes if allowed by the room!
      if Send(SYS,@GetChaosNight)
      {
         if Send(Send(SYS,@GetWarEvent),@IsActive)
         {
            // If there's a war event going, disallow attacks between teammates.
            if Send(Send(SYS,@GetWarEvent),@IsSameSide,#player1=self,#player2=victim)
               AND NOT Send(Send(SYS,@GetWarEvent),@CanAttackAllies)
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_ally,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }

               return FALSE;
            }
         }

         return TRUE;
      }

      // Check for guildmates and allies
      if IsClass(victim,&User)
         AND victim <> self
      {
         oVictimGuild = Send(victim,@GetGuild);
         oGuild = poGuild;
         if oVictimGuild <> $
            AND oGuild <> $
            AND (oGuild = oVictimGuild
               OR Send(oGuild,@IsAlly,#otherguild=oVictimGuild))
         {
            if report
            {
               if oGuild = oVictimGuild
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_guildmate,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }
               if Send(oGuild,@IsAlly,#otherguild=oVictimGuild)
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_ally,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }
            }

            return FALSE;
         }
      }

      // Check for temporary safety flag.
      if IsClass(victim,&User)
         AND ((piFlags & PFLAG_TEMPSAFE)
            OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_TEMPSAFE))
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                  #parm1=Send(victim,@GetDef),
                  #parm2=Send(victim,@GetName));
         }

         return FALSE;
      }

      // Can always attack mortal event characters.
      if IsClass(victim,&DM)
         AND Send(victim,@IsEventCharacter)
         AND NOT Send(victim,@PlayerIsImmortal)
      {
         return TRUE;
      }

      if actual
         AND Send(self,@IsInCannotInteractMode)
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=cannot_attack_phased_self_rsc);
         }
         return FALSE;
      }

      if IsClass(victim,&User)
         AND Send(victim,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      if IsClass(victim,&Monster)
      {
         /*oSpell = Send(SYS,@FindSpellByNum,#num=SID_TRUCE);
         if (Send(oRoom,@GetEnchantedState,#what=oSpell) <> $)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_truced);
            }

            return FALSE;
         }*/

         if IsClass(victim,&Reflection)
            OR IsClass(victim,&EvilTwin)
            OR Send(victim,@GetMaster) <> $
         {
            if (Send(victim,@IsOwnedByPlayer))
            {
               // Newbies can't attack players' pets.
               if (NOT Send(self,@CanPlayerPvP))
               {
                  if (report)
                  {
                     if (piFlags & PFLAG_PERMA_NO_PVP)
                     {
                        Send(self,@MsgSendUser,
                              #message_rsc=player_cant_hit_optout_minion);
                     }
                     else
                     {
                        Send(self,@MsgSendUser,
                              #message_rsc=player_cant_hit_newbie_minion);
                     }
                  }

                  return FALSE;
               }

               // No attacking players' pets on Sacred Haven.
               if (NOT Send(SYS,@IsPKAllowed))
               {
                  if (report)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                          #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
                  }

                  return FALSE;
               }
            }

            if Send(victim,@GetMaster) = self
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=player_own_minion);
               }

               return FALSE;
            }

            // Check status and safety against the owner of the minion.
            if NOT Send(self,@AllowBattlerAttack,
                        #victim=Send(victim,@GetMaster),
                        #use_weapon=use_weapon,#stroke_obj=stroke_obj,
                        #report=report,#actual=actual,#minion=TRUE,
                        #oRoomOverride=oRoom)
            {
               return FALSE;
            }
         }

         if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=Jig_cannot_attack,
                     #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
            }

            return FALSE;
         }

         if IsClass(victim,&Follower)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_cannot_attack_follower);
            }

            return FALSE;
         }
      }
      else
      {
         // Not a monster; is a player.

         // No player attacks on Sacred Haven, but allow DM attacks for events.
         if NOT Send(SYS,@IsPKAllowed)
            AND NOT IsClass(victim,&DM)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safe_server);
            }

            return FALSE;
         }

         // This prevents attacks on immortal DMs.
         if NOT Send(victim,@IsLikelyVictim)
         {
            return FALSE;
         }

         if NOT Send(oRoom,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
         {
            if NOT Send(self,@CanPlayerPvP)
            {
               // A newbie (someone below GetPKillEnableHP) tried to attack
               // another player! note that this does not affect murderers
               // who have been knocked below this level by angry retributers.

               if report
                  AND victim <> self
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     if (piFlags & PFLAG_PERMA_NO_PVP)
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_cant_hit_optout);
                     }
                     else
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_cant_hit_newbie);
                     }
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }
            
               return FALSE;
            }

            // Can attack non-pvpable players if they're holding a token.
            if NOT Send(victim,@CanPlayerPvP)
               AND NOT Send(victim,@PossessesA,#class=&Token)
            {
               // The target is a newbie. Murderers are perfectly attackable
               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                           #parm1=Send(victim,@GetDef),
                           #parm2=Send(victim,@GetName));
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }

               return FALSE;
            }
         }
      }

      if IsClass(oRoom,&GuildHall)
      {
         return TRUE;
      }

      // Finally, check status and safety.
      if NOT Send(self,@CheckStatusAndSafety,#victim=victim,
                  #report=report,#actual=actual,#minion=minion,
                  #stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      // Stop any rescue attempts if the user makes an attack.
      if ptRescue <> $
         AND actual
      {
         Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue);
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      return TRUE;
   }

   CheckStatusAndSafety(victim=$,report=TRUE,actual=TRUE,minion=FALSE,
                        stroke_obj=$)
   "CF_SAFETY_OFF prevents accidental attacks. You can always successfully "
   "hit a murderer or outlaw, though."
   {
      local oEnemyGuild, oSoldierShield, iPenTime;

      // Don't care about monsters or token holders...
      if IsClass(victim,&Monster)
         OR (Send(victim,@FindUsing,#class=&Token) <> $)
      {
         // ...unless they are our side kick...
         if IsClass(victim,&Monster)
            AND NOT Send(self,@CheckMercAttack,#what=victim,#report=report)
         {
            return FALSE;
         }

         // or they're factioned.
         if NOT Send(self,@CheckFactionAttack,#what=victim,#report=report,
                     #stroke_obj=stroke_obj)
         {
            return FALSE;
         }

         return TRUE;
      }

      // We don't penalize you for trying to hurt yourself.
      // Also don't care about Morphed or Anonymous players.
      if (victim = self)
         OR (IsClass(victim,&Player)
            AND (Send(victim,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_MORPHED)))
      {
         return TRUE;
      }
      
      // No penalties for chaos zone battles
      if poOwner <> $
         AND Send(victim,@GetOwner) <> $
         AND IsClass(poOwner,&Room)
         AND IsClass(Send(victim,@GetOwner),&Room)
         AND Send(poOwner,@GetChaosZone)
         AND Send(Send(victim,@GetOwner),@GetChaosZone)
      {
         return TRUE;
      }

      oEnemyGuild = Send(victim,@GetGuild);
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      // Check for enemy guild or faction soldier fighting - If attacking a (mutual)
      //  enemy, then they can whack on each other freely, without outlaw penalty
      //  or faction loss.
      if (poGuild <> $
            AND oEnemyGuild <> $
            AND Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
         OR (oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#what=victim))
      {
         // Okay, attack is against a player, so record the time
         if actual = TRUE
         {
            piTimeAttackedPlayer = GetTime();
         }

         return TRUE;
      }

      // Check to see if we deserve to be an outlaw.
      if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         AND NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
      {
         if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
         {
            // If your opponent is not a murderer or outlaw, you must
            // have your 'safety' off to attack anyone.
            if report
            {
               if minion
               {
                  Send(self,@MsgSendUser,#message_rsc=player_safety_caught_minion,
                        #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                        #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
            }

            return FALSE;
         }
         else
         {
            if NOT (piFlags & PFLAG_MURDERER)
               AND NOT (piFlags & PFLAG_OUTLAW)
               AND actual = TRUE
            {
               // attacking someone who is without fault is cause to
               // gain the outlaw flag.
               if minion
               {
                  Send(self,@MsgSendUser,#message_rsc=player_aggressor_minion,
                        #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=player_aggressor);
               }
               Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=TRUE);

               // Make sure phase/ghost time is below new upper bound.
               iPenTime = Send(SETTINGS_OBJECT,@GetOutlawMurdererLogPenGhostTime);
               piRemainingPhaseTime = Bound(piRemainingPhaseTime,0,iPenTime);

               Send(self,@EvaluatePKStatus,#dbug=TRUE);
            }
         }
      }

      // Check for faction loss.  Handles appropriate conditions.
      if actual = TRUE
         AND NOT Send(self,@CheckFactionAttack,#what=victim,#report=report,
                        #stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      // Okay, attack is against a player, so record the time
      if actual = TRUE
      {
         piTimeAttackedPlayer = GetTime();
      }

      return TRUE;
   }

   CheckFactionAttack(what=$,stroke_obj=$,report=TRUE)
   "Checks if you are attacking something in the same faction as you are. "
   "Boots you out of your faction if you attack an innocent or a monster. "
   "Safety will catch a bad attack, however."
   {
      local bBooted, rMessage;

      // If attacking nothing, or faction is neutral, or attacking self
      //   or in the Arena, or during a Frenzy, don't go any further.
      if what = $
         OR piFaction = FACTION_NEUTRAL
         OR what = self
         OR (poOwner <> $ AND Send(poOwner,@IsArena))
         OR Send(SYS,@GetChaosNight)
      {
         return TRUE;
      }

      // If faction loss is disabled, then attacking a user never boots you
      if NOT Send(SETTINGS_OBJECT,@FactionLossEnabled)
         AND IsClass(what,&User)
      {
         return TRUE;
      }

      bBooted = FALSE;

      // Checking for faction alignment. If you attack something of your
      // own faction, you get busted!
      if (Send(what,@GetFaction) = piFaction)
      {
         // Attacks vs. Outlaws, Murderers are not punishable by booting,
         // so just return. Also, attacks vs. anonymous or morphed people
         // are not punishable.
         if (IsClass(what,&User))
            AND (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED))
         {
            return TRUE;
         }

         bBooted = TRUE;
         rMessage = player_faction_attacked;
      }

      // Preying on non-intriguing, white-named newbies boots ya, too.
      if IsClass(what,&User)
         AND NOT Send(what,@PlayerIsIntriguing)
         AND NOT (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW))
      {
         bBooted = TRUE;
         rMessage = player_non_intriguing_attacked;
      }

      if bBooted
      {
         // On sacred haven servers, let users attack their own faction
         // soldiers to drop shield and faction regardless of safety.
         if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
            AND NOT (NOT Send(SYS,@IsPKAllowed) AND NOT IsClass(what,&User))
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }

            return FALSE;
         }

         // Area effects (room enchants, radius enchants, EQ, ice nova) are too
         // hard to use if accidentally being in range of a factioned target can
         // cause you to lose faction/shield. Let these attacks succeed without
         // taking faction away. Disallow minion attacks from losing faction for
         // the same reason. This means a lot of indirect attacks won't cause
         // faction loss, but also won't cause frustration.
         if (stroke_obj <> $
            AND (Send(stroke_obj,@IsAreaEffect)
               OR (IsClass(stroke_obj,&Monster)
                  AND Send(stroke_obj,@IsMinion))))
         {
            return TRUE;
         }

         // Get booted.
         Send(self,@MsgSendUser,#message_rsc=rMessage);
         Send(self,@ResignFaction);
      }

      return TRUE;
   }

   CheckMercAttack(what=$,report=TRUE)
   "Checks attacks against mercenaries."
   {
      local oLeader;

      oLeader = Send(what,@GetLeader);

      if oLeader = self
         AND NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }

         return FALSE;
      }

      return TRUE;
   }

   GetLastPlayerAttackTime()
   "Returns the last time the player attacked another player."
   {
      return piTimeAttackedPlayer;
   }

   CanHelpPlayer()
   "Checks to see if can be affected by spells cast by angeled characters."
   {
      if (piTimeAttackedPlayer + ATTACKED_PLAYER_WAIT) > GetTime()
         AND NOT Send(SYS,@GetChaosNight)
      {
         return FALSE;
      }

      return TRUE;
   }

   // Like CanHelpPlayer, but checks whether they have been attacked as well as
   // whether they have attacked anyone. CanHelpPlayer allows helping those
   // who have been attacked but haven't reciprocated, CanHelpPlayerStrict
   // checks if they have been involved in any sort of combat with other players.
   CanHelpPlayerStrict()
   {
      local iTime;

      if (Send(SYS,@GetChaosNight))
      {
         return TRUE;
      }

      iTime = GetTime();

      return piTimeAttackedByPlayer + ATTACKED_PLAYER_WAIT < iTime
         AND piTimeAttackedPlayer + ATTACKED_PLAYER_WAIT < iTime;
   }

   TryAttack(what = $, use_weapon = $, stroke_obj = $, bCheck = TRUE)
   {
      local i, iRange, oSpell, state;

      // Can't target self.
      if what = self
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_target_self);
         
         return FALSE;
      }

      // Check attack time.
      if bCheck AND NOT Send(self,@IsOkayAttackTime)
      {
         return FALSE;
      }

      // Is it in the same room?
      if poOwner <> Send(what,@GetOwner) 
      {
         return FALSE;
      }

      // Holding a token?  Then don't let them attack
      if GetListElemByClass(plPassive,&Token) <> $
      {
         return FALSE;
      }

      // Can pay costs?  Only check for skills, spells have already been cast.
      if IsClass(stroke_obj,&Skill)
         AND NOT Send(stroke_obj,@CanPayCosts,#who=self,#lTargets=[what])
      {
         return FALSE;
      }

      // Deny attack if no line of sight
      if NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);

         return FALSE;
      }

      // Send to the STROKE to get the range; unarmed attacks have ranges too
      iRange = Send(stroke_obj,@GetRange,#weapon_used=use_weapon);

      // A little fudge factor to account for lag drift, etc.
      //  Don't fudge for ranged weapons.
      if IsClass(what,&User) AND Send(what,@HasMovedRecently)
         AND (use_weapon <> $ AND NOT IsClass(use_weapon,&RangedWeapon))
      {
         iRange = iRange + RANGE_MOVEMENT_BONUS;
      }

      if NOT Send(self,@TargetWithinSightAndRange,#oTarget=what,#iRange=iRange,
                  #use_weapon=use_weapon,#stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      // Special case attacks
      if use_weapon <> $
      {
         // Black dagger.
         if IsClass(use_weapon,&BlackDagger)
            AND IsClass(stroke_obj,&Stroke)
         {
            // Let the assassin's game handle it
            return Send(Send(SYS,@GetAssassinGame),@TryAssassinAttack,
                        #attacker=self,#target=what,#dagger_obj=use_weapon);
         }

         // Deliverance touch attack for DMs. Handled here to trigger attack
         // timer and range checks.
         if (IsClass(use_weapon,&DeliveranceTouch))
         {
            return Send(use_weapon,@TryDeliveranceAttack,#who=self,
                        #oTarget=what);
         }
      }

      if IsClass(what,&Monster)
      {
         // Check if its a non hittable monster
         if NOT Send(what,@CanMonsterFight,#who=self,#oStroke=stroke_obj,
                     #use_weapon=use_weapon)
         {
            return FALSE;
         }

         if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
         {
            Send(self,@MsgSendUser,#message_rsc=Jig_cannot_attack,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

            return FALSE;
         }

         // Tell the monster this is a valid attack.
         Send(what,@ValidAttack,#who=self);
      }

      // Checking for legal PK attack here.
      if NOT Send(self,@AllowBattlerAttack,#victim=what,#stroke_obj=stroke_obj,
                  #use_weapon=use_weapon)
      {
         return FALSE;
      }

      // If this attack initiates pvp, notify victim (combatants maybe?) 
      // initially, but then not again until PVP_NOTIFY_DECAY has passed
      if IsClass(what,&User)
      {
         Send(what,@DoPvpNotify);
      }

      // Okay, checking is done, attack is okay.  Do the animation thing.
      if NOT Send(stroke_obj,@CheckWeaponAndDoAnimation,#who=self,
                  #weapon_used=use_weapon,#victim=what)
      {
         return FALSE;
      }

      // Switching targets?
      // Do this before paying skill costs, otherwise projectiles
      // will try to find our "kill target" and fail.
      if poKill_target <> what
      {
         if (poKill_target <> $)
         {
            Send(self,@ResetGainFlags);
         }
         poKill_target = what;
      }

      // Pay costs here. Only check skills, because spells are already cast.
      if IsClass(stroke_obj,&Skill)
      {
         Send(stroke_obj,@PayCosts,#who=self);
      }

      // Special case:  Ranged weapons in windy room.
      //  Do this after paying the costs so that the arrow is used.
      if use_weapon <> $
         AND (IsClass(use_weapon,&RangedWeapon)
            OR IsClass(use_weapon,&ThrownWeapon))
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_WINDS);
         state = Send(poOwner,@GetEnchantedState,#what=oSpell);
         if (state <> $
            AND Send(oSpell,@TryRuinShot,#who=self,#state=state))
         {
            return FALSE;
         }

         oSpell = Send(SYS,@FindSpellByNum,#num=SID_SANDSTORM);
         state = Send(poOwner,@GetEnchantedState,#what=oSpell);
         if (state <> $
            AND Send(oSpell,@TryRuinShot,#who=self,#state=state))
         {
            return FALSE;
         }
      }

      // Record the swing for potential advancement.
      if Send(what,@CanPlayerAdvanceOnMe)         
      {
         // We got another swing in, so increment that.
         Send(self,@SwingWeapon,#times=1);
      }

      // Give offensive buffs a small chance to improve each swing!
      foreach i in plPassiveImprovement
      {
         if Nth(i,3) AND Random(1,50) = 50
         {
            Send(First(i),@ImproveAbility,#who=self,#target=what);
         }
      }

      propagate;
   }

   GetTimeAttacked()
   {
      return piLastTimeAttacked;
   }

   // Determines if target is within attacking range, and within sight.
   // iRange=$ means there's no range check.
   TargetWithinSightAndRange(oTarget=$,iRange=$,use_weapon=$,stroke_obj=$)
   {
      local iDist, oTargetOwner, oFinalTarget, iAngle, iRow, iCol,
            iTargetRow, iTargetCol;

      oTargetOwner = Send(oTarget,@GetOwner);

      // We are always in range of ourselves or anything we carry.
      if oTarget = self
         OR oTargetOwner = self
      {
         return TRUE;
      }

      oFinalTarget = oTarget;

      // Strange case of us targeting something that someone else is holding.
      // This cannot be owned by us, since we already checked that.
      if oTargetOwner <> $
         AND IsClass(oTargetOwner,&Battler)
      {
         oFinalTarget = oTargetOwner;
         oTargetOwner = Send(oFinalTarget,@GetOwner);
      }

      // If we don't share the same owner, then we're not in range.
      if poOwner <> oTargetOwner
      {
         return FALSE;
      }

      iDist = Send(self,@SquaredFineDistanceTo3D,#what=oFinalTarget);

      // See if target is within range, if we provided a range.
      if iRange <> $
         AND iDist > iRange * iRange
      {
         Send(self,@SendAttackOutOfRangeMessage,#what=oFinalTarget,
              #use_weapon=use_weapon,#stroke_obj=stroke_obj);

         return FALSE;
      }

      // See if target is in a reasonable viewing area.
      // Only applies to weapon strokes and single-target spells.
      if IsClass(oFinalTarget,&Battler)
         AND stroke_obj <> $
         AND (IsClass(stroke_obj,&Stroke)
            OR (IsClass(stroke_obj,&Spell)
               AND Send(stroke_obj,@GetNumSpellTargets) = 1))
      {
         if iDist > 1
            AND NOT LineOfSightView(Send(self,@GetAngle), piRow, piCol, piFine_row,
                        piFine_col, Send(oTarget,@GetRow), Send(oTarget,@GetCol),
                        Send(oTarget,@GetFineRow), Send(oTarget,@GetFineCol))
         {
            if iDist > 2
               AND IsClass(oFinalTarget,&Player)
               AND Send(self,@CheckLog)
            {
               Debug("ALERT! ",Send(self,@GetTrueName),self," at "
                     "[",piRow,piCol,"] and angle ",Send(self,@GetAngle),
                     " tried to hit ", Send(oFinalTarget,@GetTrueName),
                     oFinalTarget," at [",Send(oTarget,@GetRow),
                     Send(oTarget,@GetCol),"] that was behind them.");
            }

            Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);

            return FALSE;
         }
      }

      return TRUE;
   }

   // This returns the battler's ability to-hit.  Ranges from 1 to 1000
   GetOffense(what = $, stroke_obj=$)
   {
      local i, oWeapon, iStroke, iProficiency, iAim, iOffense, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iOffense = Send(oMonster,@GetOffense,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         // A player's offense is based on his stroke (basic),
         // proficiency (advanced) skills, aim and max hps.
         oWeapon = Send(self,@GetWeapon);

         if oWeapon <> $
         {
            // Get weapon's numbers.
            iStroke = Send(oWeapon,@GetStroke,#who=self);
            iProficiency = Send(oWeapon,@GetProf,#who=self);
         }
         else
         {
            // Unarmed
            iStroke = Send(self,@GetSkillAbility,#skill_num=SKID_PUNCH);
            iProficiency = Send(self,@GetSkillAbility,#skill_num=SKID_BRAWLING);
         }

         iAim = Send(self,@GetAim);
         iOffense = (iStroke*2) + (iProficiency*2) + (iAim*8) +
               (200 * Send(self,@GetBaseMaxHealth))
               / (100 + Send(self,@GetStamina));

         if oWeapon <> $
         {
            iOffense = Send(oWeapon,@ModifyHitRoll,#target=what,
                  #hit_roll=iOffense);
         }
      }

      // List of items and spells that affect chance-to-hit
      foreach i in plAttack_modifiers
      {
         iOffense = Send(i,@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#stroke_obj=stroke_obj);
      }

      foreach i in plRadiusEnchantments
      {
         iOffense = Send(Nth(i,2),@ModifyHitRoll,#who=self,#what=what,
                           #hit_roll=iOffense,#state=Nth(i,3));
      }

      iOffense += Send(Send(SYS,@GetParliament),@GetFactionHitrollBonus,
                        #who=self,#stroke_obj=stroke_obj);

      // If we're using a ranged weapon and don't have a clear line of sight,
      //  then half our offense.
      if what <> $
         AND oWeapon <> $
         AND (IsClass(oWeapon,&RangedWeapon)
            OR IsClass(oWeapon,&ThrownWeapon))
         AND NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         AND NOT (IsClass(self,&DM) AND Send(self,@PlayerIsImmortal))
      {
         Send(self,@MsgSendUser,#message_rsc=bad_line_of_sight);
         iOffense = iOffense / 2;
      }

      return Bound(iOffense,1,2000);
   }

   GetDefense(what = $, stroke_obj=$)
   "This returns the battler's ability to avoid being hit. "
   "Ranges from 1 to 2000."
   {
      local i, oWeapon, oShield, iParry, iDodge, iBlock, iAgility,
            iDefense, iHealth, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iDefense = Send(oMonster,@GetDefense,#what=what,
                           #stroke_obj=stroke_obj);
      }
      else
      {
         // A player's defense is based on his dodge, parry,
         // block skills, agility, and max hps.
         iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);
         iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);
         iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);

         iAgility = Send(self,@GetAgility);

         // Bind health between 20-150 for defense calculation.
         iHealth = Send(self,@GetBaseMaxHealth);

         iDefense = iParry + iBlock + (iDodge*2) + (iAgility*8)
                     + (200 * iHealth)/(100 + Send(self,@GetStamina));
      }

      foreach i in plDefense_modifiers
      {
         iDefense = Send(i,@ModifyDefensePower,#who=self,#what=what,
                           #defense_power=iDefense);
      }

      foreach i in plRadiusEnchantments
      {
         iDefense = Send(Nth(i,2),@ModifyDefensePower,#who=self,#what=what,
                        #state=Nth(i,3),#defense_power=iDefense);
      }

      iDefense += Send(Send(SYS,@GetParliament),@GetFactionDefenseBonus,
                        #who=self,#stroke_obj=stroke_obj);

      return Bound(iDefense,1,2000);
   }

   // The next three messages deal with the three defense skills.  These
   // messages return the relative values of the three skills.  Used in
   // player for defense, used in battler for defense messages.
   GetParryAbility(stroke_obj=$)
   {
      local oWeapon, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetParryAbility,#stroke_obj=stroke_obj);
      }

      oWeapon = Send(self,@GetWeapon);
      if oWeapon = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_PARRY),
                     @CanPayCosts,#who=self)
         OR (stroke_obj <> $ AND NOT Send(stroke_obj,@CanParry))
      {
         return 0;
      }

      return Send(oWeapon,@GetParryAbility,#who=self);
   }

   GetBlockAbility(stroke_obj=$)
   {
      local oShield, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         // Should only be one morph enchantment on the player.
         return Send(oMonster,@GetBlockAbility,#stroke_obj=stroke_obj);
      }

      oShield = Send(self,@LookupPlayerShield);
      if oShield = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_BLOCK),
                     @CanPayCosts,#who=self)
         OR ((stroke_obj <> $) AND NOT Send(stroke_obj,@CanBlock))
      {
         return 0;
      }

      return Send(oShield,@GetBlockAbility,#who=self);
   }

   GetDodgeAbility(stroke_obj=$)
   {
      local oMonster;

      if stroke_obj <> $ AND NOT Send(stroke_obj,@CanDodge)
      {
         return 0;
      }

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
         AND NOT (piFlags & PFLAG_NO_MOVE)
      {
         return Send(oMonster,@GetDodgeAbility,#stroke_obj=stroke_obj);
      }

      if Send(Send(sys,@FindSkillByNum,#num=SKID_DODGE),@CanPayCosts,#who=self)
      {
         return Send(self,@GetSkillAbility,#skill_num=SKID_DODGE);
      }

      return 0;
   }

   // This returns the damage done to target "what" before resistances.
   GetDamage(what = $, stroke_obj=$)
   {
      local i, iDamage, oStroke, oWeapon, iStrokeNum, iModBonus, iDamageBonus,
            oSpell, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iDamage = Send(oMonster,@GetDamage,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         oStroke = stroke_obj;
         if stroke_obj = $
         {
            oWeapon = Send(self,@GetWeapon);
            if oWeapon = $
            {
               oStroke=Send(SYS,@FindSkillByNum,#num=SKID_PUNCH);
            }
            else if IsClass(oWeapon,&Weapon)
            {
               oStroke=Send(SYS,@FindSkillByNum,
                     #num=Send(oWeapon,@GetDefaultStrokeNumber));
            }
            else
            {
               // It's a spell, use it as the stroke object.
               oStroke = oWeapon;
            }
         }

         // Currently considers the damage of the weapon and player's might.
         // Stroke sets damage
         iDamage = Send(oStroke,@FindDamage,#weapon_used=Send(self,@GetWeapon),
                        #who=self,#victim=what); 
      }

      // Don't boost 0 damage hits with modifiers.
      if (iDamage = 0)
      {
         return 0;
      }

      // Spells and attmods that modify damage
      iDamageBonus = 0;
      foreach i in plAttack_modifiers
      {
         // Attack modifiers return the total damage, subtract out the original
         //  damage to get the damage bonus.
         iModBonus = Send(i,@ModifyDamage,#who=self,#what=what,#damage=iDamage,
                          #stroke_obj=oStroke);
         iDamageBonus += (iModBonus - iDamage);
      }

      foreach i in plRadiusEnchantments
      {
         iDamageBonus = Send(Nth(i,2),@ModifyDamage,#who=self,#what=what,
                              #state=Nth(i,3),#damage=iDamageBonus);
      }

      iDamageBonus += Send(Send(SYS,@GetParliament),@GetFactionDamageBonus,#who=self);

      // Convert to high precision. Super dirty, will be cleaned up shortly.
      iDamageBonus *= 100;

      iDamage += iDamageBonus;

      return iDamage;
   }

   // This is the type of damage done.
   GetAttackType(what = $, use_weapon = $)
   {
      local oWeapon, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetAttackType,#what=what);
      }

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         // No weapon means we are punching
         return ATK_TYPE_UNARMED+ATK_TYPE_PUNCH;
      }

      return Send(oWeapon,@GetAttackType);
   }

   GetSpellType(what = $, use_weapon = $)
   {
      local oWeapon, oMonster;

      // Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetSpellType,#what=what);
      }

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         // No weapon means we are punching, no magical damage
         return 0;
      }

      return Send(oWeapon,@GetSpellType);
   }

   AssessHit(what = $, stroke_obj = $, damage = $, use_weapon = $)
   {
      local oMonster;

      if stroke_obj <> $
         AND Send(self,@GetWeaponSwingBonus) > 0
      {
         Send(stroke_obj,@ImproveStroke,#who=self,#target=what,
               #use_weapon=Send(self,@GetWeapon));
      }

      if damage <> $
      {
         // Morphed? As a bonus, people in illusionary form
         // get the hit side effect.  :)
         oMonster = Send(self,@GetIllusionForm);
         if (oMonster <> $)
         {
            Send(oMonster,@HitSideEffect,#what=what,#who=self);
         }
      }

      
      Send(self,@DoHitMessageSound,#what=what,#damage=damage,
            #stroke_obj=stroke_obj,#use_weapon=use_weapon);

      propagate;
   }

   // Handles damage done to player
   // IMPORTANT NOTE: AssessDamage handles both legacy damage calculations and 
   // high precision damage calculation which avoid truncation. If you feed 
   // AssessDamage with a high precision damage number such as 941 for 9.41 
   // points of damage, you need to notify AssessDamage by passing it a 
   // #precision=TRUE. If you don't, AssessDamage will assume that you are 
   // passing a legacy damage value and multiply it by 100 for further 
   // calculations. Most notably, damage from attackspells and melee is now 
   // handled with high precision. Eventually, all damage calculations should 
   // be handled in high precision mode.
   AssessDamage(what=$,damage=$,atype=0,stype=0,stroke_obj=$,bonus=0,
      scalefactor=1000,report=TRUE,report_resistance=TRUE,absolute=FALSE,
      precision=FALSE)
   {
      local i, j, iResistance, oSoldierShield, gainchance, color_rsc,
            iDuration, oSpell, oGort,iLimit, origdamage, oWeapon, shrunken;

      if NOT precision
      {
         damage = damage * 100;
      }

      origdamage = damage/100;
      color_rsc = player_hit_color_none;

      if what <> $ AND IsClass(what,&monster)
      {
         color_rsc = player_hit_color_blue;
      }

      if NOT absolute
      {
         // Armor of Gort has a special effect that must go first
         oGort = Send(SYS,@FindSpellByNum,#Num=SID_ARMOR_OF_GORT);
         if Send(self,@IsEnchanted,#what=oGort)
         {
            damage = Send(oGort,@PriorityModifyDefenseDamage,#who=self,
                           #what=what,#damage=damage,
                           #atype=atype,#stype=stype);
         }
         
         foreach i in plDefense_modifiers
         {
            damage = Send(i,@ModifyDefenseDamage,#who=self,#what=what,
                           #damage=damage,#atype=atype,#stype=stype,
                           #report_resistance=report_resistance);
            Send(i,@DefendingHit,#who=self,#what=what);
         }

         iResistance = Send(self,@ResistanceCheck,#atype=atype,#stype=stype);

         damage = Send(self,@GetDamageFromResistance,#what=damage,
                        #value=iResistance);

         // Allow protective spells a chance to improve when they take effect!
         foreach i in plPassiveImprovement
         {
            if (stype & -Nth(i,4)) AND Random(1,10) = 10
            {
               Send(First(i),@ImproveAbility,#who=self,#target=what);
            }
         }

         // Add attmods AFTER resistance/suscep mods.
         damage += bonus;
         damage *= scalefactor / 1000;
      }

      // Make sure we don't deal negative damage.
      damage = Bound(damage,0,$);

      iDuration = 800;
      if damage <= 600
      {
         iDuration = 600;
      }

      if damage <= 300
      {
         iDuration = 400;
      }

      // Spell damage types do different flashes to inform the victim.
      // If it's just physical damage, do pain instead. Notably: spell
      // damage type flashes cannot be turned off by unchecking the
      // Show Pain option in client config.
      if stype <> 0
      {
         iDuration /= 2;
         Send(self,@DamageTypeFlashEffect,#stype=stype,#duration=iDuration);
      }
      else
      {
         Send(self,@EffectSendUserDuration,#what=self,
               #effect=EFFECT_PAIN,#duration=iDuration);
      }

      if damage > 0
      {
         if (piFlags2 & PFLAG2_PARALYZED)
         {
            Send(self,@RemoveEnchantment,
                  #what=Send(SYS,@FindSpellByNum,#num=SID_PARALYZE));
         }
      }

      if NOT absolute
         AND what <> $
         AND IsClass(what,&Player)
      {
         // If we have more health than twice our max, no percent limit on damage.
         // If we are outlaw or murderer, no percent limit on damage.
         if piHealth < (Send(self,@GetBaseMaxHealth) * 200)
            AND ((NOT (piFlags & PFLAG_OUTLAW)
               AND NOT (piFlags & PFLAG_MURDERER))
               OR Send(SETTINGS_OBJECT,@DamageCapProtectionMurderersEnabled))
         {
            // Cap damage to 1/3 of max health (+2 so we "round up")
            iLimit = ((Send(self,@GetBaseMaxHealth) * 100)
                        + (MAX_HEALTH_DAMAGE_FRACTION-1))
                        / MAX_HEALTH_DAMAGE_FRACTION;
            damage = Bound(damage,$,iLimit);
         }

         // maximum of 30 damage per hit
         damage = Bound(damage,$,MAX_DAMAGE_PER_HIT*100);
      }

      // Faction enemies an extra 15// damage to each other, above caps.
      if what <> $ AND IsClass(what,&Player)
      {
         oSoldierShield = Send(what,@FindUsing,#class=&SoldierShield,#damage=TRUE);
         if oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#what=self,#damage=TRUE)
         {
            damage = (damage * 115)/100;
         }
      }

      if IsClass(what,&Monster)
      {
         RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
            Send(what,@GetTrueName),stype,atype,damage/100,origdamage,
            player_monster_attack_string);
      }

      if IsClass(what,&Player)
      {
         oWeapon = Send(what,@GetWeapon);
         if oWeapon <> $
         {
            RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
               Send(what,@GetTrueName),stype,atype,damage/100,origdamage,
               Send(Send(what,@GetWeapon),@GetTrueName));
         }
         else
         {
            RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
               Send(what,@GetTrueName),stype,atype,damage/100,origdamage,
               player_no_weapon_string);
         }
      }

      Send(self,@LoseHealth,#amount=damage,#precision=TRUE);

      if piHealth <= 0
      {
         if stroke_obj = $
            OR NOT Send(stroke_obj,@PlayerWasKilledMsg,#who=self,
                        #attacker=what,#damage=$)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=Send(self,@PlayerWasHit,
                     #atype=atype,#stype=stype),#parm1=color_rsc,
                     #parm2=Send(what,@GetCapDef),#parm3=Send(what,@GetName));
            }
         }

         return $;
      }

      // flip flag for possible HP gain.
      if poKill_target = $
      {
         poKill_target = what;
      }

      if what = poKill_target AND damage > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE,#value=TRUE);
      }

      // Should we print resistance message?
      if report_resistance
      {
         if IsClass(what,&User)
         {
            Post(what,@MsgPlayerHitResisted,#what=what,
                  #resistance=iResistance,#target=self);
         }

         Post(self,@MsgPlayerResistsHit,#what=what,#resistance=iResistance,
               #target=self,#color_rsc=color_rsc);
      }

      // Report to shrunken head
      shrunken = GetListElemByClass(plPassive,&ShrunkenHead);
      if damage > 0 AND shrunken <> $
      {
         Send(shrunken,@DamageTaken,#what=what,#amount=damage/100);
      }

      Send(self,@AddHurtMeRecently,#who=what,#amount=damage);

      return damage;
   }

   // This message kicks in when damage has been dealt to the opponent.
   DidDamage(what = $, amount = 0)
   {
      local oWeapon, i, shrunken;

      oWeapon = Send(self,@GetWeapon);

      if oWeapon <> $
      {
         Send(oWeapon,@WeaponHitTarget);
      }

      foreach i in plAttack_modifiers
      {
         Send(i,@WeaponHitTarget);
      }

      if Send(self,@GetSkillAbility,#Skill_num=SKID_DISARM) > 0
      {
         if oWeapon <> $ AND IsClass(oWeapon,&Spell)
         {
            oWeapon = $;
         }

         Send(Send(SYS,@FindSkillByNum,#num=SKID_DISARM),@DoSkill,#who=self,
               #oTarget=what,#oWeapon=oWeapon);
      }

      if amount > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

         // Report to shrunken head
         shrunken = GetListElemByClass(plPassive,&ShrunkenHead);
         if shrunken <> $
         {
            Send(shrunken,@DamageDealt,#what=what,#amount=amount/100);
         }
      }

      return;
   }

   // Returns weapon used.
   GetWeapon()
   {
      local oWeapon;

      oWeapon = Send(self,@LookupPlayerWeapon);
      // If there is no wielded melee weapon, then see if we
      // have a touch attack active.
      if oWeapon = $
      {
         // This will return $ if there's no Touch Attacks enchanting player.
         oWeapon = Send(self,@GetEnchantmentsByClass,
               #EnchClass=&TouchAttackSpell);
         if oWeapon <> $
         {
            // The spell object is the second element of the list. Get that.
            oWeapon = Nth(First(oWeapon),2);
         }
      }

      return oWeapon;
   }

   // Returns stroke that handles attacks based on weapon used.
   GetStrokeObject()
   {
      local oWeapon;

      oWeapon = Send(self,@GetWeapon);

      if oWeapon <> $
      {
         if IsClass(oWeapon,&Weapon)
         {
            return Send(SYS,@FindSkillByNum,#num=Send(oWeapon,@GetDefaultStrokeNumber));
         }
         else
         {
            // Our weapon is a touch attack and doubles as a stroke object.
            return oWeapon;
         }
      }

      return Send(SYS,@FindSkillByNum,#num=SKID_PUNCH);
   }

   // The next three functions deal with weapon improvement.

   // This keeps track of the weapon swings.
   SwingWeapon(times=1)
   {
      local oWeapon, iProfNum;

      oWeapon = Send(self,@LookupPlayerWeapon);

      if oWeapon <> $
      {
         // Get weapon's numbers.
         iProfNum = Send(oWeapon,@GetProfNumber,#who=self);
      }
      else
      {
         // Unarmed or touch attacks.
         iProfNum = SKID_BRAWLING;
      }

      if iProfNum <> (piWeaponInfo % 1000)
      {
         Send(self,@ResetWeaponSwings,#prof=iProfNum);
      }

      piWeaponSwings = piWeaponSwings + times;
      if (piWeaponSwings % Send(SETTINGS_OBJECT,
                                 @GetSwingsPerImproveCheck)) = 0
      {
         // Increase this number. Allows us to advance, and
         // get bonuses for advancement.
         piWeaponInfo = piWeaponInfo + 1000;
      }

      return;
   }

   // This resets the weapon swings, for example, after an improvement or a
   // weapon type change.
   ResetWeaponSwings(prof=$)
   {
      local iProf;

      if prof <> $
      {
         iProf = prof;
      }
      else
      {
         iProf = piWeaponInfo % 1000;
      }

      piWeaponSwings = 0;
      piWeaponInfo = iProf;

      return;
   }

   GetWeaponSwingBonus()
   {
      // Separate out the number of groups of swings (the bonus) fromt he proficiency number.
      return piWeaponInfo/1000;
   }

   KilledSomething(what = $,use_weapon = $,stroke_obj = $)
   "Called when the player killed something."
   {
      local bReflection, i, oSoldierShield, monstkarma, iChance, oEnemyGuild,
            oVictimRoom, oObject;

      // Killed something with a weapon, damage weapon.
      if (use_weapon <> $)
         AND IsClass(use_weapon,&Weapon)
      {
         Send(use_weapon,@WeaponHitTarget);
      }

      // Killed something by holding down the attack key. Damage
      // any gear that might have helped our attack.
      if (stroke_obj <> $)
         AND (IsClass(stroke_obj,&Skill)
            OR IsClass(stroke_obj,&TouchAttackSpell))
      {
         foreach i in plAttack_modifiers
         {
            Send(i,@WeaponHitTarget);
         }
      }

      // If we killed someone or something, we did damage.
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

      // Stop minions ruining our karma, they are kind of bloodthirsty
      // and tend to kill indiscriminately (especially mobs)
      bReflection = FALSE;
      if use_weapon <> $
         AND IsClass(use_weapon,&Monster)
      {
         bReflection = TRUE;
      }

      // Send text message - a stroke may want to provide it's own.
      if NOT Send(what,@SayDyingWords,#what=self)
      {
         if stroke_obj
         {
            if NOT Send(stroke_obj,@PlayerKilledSomethingMsg,#who=self,#victim=what)
               AND self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }
         }
         else if self <> what
         {
            Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }
      }

      if pbLogged_on
      {
         if (IsClass(what,&Monster)
               AND NOT (IsClass(what,&Brambles)
                  OR Send(what,@IsIllusion)))
            AND (use_weapon = $
               OR NOT IsClass(use_weapon,&ActiveWallElement))
            AND (piPreferences & CF_GROUPING)
         {
            Send(self,@JoinBuilderGroup);
         }

         Send(poOwner,@SomethingKilled,#what=self,#victim=what);
      }

      // Let the objects we're using know we killed something.
      SendList(plUsing,0,@KilledSomething,#what=what);

      if IsClass(what,&User)
         AND what <> self
      {
         // Use the room the victim died in to determine if there are penalties
         // for this kill. Otherwise we can get away with it in rare instances.
         // Victim's room is still the one they died in.
         oVictimRoom = Send(what,@GetOwner);

         if (oVictimRoom = $
            OR NOT Send(oVictimRoom,@SafePlayerAttack))
            AND NOT Send(oVictimRoom,@GetChaosZone)
         {
            Send(Send(SYS,@GetStatistics),@PlayerKillsCounter);

            if Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            {
               ++piJustified_kill_count;
            }
            else
            {
               ++piKill_count;
               ++piKill_count_decay;
            }

            if NOT bReflection
               AND NOT Send(what,@IsIllusion)
            {
               Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
                     #karma_killer=Send(self,@GetKarma),
                     #karma_victim=Send(what,@GetKarma)));
            }

            if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
               AND NOT IsClass(oVictimRoom,&GuildHall)
            {
               // Attacked an innocent!

               // Check for enemy guild - If both guilds are enemies, then
               // they can whack on each other freely, without murderer or
               // faction penalty.
               oEnemyGuild = Send(what,@GetGuild);
               oSoldierShield = GetListElemByClass(plUsing,&SoldierShield);

               // Check for various murderer things if any are true:
               // We're not in a guild, opponent wasn't in a guild, we're
               // not in a mutual war
               // AND if we're not a faction soldier, the opponent isn't an
               // opposing faction soldier
               if (poGuild = $
                   OR oEnemyGuild = $
                   OR NOT Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
                  AND (oSoldierShield = $
                       OR NOT Send(oSoldierShield,@IsEnemyAttack,
                                    #what=what,#damage=TRUE))
               {
                  // SUBTLE BUG: Somehow, the faction check is missed when you
                  // kill something. We check it here, but only for players.
                  // This means that if you score just the killing blow on a
                  // factioned monster, you won't get checked for faction loss.
                  // It's a bug, but currently not that vital.
                  
                  // Check to see if the attack was faction-based.
                  Send(self,@CheckFactionAttack,#what=what,
                        #stroke_obj=stroke_obj);

                  // Apply penalties for someone NOT holding a token
                  if Send(what,@FindUsing,#class=&Token) = $
                  {
                     if (piFlags & PFLAG_MURDERER)
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_killed_player);
                     }
                     else
                     {
                        // Handles flag changes/message for killing.
                        Send(self,@MakePlayerMurderer,#what=what);
                        piTimeLastMurder = GetTime();
                     }

                     // Does the lucky murderer win a Revenant?
                     // If it was an easy fight, lets haunt em more often than if
                     // it was competitive (or the victim at least had a shot)
                     // If were twice as strong as them, we get haunted.
                     // If the victim was good, we get haunted.
                     iChance = Send(self,@RevenantChance,#target=what);
                     if (Random(1,100) < iChance) AND NOT Send(SYS,@GetChaosNight)
                     {
                        Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=TRUE);
                        if poOwner <> $
                        {
                           Send(self,@MsgSendUser,#message_rsc=player_haunted_on,
                                 #parm1=Send(what,@GetCapDef),
                                 #parm2=Send(what,@GetName,#Cap=TRUE));
                           Create(&Revenant,#target=self,#location=poOwner,
                                 #level=Bound((((Send(self,@GetBaseMaxHealth)*110)/100)+
                                    (7*piKill_Count_decay)),95,180),
                                 #diff=Bound(Send(self,@GetBaseMaxHealth)/12,4,9),
                                 #karmic=-piKarma/100);
                        }
                     }
                  }
               }
            }
         }
      }

      if IsClass(what,&Monster)
         AND NOT bReflection
         AND NOT Send(what,@IsIllusion)
      {
         Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
               #karma_victim=Send(what,@GetKarma),
               #karma_killer=Send(self,@GetKarma)),
               #bIsMob=TRUE);
      }

      Send(what,@Killed,#what=self,#stroke_obj=stroke_obj);
      Send(self,@DrawXP);

      // Report to shrunken head
      oObject = GetListElemByClass(plPassive,&ShrunkenHead);
      if oObject <> $
      {
         Send(oObject,@OpponentKilled,#what=what,#stroke_obj=stroke_obj);
      }

      // Let our follower know if we have one. It'll make his day!
      if (poMercenary <> $)
         AND NOT IsTimer(poMercenary)
         AND IsClass(poMercenary,&Follower)
         AND (Send(poMercenary,@GetOwner) = poOwner)
      {
         Send(poMercenary,@LeaderKilledSomething,#what=what,#use_weapon=use_weapon);
      }

      return;
   }

   MakePlayerMurderer(what = $)
   "Called by anything that turns the player into a murderer (killing "
   "an innocent or the vilify spell.  If this happened as a result of "
   "a kill, 'what' is the victim."
   {
      if (what <> $)
      {
         Send(self,@MsgSendUser,#message_rsc=player_wanted_now,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
      }

      // Use SetPlayerFlag for PFLAG_MURDERER.
      piFlags &= ~PFLAG_OUTLAW;
      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=TRUE);

      // If scaling pens are enabled for murderers, but not
      // for innocents/outlaws, reset our logoff pen count.
      // Fair because play styles are different when scaling
      // pens are in effect.
      if (Send(SETTINGS_OBJECT,@GetFlatPenaltiesEnable)
         <> Send(SETTINGS_OBJECT,@GetFlatPenaltiesEnable,
                  #flag=PFLAG_MURDERER))
      {
         Send(self,@ResetLogoffPenaltyCount);
      }

      Send(self,@EvaluatePKStatus,#dbug=TRUE);

      return;
   }

   GetSomethingMissedYouSound(what = $,weapon_used = $)
   {
      local i,iRoll;

      if Send(self,@LookupPlayerWeapon)
      {
         iRoll = Random(1,3);
         if iRoll = 1
         {
            return player_sound_sword1;
         }

         if iRoll = 2
         {
            return player_sound_sword2;
         }

         if iRoll = 3
         {
            return player_sound_sword3;
         }
      }

      iRoll = Random(1,3);

      if iRoll = 1
      {
         return player_sound_metal1;
      }

      if iRoll = 2
      {
         return player_sound_metal2;
      }

      if iRoll = 3
      {
         return player_sound_metal3;
      }

      Debug("Can't get here");

      return $;
   }

   GetOuchSound()
   {
      local iHealthFraction;

      // Since piHealth is inflated by a factor of 100, 
      // this returns the correct fraction.
      if piMax_health > 0
      {
         iHealthFraction = piHealth / piMax_health;
      }
      else
      {
         iHealthFraction = 0;
      }

      if piGender = GENDER_MALE
      {
         if iHealthFraction > 75
         {
            return player_sound_male_ouch1;
         }

         if iHealthFraction > 50
         {
            return player_sound_male_ouch2;
         }

         if iHealthFraction > 25
         {
            return player_sound_male_ouch3;
         }

         return player_sound_male_ouch4;
      }

      if iHealthFraction > 75
      {
         return player_sound_female_ouch1;
      }

      if iHealthFraction > 50
      {
         return player_sound_female_ouch2;
      }

      if iHealthFraction > 25
      {
         return player_sound_female_ouch3;
      }

      return player_sound_female_ouch4;
   }

   RevenantChance(who=$,target=$)
   {
      local iMaxHealth, oChance, oGuild, iFaction, oSpell, oVictimRoom;

      oVictimRoom = Send(target,@GetOwner);

      if oVictimRoom = $
         OR IsClass(oVictimRoom,&Guildhall)
      {
         return 0;
      }

      // PFLAG2_NOHAUNT is only settable by a guide or guardian. The last
      // two checks prevent outlaw/murderer players from creating revenants.
      if (piFlags2 & PFLAG2_NOHAUNT)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
      {
         return 0;
      }

      oChance = 30;
      oGuild = Send(target,@GetGuild);

      if poGuild <> $ AND oGuild <> $
      {
         if poGuild = oGuild
         {
            oChance += 20;
         }
         else
         {
            if Send(poGuild,@IsMutualEnemy,#otherguild=oGuild)
            {
               return 0;
            }
            if Send(poGuild,@IsAlly,#otherguild=oGuild)
            {
               oChance += 10;
            }
            if Send(oGuild,@IsAlly,#otherguild=poGuild)
            {
               oChance += 10;
            }
            if Send(poGuild,@IsEnemy,#otherguild=oGuild)
            {
               oChance -= 10;
            }
            if Send(oGuild,@IsEnemy,#otherguild=poGuild)
            {
               oChance -= 10;
            }
         }
      }

      iFaction = Send(target,@GetFaction);
      if piFaction <> FACTION_NEUTRAL AND iFaction <> FACTION_NEUTRAL
      {
         if piFaction <> iFaction
         {
            oChance -= 5;
         }
         else
         {
            oChance += 15;
         }
      }

      // Our max health, bound to max HP
      iMaxHealth = Send(self,@GetBaseMaxHealth);
      // Punish them more if they beat up someone weaker than they are.
      oChance += ((10 * iMaxHealth) / Send(target,@GetBaseMaxHealth));

      // People with greater absolute Karma have a greater chance to produce
      // a revenant.  Being a good person, in general, decreases your chance.
      // Even if you are murderous scum.
      oChance += (Abs(Send(target,@GetKarma)-piKarma/100))/20;

      // Punish them more if they walked away with more health.
      oChance += Bound(piHealth / (5 * iMaxHealth),0,20);

      // Bind the number to a reasonable amount, then add in the penalty
      // for being a repeat killer.
      oChance = (Bound(oChance,20,80) + (5 * piKill_count_decay));

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_MARTYRS_BATTLEGROUND);
      if Send(oVictimRoom,@IsEnchanted,#what=oSpell)
      {
         oChance += (oChance * First(Send(oVictimRoom,@GetEnchantmentState,
                                       #what=oSpell)) / 100);
      }
      oChance = Bound(oChance,40,95);

      return oChance;
   }

   DoHitMessageSound(what = $,damage = 0,stroke_obj = $, use_weapon = $)
   {
      local iRoll,rSound;

      if (stroke_obj = $)
      {
         // Play a hurt sound for attack spells.
         if (use_weapon <> $
            AND IsClass(use_weapon,&AttackSpell)
            AND IsClass(what,&User))
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,
                  #wave_rsc=Send(what,@GetOuchSound));
         }

         return;
      }

      if IsClass(stroke_obj,&Spell)
      {
         rSound = Send(stroke_obj,@GetHitSound);
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
         if IsClass(what,&User)
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,
                  #wave_rsc=Send(what,@GetOuchSound));
         }

         return;
      }

      if IsClass(what,&Monster)
      {
         if damage <> $
         {
            if damage <= 300
            {
               iRoll = Random(1,3);
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_flesh1;
               }
               else
               {
                  if iRoll = 2
                  {
                     rSound = player_sound_hit_monster_flesh2;
                  }
                  else
                  {
                     rSound = player_sound_hit_monster_flesh3;
                  }
               }

               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

               return;
            }

            if damage <= 600
            {
               iRoll = Random(1,3);
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_leather1;
               }
               else
               {
                  if iRoll = 2
                  {
                     rSound = player_sound_hit_monster_leather2;
                  }
                  else
                  {
                     rSound = player_sound_hit_monster_leather3;
                  }
               }

               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

               return;
            }
         }

         iRoll = Random(1,3);
         if iRoll = 1
         {
            rSound = player_sound_hit_monster_metal1;
         }
         else
         {
            if iRoll = 2
            {
               rSound = player_sound_hit_monster_metal2;
            }
            else
            {
               rSound = player_sound_hit_monster_metal3;
            }
         }

         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

         return;
      }

      if damage <> $
      {
         if damage <= 300
         {
            iRoll = Random(1,3);
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_flesh1;
            }
            else
            {
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_flesh2;
               }
               else
               {
                  rSound = player_sound_hit_monster_flesh3;
               }
            }

            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

            if IsClass(what,&Player)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,
                     #wave_rsc=Send(what,@GetOuchSound));
            }

            return;
         }

         if damage <= 600
         {
            iRoll = Random(1,3);
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_leather1;
            }
            else
            {
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_leather2;
               }
               else
               {
                  rSound = player_sound_hit_monster_leather3;
               }
            }

            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

            if IsClass(what,&Player)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,
                     #wave_rsc=Send(what,@GetOuchSound));
            }

            return;
         }
      }

      iRoll = Random(1,3);
      if iRoll = 1
      {
         rSound = player_sound_hit_monster_metal1;
      }
      else
      {
         if iRoll = 2
         {
            rSound = player_sound_hit_monster_metal2;
         }
         else
         {
            rSound = player_sound_hit_monster_metal3;
         }
      }

      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

      if IsClass(what,&Player)
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
      }

      return;
   }

   CheckAttackTimer()
   {
      if ptAttackTimer <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   IsOkayAttackTime(time = 1000, seconds = $)
   "Have we waited long enough since the last attack/spell? Sets new "
   "valid attack time (time in msec, default 1 second)."
   {
      local i;

      if ptAttackTimer <> $
      {
         return FALSE;
      }

      if seconds <> $
      {
         i = seconds*1000;
      }
      else
      {
         i = time;
      }

      if i > 0
      {
         ptAttackTimer = CreateTimer(self,@AttackTimer,i);
         piLastTimeAttacked = GetTickCount();
      }

      return TRUE;
   }

   SetAttackTime(time = 0, bAdd = FALSE)
   "Override the current attack timer with specified value."
   {
      if ptAttackTimer <> $
      {
         if bAdd
         {
            time += GetTimeRemaining(ptAttackTimer);
         }

         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      if time
      {
         ptAttackTimer = CreateTimer(self,@AttackTimer,time);
      }

      return;
   }

   AttackTimer()
   "Sets the attack timer variable to NIL so we know it's OK to attack again."
   {
      ptAttackTimer = $;

      return;
   }

   SendAttackOutOfRangeMessage(what = $, use_weapon = $, stroke_obj = $)
   {
      if use_weapon = $
         AND stroke_obj = $
      {
         return;
      }

      if use_weapon <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_range,
               #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
               #parm3=Send(use_weapon,@GetIndef),
               #parm4=Send(use_weapon,@GetName));
      }
      else if IsClass(stroke_obj,&Spell)
      {
         if IsClass(stroke_obj,&RadiusEnchantment)
         {
            return;
         }

         Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_SPELL_range,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
               #parm3=Send(stroke_obj,@GetName));
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_PUNCH_range,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
               #parm3=Send(stroke_obj,@GetName));
      }

      return;
   }

   SendNoLineOfSightMessage()
   {
      Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);
      return;
   }

   GetMoneyObject(type= $)
   {
      if (type = &Silver)
      {
         return GetListElemByClass(plPassive,&Silver);
      }
      else
      if (type = &Shillings)
      {
         return GetListElemByClass(plPassive,&Shillings);
      }
      
      return;
   }

   // Returns wielded Melee/Ranged weapon.
   LookupPlayerWeapon()
   {
      return GetListElemByClass(plUsing,&Weapon);
   }

   LookupPlayerShield()
   {
      local i;

      // Can be using two shields at once - soldier shield on back and normal
      // shield in the shield position. Skip over the soldier shield if it
      // is in the back position.
      foreach i in plUsing
      {
         if (IsClass(i,&SoldierShield))
         {
            if (NOT Send(i,@IsOnBack)
               AND Send(i,@GetBlockAbility,#who=self) > 0)
            {
               return i;
            }
         }
         else if (IsClass(i,&Shield)
            AND Send(i,@GetBlockAbility,#who=self) > 0)
         {
            return i;
         }
      }

      return $;
   }

   LeaveHold(what = $)
   {
      local i;

      // in case it's on the list of window overlays 
      Send(self,@RemoveWindowOverlayObject,#what=what);

      // in case it set our icon
      if poIcon_set = what
      {
         Send(self,@ResetPlayerIcon);
      }

      // in case it removed our hair
      if poHair_remove = what
      {
         Send(self,@ResetHair);
      }

      // in case it set our legs
      if poLegs_set = what
      {
         Send(self,@ResetPlayerLegs);
      }

      if poArms_set = what
      {
         Send(self,@ResetPlayerArms);
      }

      foreach i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            // implied by drop: Send(self,@NewUnusing,#what=what)
            Send(what,@NewUnused,#what=self);

            break;
         }
      }

      propagate;
   }

   GetPlayerUsing()
   {
      return plUsing;
   }

   GetEquippedItems()
   {
      return Send(self,@GetPlayerUsing);
   }

   IsUsingA(class=$)
   {
      return GetListElemByClass(plUsing,class) <> $;
   }

   FindUsing(class=$)
   "Find the first instance of 'class' that player has equipped. "
   "Returns $ if nothing is found."
   {
      return GetListElemByClass(plUsing,class);
   }

   ChooseArmorPosition()
   "Defense now chooses a body place at random, and checks to see if the "
   "defender has any defense value there. Much better than random pattern "
   "of previous combat."
   {
      local rand, armor_pos;

      rand = Random(1,12);
      armor_pos = 0;

      if rand < 6
      {
         return ITEM_USE_BODY;
      }

      if rand < 8
      {
         return ITEM_USE_LEGS;
      }

      if rand < 9
      {
         return ITEM_USE_HEAD;
      }

      if rand < 10
      {
         return ITEM_USE_GAUNTLET;
      }

      // Default position: shield
      return -1;
   }

   ReqEatSomething(filling = 0, what = $)
   {
      // This is the only place we need piStomach to be correct
      Send(self,@UpdateStomach);

      if (piStomach + filling) > 100
      {
         if what = $ OR NOT Send(what,@IsBeverage)
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full_drink);
         }

         return FALSE;
      }

      return TRUE;
   }

   EatSomething(nutrition = 0, filling = 0)
   {
      Send(self,@GainVigor,#precision=TRUE,#amount=100 * nutrition);
      piStomach += filling;

      return;
   }

   LoseUnboundEnergy()
   {
      local iReduction;

      if NOT Send(self,@IsInCannotInteractMode)
      {
         iReduction = Bound(piUnbound_energy * Send(SETTINGS_OBJECT,@GetUnboundDecay)
                           / 1000,1,$);
         piUnbound_energy -= iReduction;
      }

      Send(self,@NewUnboundEnergy);

      return;
   }

   NewUnboundEnergy(bDelay = FALSE)
   {
      if piUnbound_energy < 0
      {
         piUnbound_energy = 0;
      }

      if ptUnboundEnergy = $
      {
         if piUnbound_energy > 0
         {
            if bDelay
            {
               ptUnboundEnergy = CreateTimer(self,@UnboundEnergyTimer,
                                       Send(SETTINGS_OBJECT,@GetUnboundDelay));
            }
            else
            {
               ptUnboundEnergy = CreateTimer(self,@UnboundEnergyTimer,1000);
            }
         }
      }
      else if piUnbound_energy = 0
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = $;
      }
      else if bDelay
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = CreateTimer(self,@UnboundEnergyTimer,
                                 Send(SETTINGS_OBJECT,@GetUnboundDelay));
      }

      Send(self,@DrawUnboundEnergy);

      return;
   }

   GainLight(amount = $)
   "Adds <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }

      piLight = piLight + amount;
      Send(self,@NewLight);

      return amount;
   }

   LoseLight(amount = $)
   "Subtracts <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }

      piLight = piLight - amount;
      Send(self,@NewLight);

      return amount;
   }

   NewLight()
   "Call this everytime player light is changed."
   {
      Send(self,@SourceLightChanged);

      return;
   }

   GainBaseMaxHealth(amount = 0)
   {
      local iPrev_max;

      iPrev_max = Send(self,@GetBaseMaxHealth);

      piBase_max_health = Bound(piBase_max_health + amount,MIN_HEALTH,$);
      amount = Send(self,@GetBaseMaxHealth) - iPrev_max;

      // Give them the "further info" gmail if they've advanced to 25.
      if piBase_Max_health = 25
         AND amount > 0
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_tutorial_mail]);
      }

      Send(self,@PlayerIsIntriguing);
      Send(self,@GainMaxhealth,#amount=amount);

      return;
   }

   GainMaxHealth(amount = 0)
   "Call this any time you modify piMax_health, to set stuff on the user's "
   "display, and make sure the value doesn't get too high.  Returns "
   "actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_health;
      piMax_health = Bound(piMax_health + amount, MIN_HEALTH, $);

      //  no longer reset health to max - will need to test for abusability
      //     the motivation for this originated in using a circlet with health > max_health,
      //     which would erase hp boons or vamptouch gains - kinda mean.
      //     thought about preserving (health - max_health):
      //           OOOOOOOOOOOOOOOOOOOOoooooo       (o is health above max)
      //     -->   OOOOOOOOOOOOOOOOoooooo
      //     but in parallel with this scheme, we should also do:
      //           OOOOOOOOOOOOOO......             (. is space to max)
      //     -->   OOOOOOOOOO......
      //     which could result in death!
      //     the behavior could be made assymetrical,
      //           OOOOOOOOOOOOOO......
      //     -->   OOOOOOOOOOOOOO..
      //     but what about this case?
      //           OOOOOOOOOOOOOOOOO...    or    OOOOOOOOOOOOOOOOO...
      //     -->   OOOOOOOOOOOOOOOOo             OOOOOOOOOOOOOOOO
      //     the left is obviously abusable - compound it with the first gain above,
      //     and by putting on and removing a circlet we gain health!
      //     the right might be ok, and is closest to the current scheme,
      //     but this introduces even more assymmetry and thus makes me nervous.
      //     so my first pass is to do nothing to health here:
      //
      //if piHealth > piMax_health { piHealth = piMax_health; }
      //
      //     if this becomes undesirable, use this new code:
      //if piHealth > iPrev_max { piHealth = piMax_health + (piHealth - iPrev_max); }
      //else { piHealth = Bound(piHealth, $, piMax_health); }

      Send(self,@NewHealth); // in case need heal timer

      return piMax_health - iPrev_max;
   }

   StripNodeList(number=$)
   {
      local nodelist, count;

      nodelist = Send(self,@GetNodelist);

      if number = $
      {
         number = Length(nodelist);
      }

      count = 1;

      while nodelist >= 1
      {
         if ((nodelist/2)*2) <> nodelist  //we do an "# was odd" operator
         {
            Send(Send(SYS,@FindNodeByNum,#num=count),@UnMeld,#who=self);
         }
         count = count * 2;
         nodelist = nodelist / 2;
      }

      Send(self,@ResetNodeList);
      Send(self,@NewMana);

      return;
   }

   StripOneNode(report=TRUE)
   {
      local lNodes, index, bFaerieNode, bQNode, oNode;

      if piNodeList = 0
      {
         return;
      }

      index = 1;
      bFaerieNode = FALSE;
      bQNode = FALSE;

      while index <= NODE_MAX_VALUE
      {
         if piNodelist & index
         {
            if index = NODE_FAERIE
            {
               bFaerieNode = TRUE;
            }
            else if index = NODE_Q
            {
               bQNode = TRUE;
            }
            else
            {
               lNodes = Cons(index,lNodes);
            }
         }

         index = index * 2;
      }

      if lNodes = $
      {
         // No nodes; let's rip out one of the special ones, then.
         if bFaerieNode
         {
            lNodes = Cons(NODE_FAERIE,lNodes);
         }
         if bQNode
         {
            lNodes = Cons(NODE_Q,lNodes);
         }
      }

      if lNodes
      {
         index = Nth(lNodes,Random(1,Length(lNodes)));
         oNode = Send(SYS,@FindNodeByNum,#num=index);
         Send(oNode,@UnMeld,#who=self);

         if report
         {
            Post(self,@MsgSendUser,#message_rsc=player_lose_node,
                  #parm1=Send(oNode,@GetLocationName));
         }
      }

      Send(self,@NewMana);

      return;
   }

   RemoveNodeFromList(node_num=0)
   {
      piNodelist &= ~node_num;

      // Have to update mana node quest in quest log.
      // Would be better to update each quest individually...
      if (pbLogged_on)
      {
         Send(self,@ToCliStats,#group=5);
      }

      return;
   }

   ResetNodeList()
   {
      piNodelist = 0;

      // Have to update mana node quest in quest log.
      // Would be better to update each quest individually...
      if (pbLogged_on)
      {
         Send(self,@ToCliStats,#group=5);
      }

      return;
   }

   AddManaNode(node_num=0)
   "Used for manually adding nodes by node ID."
   {
      local oNode;

      if (piNodelist & node_num)
      {
         return;
      }

      oNode = Send(SYS,@FindNodeByNum,#num=node_num);

      if (oNode = $)
      {
         return;
      }

      Send(oNode,@Meld,#who=self);

      return;
   }

   ConnectManaNode(node_num=0,all=FALSE)
   {
      if all
      {
         piNodelist = NODE_ALL;
      }
      else
      {
         piNodelist |= node_num;
      }

      // Have to update mana node quest in quest log.
      // Would be better to update each quest individually...
      if (pbLogged_on)
      {
         Send(self,@ToCliStats,#group=5);
      }

      Send(self,@ComputeMaxMana);

      return;
   }

   SeverManaNode(node_num=0,all=FALSE)
   {
      if all
      {
         piNodelist = 0;
      }

      piNodelist &= ~node_num;

      // Have to update mana node quest in quest log.
      // Would be better to update each quest individually...
      if (pbLogged_on)
      {
         Send(self,@ToCliStats,#group=5);
      }

      Send(self,@ComputeMaxMana);

      return;
   }

   NewMaxMana(amount=0)
   {
      if piMax_mana + amount > MAX_CALCULATED_MANA
      {
         amount = MAX_CALCULATED_MANA - piMax_mana;
         piMax_mana = MAX_CALCULATED_MANA;
      }
      else if piMax_mana + amount < MIN_MANA
      {
         amount = piMax_mana - MIN_MANA;
         piMax_mana = MIN_MANA;
      }
      else
      {
         piMax_mana += amount;
      }

      Post(self,@ComputeMaxMana);

      return amount;
   }

   ComputeMaxMana()
   {
      local i, index, iNodeList, oNode, iMagic, oSpell, iAbility;

      iMagic = Send(self,@GetMysticism);
      piMax_mana = 150 + (2 * iMagic);

      for (index = 1, iNodelist = piNodelist;
           iNodeList > 0 AND index <= NODE_MAX_VALUE;
           index *= 2)
      {
         if (iNodeList & index)
         {
            oNode = Send(SYS,@FindNodeByNum,#num=index);
            piMax_mana += Send(oNode,@GetManaAdjust,#who=self,#myst=iMagic);
            iNodelist &= ~index;
         }
      }

      piMax_mana /= 10;

      // Account for any items that may affect max mana
      foreach i in plUsing
      {
         if Send(i,@AdjustsMaxMana)
         {
            piMax_mana += Send(i,@GetManaChange);
         }
      }

      foreach i in plEnchantments
      {
         if Send(Nth(i,2),@AffectsMaxMana)
         {
            piMax_mana += Send(Nth(i,2),@GetManaBonus,#state=Nth(i,3));
         }
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_CRYSTALIZE_MANA);
      iAbility = Send(self,@GetSpellAbility,#spell_num=SID_CRYSTALIZE_MANA);

      if oSpell <> $ AND iAbility <> 0
      {
         piMax_mana += Send(oSpell,@GetManaBonus,#spell_ability=iAbility);
      }

      if Send(self,@IsCrystalizeManaSurging)
      {
         piMax_mana = 15 + (iMagic / 5);
      }

      Send(self,@NewMana);

      return;
   }

   NumManaNodes()
   {
      local i, n;

      n = 0;
      i = 1;

      while i <= NODE_MAX_VALUE
      {
         if piNodelist & i
         {
            ++n;
            if i = 512
            {
               ++n;
            }
         }

         i *= 2;
      }

      return n;
   }

   GetNodeList()
   "Returns the list of nodes that a player has successfully melded with."
   {
      return piNodelist;
   }

   GetSpellList()
   {
      return plSpells;
   }

   // These next three functions handle school casts.

   // This message handles adding a weighted cast to the school casts list.
   AddSchoolCast(school=$, amount=$)
   {
      local iToAdd;

      if plSchoolCasts = $
      {
         // 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > Length(plSchoolCasts)
         OR amount = $
      {
         return;
      }

      iToAdd = amount;

      SetNth(plSchoolCasts,school,(Nth(plSchoolCasts,school)+iToAdd));

      return;
   }

   // This message returns the appropriate school cast amount from the list.
   GetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         // 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > Length(plSchoolCasts)
      {
         return 0;
      }

      return Nth(plSchoolCasts,school);
   }

   // This message resets the weighted cast count back to 0.
   ResetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         // 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > Length(plSchoolCasts)
      {
         return;
      }

      SetNth(plSchoolCasts,school,0);

      return;
   }

   GetNumAbilityPointsInSchool(school=0)
   {
      if school = 0
         OR plSchools = $
      {
         return 0;
      }

      return Nth(plSchools,school);
   }

   GetNumSpellsInSchool(school = 0)
   "Used by the advancement checker to see the odds of a player advancing."
   {
      local num, i, oSpell;

      num = 0;
      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,
               #num=Send(self,@DecodeSpellNum,#compound=i));
         if school = Send(oSpell,@GetSchool)
         {
            ++num;
         }
      }

      return num;
   }

   GetSkillList()
   {
      return plSkills;
   }

   GetMight()
   {
      return Bound((piMight + piMightMod),1,MAXIMUM_STAT);
   }

   GetIntellect()
   {
      return Bound((piIntellect + piIntellectMod),1,MAXIMUM_STAT);
   }

   GetAgility()
   {
      return Bound((piAgility + piAgilityMod),1,MAXIMUM_STAT);
   }

   GetAim()
   {
      return Bound((piAim + piAimMod),1,MAXIMUM_STAT);
   }

   GetStamina()
   {
      return Bound((piStamina + piStaminaMod),1,MAXIMUM_STAT);
   }

   GetMysticism()
   {
      return Bound((piMysticism + piMysticismMod),1,MAXIMUM_STAT);
   }

   GetRawMight()
   {
      return Bound(piMight,1,50);
   }

   GetRawIntellect()
   {
      return Bound(piIntellect,1,50);
   }

   GetRawAgility()
   {
      return Bound(piAgility,1,50);
   }

   GetRawAim()
   {
      return Bound(piAim,1,50);
   }

   GetRawStamina()
   {
      return Bound(piStamina,1,50);
   }

   GetRawMysticism()
   {
      return Bound(piMysticism,1,50);
   }

   GetRawStatisticsTotal()
   {
      return piMight + piIntellect + piAgility + piAim + piStamina + piMysticism;
   }

   GetKarma()
   "Returns karma in natural units"
   {
      return piKarma/100;
   }

   AddKarma(amount = 0)
   "Adds argument (which must be in hundredths of karma units) to karma"
   {
      piKarma = piKarma + amount;
      Send(self,@NewKarma);

      return;
   }

   LoseKarma(amount = 0)
   {
      piKarma = piKarma - 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   GainKarma(amount = 0)
   {
      piKarma = piKarma + 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   NewKarma()
   {
      if piKarma < -10000
      {
         piKarma = -10000;
      }

      if piKarma > 10000
      {
         piKarma = 10000;
      }

      Send(self,@DrawKarma);

      return;
   }

   SetKarma(value = 0)
   "Changes karma to specified amount"
   {
     piKarma = value;
     Send(self,@NewKarma);

     return;
   }

   CalculateKarmaChangeFromAct( karma_doer=$, karma_act=$, Swing_factor = 1)
   {
      local iBase, iChange;

      if karma_doer = $ OR karma_act = $
      {
         return 0;
      }

      // Neutral mobs and event mobs do not change karma
      if karma_act = 0
      {
         return 0;
      }

      // Do not change karma if player is good, act is good, but not as
      // good as player. I.e. only change karma if good player does bad
      // stuff (or vice versa).
      if (karma_doer > 0 AND karma_act > 0 AND karma_doer > karma_act)
      OR (karma_doer < 0 AND karma_act < 0 AND karma_doer < karma_act)
      {
         return 0;
      }

      iBase = karma_doer  - karma_act;

      iChange = - ((iBase*iBase*ibase)/2500 + (5*iBase));

      // Swing factor must be a number from 1 to 10
      swing_factor = Bound(swing_factor,1,10);

      return (iChange / (11 - swing_factor));
   }

   CalculateKarmaChangeFromKill(karma_killer=0,karma_victim=0,bIsMob=FALSE)
   {
      local iChange, iSwing, oSpellDeathLink;

      // No karma change in survival room. Mobs in this room *should*
      // return 0 karma, but there are cases where it doesn't happen.
      if poOwner <> $
         AND IsClass(poOwner,&SurvivalRoom)
      {
         return 0;
      }

      // No karma changes from killing players during Frenzies.
      // Also, no Karma change from event monsters: Xeos and admin-spawned.
      if (Send(SYS,@GetChaosNight) AND NOT bIsMob)
         OR karma_victim = $
      {
         return 0;
      }

      // No karma changes from killing neutral monsters.
      if bIsMob AND karma_victim = NEUTRAL
      {
         return 0;
      }

      // Death link prevents karma changes
      oSpellDeathLink = Send(SYS,@FindSpellByNum,#num=SID_DEATH_LINK);
      if Send(self,@IsEnchanted,#what=oSpellDeathLink)
      {
         return 0;
      }

      // A kill is merely an act, like all other acts, with the
      // strongest swing factor possible.  The karma of a kill
      // is equal to the negative karma of the person who died -
      // thus, killing someone with 100 karma is a -100 karma act.
      if bIsMob
      {
         iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingMonster);
      }
      else
      {
         iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingPlayer);
      }

      // Okay, let's give them a break if they are moving towards
      // neutrality, and they've just killed a monster.  This happens,
      // for example, if a player with 20 karma kills a monster with
      // -10.  It moves the player towards 10, but at a slower pace.

      if bIsMob
      {
         if (karma_killer > 0) <> (karma_victim > 0)
            AND (abs(karma_killer) > abs(karma_victim))
         {
            iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingNeutral);
         }
      }

      iChange = Send(self,@CalculateKarmaChangeFromAct,#karma_doer = karma_killer,
                     #karma_act = -(karma_victim),#swing_factor = iSwing);

      if bIsMob
      {
         iChange = Bound(iChange,-150,150);
      }

      return iChange;
   }

   //// Guild Command Stuff

   RemoveAllGuildCommands()
   "Removes all of the player's guild commands from him."
   {
      piGuild_commands = 0;

      return;
   }

   HasGuildCommand(command_num=0)
   "This always checks to be sure that the flag exists."
   {
      return (piGuild_commands & command_num);
   }

   AddGuildCommand(command_num = 0)
   "Adds a guildcommand to player's arsenal.  Usually called by resetpowers"
   "in guild.kod."
   {
      local oCommand;

      if Send(self,@HasGuildCommand,#command_num=command_num)
      {
         return FALSE;
      }
      piGuild_Commands = piGuild_Commands | command_num;

      return TRUE;
   }

   RemoveGuildCommand(command_num=0)
   {
      piGuild_commands = piGuild_commands & ~command_num;

      return;
   }

   SetGuild(guild_obj=$)
   "Sets the player's poGuild to be equal to the guild object."
   {
      poGuild = guild_obj;
      Send(self,@EvaluatePKStatus,#dbug=TRUE);

      return;
   }

   QuitGuild()
   "Call this if you're an admin trying to kick someone out of a guild."
   "This will tell the guild to delete the user."
   {
      if poGuild <> $
      {
         Send(poGuild,@RemoveFromGuild,#who=self);
      }

      return;
   }

   ResetGuildStuff()
   "This should never be called directly, except from 'RemoveFromGuild' in"
   "guild.kod!  Otherwise, the guild lists may not match with player's poGuild!"
   {
      local oWatcher;

      poGuild = $;
      piGuild_commands = 0;

      if (poOwner <> $)
      {
         oWatcher = Send(poOwner,@GetWatcher);
         if (oWatcher <> $)
         {
            Send(oWatcher,@PlayerQuitGuild,#who=self);
         }
      }

      // If we are logged off unsafely or phased, we pen instantly.
      Send(self,@InstantPenIfUnsafe);

      return;
   }

   // Stub (probably unnecessary), User handles it.
   InstantPenIfUnsafe()
   {
      return;
   }

   ////  Spells Stuff

   HasSpell(num = 0)
   "Returns TRUE if a spell is in a player's spell list,"
   "FALSE if it is not."
   {
      local i,oSpell;

      foreach i in plSpells
      {
         if Send(self,@DecodeSpellNum,#compound=i) = num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   EncodeSpell(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used=TRUE
      {
         return num*100 + iability;
      }

      return -(num*100 + iability);
   }

   DecodeSpellNum(compound = 0)
   {
      return Abs(compound) / 100;
   }

   DecodeSpellAbility(compound = 0)
   {
      return Abs(compound) % 100;
   }

   GetSpellAbility(spell_num = 0)
   {
      local i;

      foreach i in plSpells
      {
         if Abs(i) / 100 = spell_num
         {
            return Abs(i) % 100;
         }
      }

      // This spell is not in the player's spell list. Return 0 ability.
      return 0;
   }

   ChangeSpellAbility(spell_num = 0, amount = 0, report = FALSE,
                      refigureschools = TRUE)
   {
      local i, bFound, elemNum, iAbility, bUsed, spellName, iChange,
            newAbility, oSpell, shrunken;

      oSpell = Send(SYS,@FindSpellByNum,#num=spell_num);
      if oSpell = $
      {
         return FALSE;
      }

      // Make sure user has this spell (should always have it if this is being called)
      bFound = FALSE;
      elemNum = 0;
      spellName = Send(oSpell,@GetName);
      iChange = 0;

      // Do _not_ replace with HasSpell.
      // This also finds the spell/ability pair and puts it in 'i' for later use.
      foreach i in plSpells
      {
         ++elemNum;
         if spell_num = Send(self,@DecodeSpellNum,#compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         // Can't advance a spell you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if NOT bUsed
      {
         bUsed = -1;
      }

      iAbility = Send(self,@DecodeSpellAbility,#compound=i);
      newAbility = Bound(iAbility+amount,1,99);
      iChange = newAbility-iAbility;

      SetNth(plSpells,elemNum,Send(self,@EncodeSpell,
            #num=spell_num,#iAbility=newAbility));
      Send(self,@DrawStatSpell,#index=elemNum);
      if report AND iChange > 0
      {
         if poOwner <> $
         {
            Post(self,@MsgSendUser,#message_rsc=player_improved,
                  #parm1=spellName,#parm2=newAbility);
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=player_improved_wav_rsc);

            // Report to shrunken head.
            shrunken = GetListElemByClass(plPassive,&ShrunkenHead);
            if shrunken <> $
            {
               Send(shrunken,@Improvement,#spellName=spellName);
            }
         }
      }

      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {
         Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),#change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed in spell ability of ",spellname,
               " by ",iChange," to ",abs(i));
      }

      return TRUE;
   }

   AddToSchools(school=0, change=0)
   {
      local iOldValue, oLore;

      if school = $
         OR school < 1
         OR change = $
         OR change = 0
      {
         return FALSE;
      }

      if plSchools = $
      {
         // 11 elements right now.
         plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      while Length(plSchools) < school
      {
         plSchools = Cons(0, plSchools);
      }

      iOldValue = Nth(plSchools,school);
      SetNth(plSchools,school,(iOldValue+change));

      oLore = Send(SYS,@GetLore);
      Send(oLore,@PlayerAdvanced,#who=self,#school = school);

      return TRUE;
   }

   RefigureSchoolsLists(informlore=FALSE)
   {
      local i, lOldList, oAbility, iSchool, iAbility, iValue, oLore, iNum;

      lOldList = plSchools;

      // 11 elements right now.
      plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];

      foreach i in plSpells
      {
         iAbility = Send(self,@DecodeSpellAbility,#compound=i);
         iNum = Send(self,@DecodeSpellNum,#compound=i);
         oAbility = Send(SYS,@FindSpellByNum,#num=iNum);
         if IsClass(oAbility,&Spell)
         {
            iSchool = Send(oAbility,@GetSchool);
            iValue = Nth(plSchools,iSchool);
            SetNth(plSchools,iSchool,(iValue+iAbility));
         }
      }

      foreach i in plSkills
      {
         oAbility = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oAbility,@GetSchool);
         iAbility = Send(self,@DecodeSkillAbility,#compound=i);
         iValue = Nth(plSchools,iSchool);
         SetNth(plSchools,iSchool,(iValue+iAbility));
      }

      if informlore OR lOldList = $
      {
         // Assume that something has changed
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school=iSchool);

         return;
      }

      // If they changed, update them in the lore.
      if (NOT IsListMatch(lOldList,plSchools))
      {
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school=-1);
      }

      return TRUE;
   }

   AdminSetSpell(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a spell by an additional or absolute value."
   {
      local oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      // Spell must exist.
      if Send(SYS,@FindSpellByNum,#num=num) = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSpellAbility,#spell_num=num);

      // Add?
      if oldAbility = 0
      {
         if Send(self,@AddSpell,#num=num,#iability=ability)
         {
            return player_admin_added_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      // Remove?
      if ability = 0 AND add <= -oldAbility
      {
         if Send(self,@RemoveSpell,#num=num)
         {
            return player_admin_removed_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      // Modify?
      if ability = 0 and add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }

      if Send(self,@ChangeSpellAbility,#spell_num=num,#amount=add)
      {
         return player_admin_modified_spell;
      }

      return Send(SYS,@GetFailureRsc);
   }

   AddSpell(num = 0, iability=0, bDM=FALSE, initial=FALSE, dontSend=FALSE)
   "Admin supported\n"
   "Adds a spell by spell ID to the user's castable list of spells"
   {
      local i, j, oSpell, lSpell_info, lPrereqs, bFound,
            iBoundAbility, lEncode;

      if Send(self,@HasSpell,#num=num)
      {
         if Send(self,@GetSpellAbility,#spell_num=num) < iAbility
         {
            Send(self,@ChangeSpellAbility,#spell_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }

//  When I re-enabled the shadow rift spell, it was only sold by the lich,
//  and the Ao3/SotH quest that was needed to get the spell was broken and unfixable,
//  so I made the spell sold by a different NPC.  I had to remove this check
//  (which clearly doesn't belong in player; should be in the spell itself) to
//  make it buyable.  - ARK 10/26/2010
//
//      if num = SID_SHADOW_RIFT
//          AND ((NOT Send(self, @IsUsingA,#class=&NecromancerAmulet))
//               AND (NOT IsClass(self,&Admin)))
//      {
//         return FALSE;
//      }

      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return FALSE;
      }
      
      if (NOT Send(oSpell,@CanBeLearned))
      {
         return FALSE;
      }

      lPrereqs = Send(oSpell,@GetPrerequisites);

      foreach i in lPrereqs
      {
         if NOT Send(self,@HasSpell,#num=i)
         {
            //Player can't learn this spell without all the prerequisites.
            return FALSE;
         }
      }

      // Spell format: [ num * 100 + ability ]

      iBoundAbility = Bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSpell,@InitialAbility,#who=self);
      }

      lEncode = Send(self,@EncodeSpell,#num=num,#iability=iBoundAbility);
      plSpells = Cons(lEncode,plSpells);

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added spell ",Send(oSpell,@GetName));
      }

      if dontSend = FALSE
      {
         // Added to front of list.
         Send(self,@ToCliAddSpell,#oSpell=oSpell,#iSID=num,#iNum=1);
      }

      if NOT bDM
         AND NOT initial
      {
          Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),
               #change=iBoundAbility);
      }

      if poOwner <> $
         AND NOT bDM
         AND NOT dontSend
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
              #wave_rsc=player_sound_learn_spell);
      }

      foreach i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@PlayerIsIntriguing);

      return TRUE;
   }

   RemoveAllSpells()
   {
      local i;
      
      plSpells=$;
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," lost all spells.");
      }

      Send(self,@PlayerIsIntriguing);

      foreach i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@ToCliStats,#group=3);

      return TRUE;
   }

   RemoveSpell(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a spell by spell ID from the user's castable list of spells"
   {
      local oSpell, i, j, bFound;

      oSpell = Send(SYS,@FindSpellbyNum,#num=num);
      if oSpell = $
      {
         Debug("Trying to delete a spell that doesn't exist in system.");

         return FALSE;
      }

      bFound = FALSE;
      foreach i in plSpells
      {
         if num = Send(self,@DecodeSpellNum,#compound=i)
         {
            plSpells = DelListElem(plSpells,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," removed spell ",Send(oSpell,@GetName));
            }

            Send(self,@ToCliRemoveSpell,#oSpell=oSpell);
            Send(self,@PlayerIsIntriguing);

            bFound = TRUE;
            foreach j in plUsing
            {
               if IsClass(j,&DiscipleRobe)
               {
                  Send(j,@ResetColors);
               }
            }

            if NOT isDM
            {
               // DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

     Debug("Trying to delete a spell not on spell list",self,num);

     return FALSE;
   }

   WasSpellUsed(compound=0)
   {
      if compound > 0
      {
         return TRUE;
      }

      return FALSE;
   }


   FlipSpellAtrophyFlag(SID=0)
   "This spell was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, spellnum;

      // This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSpells
      {
         elemnum = elemnum + 1;
         if Send(self,@DecodeSpellNum,#compound=i) = SID
         {
            SetNth(plspells,elemnum,abs(i));

            break;
         }
      }

      return;
   }

   ActivateSpellAtrophy()
   {
      local i, j, iability, lSchoolsUsed, oSpellA, oSpellB,
            bFound, highmark, iAmount;

      // Must get below highmark for atrophy to activate
      iAmount = -2;

      foreach i in plSpells
      {
         if i < 0
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            if iAbility > 2
            {
               oSpellA = Send(SYS,@FindSpellByNum,
                     #num=Send(self,@DecodeSpellNum,#compound=i));
               bFound = FALSE;

               foreach j in plSpells
               {
                  oSpellB = Send(SYS,@FindSpellByNum,
                        #num=Send(self,@DecodeSpellNum,#compound=j));
                  if j > 0 AND Send(oSpellA,@GetSchool) = Send(oSpellB,@GetSchool)
                  {
                     iAmount = -1;

                     break;
                  }
               }
               Send(self,@ChangeSpellAbility,#spell_num=Send(oSpellA,@GetSpellNum),
                    #amount=iamount);
            }
         }
      }

      return;
   }

   ////  Skills Stuff

   HasSkill(num = $)
   "Returns TRUE if a Skill is in a player's Skill list,"
   "FALSE if it is not."
   {
      local i,oSkill;

      foreach i in plSkills
      {
         if Send(self,@DecodeSkillNum,#compound=i) = num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   EncodeSkill(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used
      {
         return num*100 + iability;
      }

      return -(num*100 + iability);
   }

   DecodeSkillNum(compound = 0)
   {
      return Abs(compound) / 100;
   }

   DecodeSkillAbility(compound = 0)
   {
      return Abs(compound) % 100;
   }

   GetSkillAbility(Skill_num = 0, absolute=FALSE)
   {
      local i;

      foreach i in plSkills
      {
         if Abs(i) / 100 = Skill_num
         {
            return Abs(i) % 100;
         }
      }

      // this Skill is not in the player's Skill list.  return 0 ability.
      return 0;
   }

   ChangeSkillAbility(Skill_num=0,amount=0,report=FALSE,refigureschools=TRUE,bDM=FALSE)
   {
      local i, bFound, elemnum, iability, bUsed, iChange, skillname, 
            newability, oSkill;

      oSkill = Send(SYS,@FindSkillByNum,#num=skill_num);
      if oSkill = $
      {
         return FALSE;
      }

      // Make sure user has this Skill (should always have it if this is being called)
      bFound = FALSE;
      elemnum = 0;
      skillname = Send(oSkill,@GetName);
      iChange = 0;

      // Do _not_ replace with HasSkill.
      // This also finds the Skill/ability pair and puts it in 'i' for later use.
      foreach i in plSkills
      {
         elemnum = elemnum + 1;
         if Skill_num = Send(self, @DecodeSkillNum, #compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         // Can't advance in a skill you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if bUsed = 0
      {
         bUsed = -1;
      }

      iability = Send(self,@DecodeSkillAbility,#compound=i);
      newability = Bound(iability+amount,1,99);
      iChange = newability - iability;

      // If we advance a stroke or a proficiency, then
      // reset our stroke count (and bonuses)
      if IsClass(oSkill,&Stroke) OR IsClass(oSkill,&Proficiency)
      {
         Send(self,@ResetWeaponSwings);
      }

      SetNth(plSkills,elemnum,Send(self,@EncodeSpell,#num=skill_num,
            #iability=newability));
      Send(self,@DrawStatSkill,#index=elemnum);
      if report AND (iChange > 0)
      {
         if poOwner <> $
         {
            Post(self,@MsgSendUser,#message_rsc=player_improved,
                  #parm1=skillName,#parm2=newability);
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=player_improved_wav_rsc);
         }
      }

      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
               #change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed skill ",skillname,"by ",iChange,
               " to ",abs(i)); 
      }

      return TRUE;
   }

   AdminSetSkill(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a skill by an additional or absolute value."
   {
      local oSkill, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if oSkill = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSkillAbility,#skill_num=num);

      // Add?
      if oldAbility = 0
      {
         if Send(self,@AddSkill,#num=num,#iability=ability)
         {
            return player_admin_added_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      // Remove?
      if ability = 0 AND add <= -oldAbility
      {
         if Send(self,@RemoveSkill,#num=num)
         {
            return player_admin_removed_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      // Modify?
      if ability = 0 AND add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }

      if Send(self,@ChangeSkillAbility,#skill_num=num,#amount=add)
      {
         return player_admin_modified_skill;
      }

      return Send(SYS,@GetFailureRsc);
   }

   AddSkill(num=0,iability=0,bDM=FALSE,initial=FALSE,dontSend=FALSE)
   "Admin supported\n"
   "Adds a Skill by Skill ID to the user's castable list of Skills"
   {
      local i,j,oSkill, lSkill_info, lPrereqs, bFound, iBoundAbility;

      if Send(self,@HasSkill,#num=num)
      {
         // Already has it.
         if Send(self,@GetSkillAbility,#skill_num=num) < iAbility
         {
            Send(self,@ChangeSkillAbility,#skill_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if (oSkill = $)
      {
         // System has no info on this skill.
         return FALSE;
      }

      // Skill format: [ num * 100 + ability ]

      iBoundAbility = Bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSkill,@InitialAbility,#who=self);
      }

      plSkills = Cons(Send(self,@EncodeSkill,#num=num,
                     #iability=iBoundAbility),plSkills);

      // Special case: Second Wind is so essential to resource generation that we
      // want to keep it as a property in battler to cut down on message calls.
      if num = SKID_SECOND_WIND
      {
         Send(self,@SetSecondWind,#i=iBoundAbility);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added skill ",Send(oSkill,@GetName));
      }

      if NOT dontSend
      {
         // Added to front of list.
         Send(self,@ToCliAddSkill,#oSkill=oSkill,#iSKID=num,#iNum=1);
      }

      if NOT bDM and NOT initial
      {
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
               #change=iBoundAbility);
      }

      return TRUE;
   }

   RemoveAllSkills()
   {
      plSkills = $;

      if Send(self,@checklog)
      {
         Debug("LOG:  ",vrName," loses all skills.");
      }

      Send(self,@ToCliStats,#group=4);

      return TRUE;
   }

   RemoveSkill(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a Skill by Skill ID from the user's castable list of Skills"
   {
      local oSkill, i, iVigorChange;

      oSkill = Send(SYS,@FindSkillbyNum,#num=num);
      if oSkill = $
      {
         Debug("Trying to delete a skill the system doesn't recognize.");

         return FALSE;
      }

      foreach i in plSkills
      {
         if num = Send(self,@DecodeSkillNum,#compound=i)
         {
            plSkills = DelListElem(plSkills,i);

            if (num = SKID_SECOND_WIND)
            {
               piWind = 0;
            }

            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," lost skill ",Send(oSkill,@GetName));
            }

            Send(self,@ToCliRemoveSkill,#oSkill=oSkill);

            if NOT isDM
            {
               // DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

      Debug("Tried to delete skill not in skill list",self,num);

      return FALSE;
   }

   FlipSkillAtrophyFlag(SKID=0)
   "This Skill was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, Skillnum;

      // This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSkills
      {
         elemnum = elemnum + 1;
         if Send(self,@decodeSkillNum,#compound=i) = SKID
         {
            SetNth(plSkills,elemnum,abs(i));

            break;
         }
      }

      return;
   }

   ActivateSkillAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSkill, bSkill,
            bFound, highmark, iAmount;

      iAmount = -2;

      foreach i in plSkills
      {
         if i < 0
         {
            iAbility = Send(self,@decodeSkillability,#compound=i);
            if iAbility > 2
            {
               aSkill = Send(SYS,@FindSkillByNum,
                     #num=Send(self,@DecodeSkillNum,#compound=i));
               bFound = FALSE;
               foreach j in plSkills
               {
                  bSkill = Send(SYS,@FindSkillByNum,
                        #num=Send(self,@DecodeSkillNum,#compound=j));
                  if j > 0 AND Send(aSkill,@GetSchool) = Send(bSkill,@GetSchool)
                     AND aSkill <> bSkill
                  {
                     iAmount=-1;
                     break;
                  }
               }

               Send(self,@ChangeSkillAbility,#skill_num=Send(aSkill,@GetSkillNum),
                    #amount=iAmount);
            }
         }
      }

      return;
   }

   ////  Advancement

   ResetAtrophyFlags()
   "This sets all of a player's spell values to negative."
   "This means that the player has not used these spells in a while."
   "Meaning they have a chance to atrophy when ptAdvancement goes off."
   {
      local i, elemnum;

      // This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSpells
      {
         elemnum = elemnum+1;
         SetNth(plSpells,elemnum,-(abs(i)));
      }

      elemnum = 0;
      foreach i in plSkills
      {
         elemnum = elemnum+1;
         SetNth(plSkills,elemnum,-(abs(i)));
      }

      return;
   }

   AdvancementTimer()
   "This checks for spell or skill atrophy, "
   "and resets the atrophy flags."
   {
      ptAdvancement = $;

      if pbLogged_on
      {
         if Send(SETTINGS_OBJECT, @IsAtrophyOn)
         {
            Send(self,@ActivateSpellAtrophy);
            Send(self,@ActivateSkillAtrophy);
         }

         Send(self,@ResetAtrophyFlags);
      }

      return;
   }

   //// Advancement in combat

   SomethingKilled(what=$,victim=$,use_weapon=$)
   {
      local i, bGainedCharge, oSpellDeathLink;

      if NOT IsClass(victim,&Battler)
      {
         propagate;
      }

      // If we have death link up, give a vigor boost
      oSpellDeathLink = Send(SYS,@FindSpellByNum,#Num=SID_DEATH_LINK);

      if Send(self,@IsEnchanted,#what=oSpellDeathLink)
      {
         Send(oSpellDeathLink,@GiveKilledBenefits,#Caster=self,#Victim=victim);
      }

      // Let our recharging rods know we killed something.
      if what = self
      {
         bGainedCharge = FALSE;

         foreach i in plPassive
         {
            if IsClass(i,&Rod)
               AND Send(i,@SomethingKilled,#what=what,#victim=victim)
            {
               bGainedCharge = TRUE;
            }
         }

         // Notify the player if he gained a charge on any recharging
         // wand (just one message for all of them)
         if bGainedCharge
         {
            Send(self,@MsgSendUser,#message_rsc=rod_gained_charge_msg);
         }
      }

      if victim = poKill_target
      {
         if what = self
            OR what = poMercenary // Merc kills count as our own.
         {
            Send(self,@AdvancementCheck,#what=victim,#killing_blow=TRUE);
         }
         else
         {
            Send(self,@AdvancementCheck,#what=victim,
                  #killing_blow=FALSE,#group_member=what);
         }

         Send(self,@ResetGainFlags);
      }
      else
      {
         // Let players share XP if they're grouped, even if
         // they're not fighting the same mob.
         if Send(poOwner,@AreGroupedHere,#who=self,#what=what)
         {
            Post(self,@AdvancementCheck,#what=victim,#killing_blow=FALSE,
                  #group_member_kill=TRUE,#group_member=what);
         }
      }

      propagate;
   }

   ResetGainFlags()
   {
      poKill_target = $;
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE, #value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_DODGED, #value=FALSE);

      return;
   }

   CanPlayerAdvanceOnMe()
   {
      return (Send(self,@FindUsing,#class=&Token) = $);
   }

   AdvancementCheck(what=$,killing_blow=TRUE,group_member_kill=FALSE,group_member=$)
   "A player will need, on average, to kill a number of monsters equal to"
   "their maxhealth to gain a HP.  This number is reduced by the player's"
   "stamina, all the way down to half for those with high staminas."
   {
      local i, iMaxHealth, dodgeskill, oSkill, monster_level, iXP, oWeapon,
            iItemBonus, iUnbound, iDist, iDifference, iBonus;

      iXP = 0;
      iItemBonus = 0;

      // Some things just never allow advancement.
      // Can advance in arena if realdeath is on in an arena.
      if NOT Send(what,@CanPlayerAdvanceOnMe)
         OR Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         OR (Send(poOwner,@IsArena))
      {
         return FALSE;
      }

      if IsClass(what,&User)
      {
         // Set a reasonable upper bound to handle event characters.
         monster_level = Bound(Send(what,@GetBaseMaxHealth),MIN_HEALTH,1000);
      }
      else
      {
         monster_level = Send(what,@GetLevel);
      }

      if ((piFlags & PFLAG_DID_DAMAGE)
         AND poKill_target = what)
         OR group_member_kill
      {
         // Allow players to improve defensive spells!
         if killing_blow 
            AND ((piFlags & PFLAG_TOOK_DAMAGE)
               OR (piFlags & PFLAG_DODGED))
         {
            foreach i in plPassiveImprovement
            {
               if Nth(i,2) AND Random(1,5) = 5
               {
                  Send(First(i),@ImproveAbility,#who=self,#target=what);
               }
            }
         }

         iMaxHealth = Send(self,@GetBaseMaxHealth);

         // Determine the base amount of XP awarded:
         // Full XP for when the player got the kill and dodged or took damage.
         // 66% XP when the player didn't get the kill (they dodged or took
         // damage from any source).
         // 25% XP for any other group member kill.
         // 25% XP for monsters at the same level as the player.
         // 10% XP for monsters 1-4HP lower than the player.
         if monster_level > iMaxHealth
         {
            if killing_blow
               AND ((piFlags & PFLAG_TOOK_DAMAGE)
                  OR (piFlags & PFLAG_DODGED))
            {
               // Player took damage and landed killing blow
               iXP = monster_level;

               // Add any item XP bonuses here. Have to get the kill, and
               // either take damage or dodge to gain bonus XP.
               foreach i in plUsing
               {
                  iItemBonus += Send(i,@GetItemXPBonus);
               }
            }
            else
            {
               // Player either did not take damage, but did killing blow (mage),
               // or did take damage, did not land killing blow, or it's a group
               // member kill.
               if (poKill_target = what
                  AND ((piFlags & PFLAG_TOOK_DAMAGE)
                     OR (piFlags & PFLAG_DODGED)
                     OR killing_blow))
               {
                  iXP = monster_level / 3 * 2;
               }
               else
               {
                  iXP = monster_level / 4;
               }

               if group_member_kill
                  AND group_member <> $
                  AND NOT killing_blow
               {
                  Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                        #parm1=Send(group_member,@GetName),
                        #parm2=Send(what,@GetName));
               }
            }
         }
         else if (monster_level + 5) > iMaxHealth
               AND IsClass(what,&Monster) AND killing_blow
               AND ((piFlags & PFLAG_TOOK_DAMAGE)
                  OR (piFlags & PFLAG_DODGED))
         {
            // Monster was equal or close to player level.  Small bonus.
            if (monster_level = iMaxHealth)
            {
               iXP = monster_level / 4;
            }
            else
            {
               iXP = monster_level / 10;
            }
         }
         else if Random(1,100) < 30 AND killing_blow
         {
            // Monster was too easy for player to kill!
            Send(self,@MsgSendUser,#message_rsc=player_spits);
         }

         // Check if we are awarded any additional XP or TP for defeating a boss.
         // The bonus scales with regular XP received before modifiers.
         // Calculate TP first because we don't want to base the value on 
         // XP post bonus.
         iBonus = Send(what,@GetBonusTP) * iXP / monster_level;
         piTraining_points += iBonus;

         // Alright, now it's time for the XP bonus.
         iXP += Send(what,@GetBonusXP) * iXP / monster_level;

         // Add stamina modifier here.
         // 1% bonus for 1 stamina, 70% bonus for 70 stamina.
         iXP += iXP * Send(self,@GetStamina) / 100;

         // Determine XP bonuses on top of the base amount:
         // Newbies get 10% bonus XP.
         // 2XP (default) per survival arena level.
         // Halve XP if player has more than twice their base health.
         // Multiply total XP by the global XP percent setting.
         if iMaxHealth < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
         {
            iXP = iXP * 11 / 10;
         }

         if Send(what,@GetBoostedLevel) > 0
         {
            iXP += (Send(what,@GetBoostedLevel)
                 * Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalXP));
         }

         // If they're cheesing the situation by fighting wussy monsters
         // in an altered form, penalize the XP.
         if piMax_health > iMaxHealth * 2
            AND monster_level < piMax_health
         {
            iXP /= 2;
         }

         // Scale XP with server modifier.
         iXP = iXP * Bound(Send(SETTINGS_OBJECT,@GetXPPercent),50,500) / 100;

         // Add in XP bonus from items after this.
         iXP += iItemBonus;
         // AddXP checks for HP gain and redraws the XP bar.
         // NOTE: iMaxHealth could be wrong after this point.
         Send(self,@AddXP,#iAmount=iXP);

         // Also grant unbound energy for your own kills.
         // Unbound energy allows free spell casts.
         if IsClass(what,&Monster) AND killing_blow
         {
            // Let's figure the amount, mostly based on monster level.
            iUnbound = monster_level * Send(SETTINGS_OBJECT,@GetUnboundAbsorption)
               * (Random(30,80) + (Send(self,@GetMysticism) * 2 / 5)) / 10000;

            // Scale with distance to victim.
            iDist = Bound(Send(self,@SquaredFineDistanceTo3D,#what=what),1,$);
            // 36864 is 3 range in fine units, cf. SquaredFineDistanceTo3D.
            iUnbound = Bound(iUnbound * 36864 / iDist,$,iUnbound);

            // Scale with player level.
            iDifference = piMax_health - monster_level;
            if iDifference > 10
            {
               iUnbound = Bound(iUnbound * 100 / (iDifference * iDifference),$,iUnbound);
            }

            // Not awarding any unbound energy to players who have recently been involved
            // in PvP.
            if Send(self,@GetLastPlayerAttackTime)
               + Send(SETTINGS_OBJECT,@UnboundEnergyAttackDelaySec)
               > GetTime()
            {
               if iUnbound > 0
               {
                  Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_wasted);
               }
            }
            else
            {
            
               // Grant only one fourth of the energy if the mob didn't attack the player.
               if ((piFlags & PFLAG_TOOK_DAMAGE) OR (piFlags & PFLAG_DODGED))
               {
                  Send(self,@AddUnboundEnergy,#iAmount=iUnbound);
               }
               else
               {
                  Send(self,@AddUnboundEnergy,#iAmount=iUnbound / 4);
               }
            }
         }

         // Here, we work out if the player deserves a training point.
         // They qualify if they got at least one gain point from the monster,
         // and also got the killing blow (no double points from single mobs).
         if iXP > 0
            AND killing_blow
            AND piTraining_points < 1000
         {
            piTraining_points = piTraining_points + 1
               + (Send(what,@GetBoostedLevel)
               / Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalTP));

            if monster_level > 150
            {
               piTraining_points = piTraining_points + 3;
            }
            else if monster_level > 120
            {
               piTraining_points = piTraining_points + 2;
            }
            else if monster_level > 75
            {
               ++piTraining_points;
            }
         }

         // Let the player know how many training points they have, if they
         // either reached the max, or a multiple of 100.
         if piTraining_points > 999
         {
            if NOT (piFlags2 & PFLAG2_NO_INFORM_TP)
            {
               Send(self,@MsgSendUser,#message_rsc=player_reached_maxtraining,
                  #parm1=piTraining_points);
               piFlags2 |= PFLAG2_NO_INFORM_TP;
            }
         }
         else if piTraining_points % 100 = 0
               AND piTraining_points <> 0
               AND NOT (piFlags2 & PFLAG2_NO_INFORM_TP)
         {
            Send(self,@MsgSendUser,#message_rsc=player_training_inform,
                  #parm1=piTraining_points);
         }

         // Draw the training points bar.
         Post(self,@DrawTraining);

         // Inform the player about bonus TP if they've received any.
         if iBonus > 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_bonus_tp,#parm1=iBonus);
         }
      }

      if (piFlags & PFLAG_DODGED)
         AND NOT group_member_kill
      {
         oWeapon = Send(self,@LookupPlayerWeapon);
         if oWeapon <> $
            AND (NOT IsClass(oWeapon,&RangedWeapon))
            AND Send(self,@HasSkill,#num=SKID_PARRY)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_PARRY) < 99
         {
            oSkill = Send(SYS,@FindSkillByNum,#num=SKID_PARRY);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }

         if (Send(self,@LookupPlayerShield) <> $)
            AND Send(self,@HasSkill,#num=SKID_BLOCK)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_BLOCK) < 99
         {
            oSkill = Send(SYS,@FindSkillByNum,#num=SKID_BLOCK);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }

         if Send(self,@HasSkill,#num=SKID_DODGE)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_DODGE) < 99
         {
            oSkill = Send(SYS,@FindSkillByNum,#num=SKID_DODGE);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }
      }

      return;
   }

   TryGainBaseMaxHealth()
   "Handles the roll for tougher based on the player's gain chance plus "
   "the iLevel parameter.  Returns TRUE if the player gaints a hit point, "
   "FALSE otherwise.  The iLevel parameter has the player's base max HP "
   "taken from it, then divided by 5 before being bound between 1 and 10."
   {
      local bGainHP, iMaxHealth, oShrunken, iStamina;

      bGainHP = FALSE;

      while (Send(self,@GetBaseMaxHealth) < (101 + Send(self,@GetStamina))
         AND Send(self,@GetXPRemainingForNextLevel) <= 0)
      {
         Send(self,@GainBaseMaxHealth,#amount=1);
         bGainHP = TRUE;
      }

      if (bGainHP)
      {
         if Send(self,@CheckLog)
         {
            Debug("LOG:  ",vrName," gained a health point: ",
                  piMax_health,pibase_max_health);
         }

         Send(self,@EvaluatePKStatus);

         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=player_improve_maxhealth);
            Send(self,@WaveSendUser,#what=self,#wave_rsc=player_tougher_wav_rsc);

            // Boost the player to max health, and give them 200 vigor.
            Send(self,@MsgSendUser,#message_rsc=player_improve_health_invigorate);
            piHealth = piMax_health * 100;
            Send(self,@DrawHealth);
            Send(self,@EatSomething,#nutrition=200);
            Post(self,@DrawOffense);
            Post(self,@DrawDefense);

            // Report to shrunken head, if they have one.
            oShrunken = GetListElemByClass(plPassive,&ShrunkenHead);
            if oShrunken <> $
            {
               Send(oShrunken,@Tougher,#hp=Send(self,@GetBaseMaxHealth));
            }
         }

         // If they are at max HP, award some training points instead.
         // Awards the TP when the player hits max HP also (reward!).
         iStamina = Send(self,@GetStamina);

         iMaxHealth = Send(self,@GetBaseMaxHealth);

         if (iMaxHealth >= 100 + iStamina
            OR iMaxHealth >= MAX_HEALTH)
         {
            Send(self,@AddTrainingPoints,#points=iMaxHealth * 3,#bCap=FALSE);
         }

         // Allow our mercenary to gain a level as well.
         if poMercenary <> $
            AND NOT IsTimer(poMercenary)
            AND IsClass(poMercenary,&Follower)
         {
            Send(poMercenary,@FollowerDing);
         }

         return TRUE;
      }

      return FALSE;
   }

   GetTotalXP()
   {
      return piXP_total;
   }

   AddXP(iAmount=0,report=TRUE)
   "All code that adds or subtracts XP should go through this message. "
   "Handles resource display and toughers."
   {
      local iXPNeeded;

      // Add to total.
      piXP_total = Bound(piXP_total + iAmount,0,MAX_XP);

      // Get the amount they need for the next HP
      iXPNeeded = Send(SYS,@GetXPForLevel,#iHP=piBase_Max_health + 1);

      // TryGainBaseMaxHealth checks if player can be awarded a hit point.
      if (piXP_total >= iXPNeeded)
      {
         Send(self,@TryGainBaseMaxHealth);
      }
      else
      {
         while (piXP_total < Send(SYS,@GetXPForLevel,#iHP=piBase_Max_health))
         {
            Send(self,@GainBaseMaxHealth,#amount=-1);
         }
      }

      if (pbLogged_on AND report)
      {
         if iAmount > 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_experience_gained,
                  #parm1=iAmount);
         }
         else if iAmount < 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_experience_lost,
                  #parm1=Abs(iAmount));
         }

         Post(self,@DrawXP);
      }

      return;
   }

   AddUnboundEnergy(iAmount=0,report=TRUE)
   {
      // Add to total. Check reasonable limits first. You can't lose
      // more points than you have and you can't get more points than
      // you need to reach the cap.
      iAmount = Bound(iAmount,-piUnbound_energy,Send(SETTINGS_OBJECT,@GetUnboundMax) - piUnbound_energy);
      piUnbound_energy += iAmount;

      if (pbLogged_on AND report)
      {
         if iAmount > 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_gained,
                  #parm1=iAmount,#parm2=piUnbound_energy);
         }
         else if iAmount < 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_lost,
                  #parm1=-iAmount,#parm2=piUnbound_energy);
         }
      }

      // Only delay decay if we gain points.
      if iAmount > 0
      {
         Send(self,@NewUnboundEnergy,#bDelay=TRUE);
      }
      else
      {
         Send(self,@NewUnboundEnergy,#bDelay=FALSE);
      }

      return;
   }

   WipeUnboundEnergy(report=TRUE)
   {
      if (pbLogged_on AND report AND piUnbound_energy > 0)
      {
         Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_wiped);
      }

      // Remove all unbound energy, for example after a teleport.
      send(self,@AddUnboundEnergy,#iAmount=-piUnbound_energy,#report=FALSE);

      return;
   }

   GetXPRemainingForNextLevel()
   {
      // Use raw base max health here, can go higher than 150.
      return Send(SYS,@GetXPForLevel,#iHP=piBase_Max_health + 1) - piXP_total;
   }

   ResetXPToLevel()
   "Sets the player's total XP to the amount they would have needed to "
   "get to their current HP. Called if the player's max HP is lowered and "
   "extra XP needs to be removed to prevent them gaining multiple toughers."
   {
      // Use piBase_Max_health directly.
      piXP_total = Send(SYS,@GetXPForLevel,#iHP=piBase_Max_health);

      return;
   }

   CheckValidHP()
   {
      if (piMax_health > 100 + Send(self,@GetStamina))
      {
         Debug(Send(self,@GetTrueName)," has ",piMax_health," HP with ",
               Send(self,@GetStamina)," stamina.");
      }

      return;
   }

   GetTrainingPoints()
   {
      return piTraining_points;
   }

   GetUnboundEnergy()
   {
      return piUnbound_energy;
   }

   AddTrainingPoints(points=0,report=TRUE,bCap=TRUE)
   {
      if points = 0
      {
         return;
      }

      if bCap
      {
         if piTraining_points <= 1000
         {
            points = Bound(points,-piTraining_points,1000 - piTraining_points);
         }
         else if points > 0
         {
               // We're respecting the 1000 point cap, have more than 1000
               // points and are trying to add more. Don't add the points,
               // return out.
               return;
         }
      }

      if report AND points > 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_gained_training,
               #parm1=points);
      }

      if report AND points < 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_spent_training,
               #parm1=-points);
      }

      piTraining_points = piTraining_points + points;

      if piTraining_points < 1000
         OR NOT bCap
      {
         piFlags2 &= ~PFLAG2_NO_INFORM_TP;
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=player_reached_maxtraining,
               #parm1=piTraining_points);
         piFlags2 |= PFLAG2_NO_INFORM_TP;
      }

      Post(self,@DrawTraining);

      return;
   }

   GetDailyTrainingReward()
   {
      local iBonus;

      ptReward_timer = CreateTimer(self,@GetDailyTrainingReward,24*60*60*1000);

      if piTraining_points >= 1000
      {
         return;
      }

      // Retrieve the daily logon bonus from settings.
      iBonus = Send(SETTINGS_OBJECT,@GetLogonBonus);

      Send(self,@MsgSendUser,#message_rsc=player_logon_bonus,#parm1=iBonus);
      Send(self,@AddTrainingPoints,#points=iBonus,#report=FALSE);

      piReward_timestamp = GetTime();

      return;
   }

   //// Player Killed //

   Killed(what = $, stroke_obj = $)
   {
      local lItems,i, j, amount, oBody, oSoldierShield, bNo_drop_death, oItemAtt,
            oRoom, iRow, iCol, iFine_Row, iFine_Col, iAngle, oItem,
            iRoom, lInventoryContents, lReagentBagContents;

      // If this player has created any evil twins, delete them.
      Send(self,@RemoveAllCreatedEvilTwins);

      // If we have Apparitions attacking us, delete them.
      Send(self,@RemoveAllApparitions);

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
      {
         return;
      }

      if poOwner <> $
         AND IsClass(poOwner,&Room)
         AND Send(poOwner,@OverridesDeathFunction)
      {
         Send(poOwner,@OverrideDeathFunction,#who=self,#what=what);

         return;
      }

      // Skill, spell and hp penalties are handled by ApplyDeathPenalties, which
      // is called from LeaveHold() in the Underworld.  This is to allow time
      // for Portal of Life to reduce penalties.  We get the default value of
      // piDeathCost from SYS, so that we can adjust global death penalties.
      // "Normal" value is 100.
      piDeathCost = Send(SETTINGS_OBJECT,@GetDefaultDeathCost);

      // A player (probably) cannot die twice in two seconds in any valid way.
      if GetTime() < (piLastDeathTime + 2)
      {
         Debug("Averted double-death of",vrName);

         return;
      }

      // Stop any rescue attempts that were going on.
      Send(self,@CancelRescue);
      

      // Grab the location of the deceased.
      // Might need to grab the old location if logged off.

      if pbLogged_on
      {
         oRoom = poOwner;
         iRow = piRow;
         iCol = piCol;
         iFine_Row = piFine_Row;
         iFine_Col = piFine_Col;
         iAngle = Send(self,@GetAngle);
         iRoom = Send(poOwner,@GetRoomNum);
      }
      else
      {
         if NOT Send(self,@IsUsingA,#class=&NecromancerAmulet)
         {
            Debug("Player died while offline, but not a necromancer: ",
                  Send(self,@GetName));
         }

         iRoom = Send(self,@GetSaveRoom);
         oRoom = Send(SYS,@FindRoomByNum,#num=iRoom);
         iRow = Send(self,@GetSaveRow);
         iCol = Send(self,@GetSaveCol);
         iFine_Row = Send(self,@GetSaveFineRow);
         iFine_Col = Send(self,@GetSaveFineCol);
         iAngle = Send(self,@GetSaveAngle);
      }

      // Any other quick escapes from certain death?
      // Such as the Arena "loser", or while in the Out of Grace prison.
      // These aren't cheap deaths, these are ways to avoid actual death.
      if pbLogged_on
         AND ((Send(poOwner,@IsArena)
               AND Send(poOwner,@InPlay,#what=self)
               AND NOT Send(poOwner,@ArenaRealDeath))
              OR IsClass(poOwner,&OutOfGrace)
              OR (Send(poOwner,@SafePlayerAttack)
               AND NOT Send(poOwner,@ArenaRealDeath)))
      {
         piHealth = 1;
         Send(self,@NewHealth);

         // Currently, the following block is only for
         // Necromancer Amulets and Hunter Swords.
         foreach i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }

         return;
      }

      // Okay, we're really dying now.
      // Now we need to determine if it's a 'cheap'
      // death where we don't lose stuff.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      Send(self,@DeleteAllOverTimeEffects);
      bNo_drop_death = FALSE;

      // Reign of Blood Frenzy death?  Newbie death?
      // Don't drop anything or take any penalties.
      if Send(SYS,@GetChaosNight)
         OR Send(self,@HasHonorString,#string=player_newbie_honor_string)
         OR (NOT (piFlags & PFLAG_PKILL_ENABLE)
            AND NOT Send(SETTINGS_OBJECT,@NewbiesDropLoot))
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;
      }
      else if (Send(poOwner,@IsArena)
         AND NOT Send(poOwner,@ArenaDropItems))
      {
         // If we get to here and we are in an arena, check for item drop.
         bNo_drop_death = TRUE;
      }

      // Currently, the following block is only for Necromancer Amulets
      // and Hunter Swords. This is placed before the token death check,
      // so that token deaths _will_ make you lose your artifact.
      if bNo_drop_death
      {
         foreach i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }
      }

      // Record-keeping. Keep this before the token check,
      // so we can give proper message.
      Send(SYS,@UserKilled,#what=self,#killer=what,#oRoom=oRoom,#stroke_obj=stroke_obj);
      Send(Send(SYS,@GetStatistics),@PlayerDiedCounter);

      // Token death?
      i = GetListElemByClass(plUsing,&Token);
      if i <> $
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;
         Send(self,@MsgSendUser,#message_rsc=player_token_death);
         Send(i,@NewUnused,#what=self,#where=oRoom);
      }

      // Create the corpse.
      oBody = Send(self,@CreateCorpse);
      Send(oRoom,@NewHold,#what=oBody,#new_row=iRow,#new_col=iCol,
            #fine_row=iFine_Row,#fine_col=iFine_Col,#new_angle=iAngle);

      // Start losing stuff if applicable.
      if NOT bNo_drop_death
      {
         if ptHealth <> $
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }

         // Lose the inventory.  It falls onto the corpse.
         if (what = $) OR (NOT IsClass(what,&user))
         {
            oItemAtt = $;
         }
         else
         {
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_PKPOINTER);

            if what <> $
            {
               // We've been killed by a player, so set the PKed flag for
               // the temp safety angel to trigger later, provided we meet
               // all the requirements. Check for not $ here - fastest way
               // to implement this without performing another IsClass check.
               piFlags = piFlags | PFLAG_KILLED_BY_PLAYER;
            }
         }

         lReagentBagContents = Send(self,@GetReagentBagContents);
         if lReagentBagContents <> $
         {
            lInventoryContents = [plActive,plPassive,lReagentBagContents];
         }
         else
         {
            lInventoryContents = [plActive,plPassive];
         }

         foreach lItems in lInventoryContents
         {
            foreach i in lItems
            {
               // Let the item know we died, in case it does something special.
               Send(i,@OwnerKilled);

               if Send(i,@DropOnDeath)
                  AND Send(oRoom,@ReqNewHold,#what=i,#new_row=iRow,#new_col=iCol)
               {
                  if oItemAtt <> $
                  {
                     // We know this was a pk.  Only let PKillables pick up
                     // the loot. Put the appropriate item attribute on it.
                     Send(oItemAtt,@AddToItem,#oItem=i,
                           #timer_duration=PKPOINTER_TIME,#state1=self);
                  }

                  Send(oRoom,@NewHold,#what=i,#merge=FALSE,
                        #new_row=iRow,#new_col=iCol,
                        #fine_row=iFine_row,#fine_col=iFine_col);
               }
            }
         }

         // Atrophy of skills or learning progress.
         Send(self,@ResetGainFlags);
         Send(self,@ResetAtrophyFlags);
         if ptAdvancement <> $
         {
            DeleteTimer(ptAdvancement);
            ptAdvancement = $;
         }

         Post(self,@EvaluatePKStatus);

         // Let SoldierShields know we died. It handles itself as appropriate.
         oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
         if oSoldierShield <> $
         {
            Send(oSoldierShield,@OwnerDied,#what=what);
         }

         // Positive karma makes us eligible for a booby prize.
         if piKarma > 5000
         {
            // To prevent mule money abuse, make the hammer "created".
            // This makes it worthless to try to sell. It lasts for 5 hours.
            oItem = Create(&Hammer);
            oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
            Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
            Send(self,@NewHold,#what=oItem);
         }
         else if piKarma >= 0
         {
            // To prevent mule money abuse, make the mace "created".
            // This makes it worthless to try to sell. It lasts for 5 hours.
            oItem = Create(&Mace);
            oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
            Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
            Send(self,@NewHold,#what=oItem);
         }
      }

      // Give out your dying scream.
      if piGender = GENDER_FEMALE
      {
         i = playerf_death_wav;
      }
      else
      {
         i = playerm_death_wav;
      }

      Send(oRoom,@SomethingWaveRoom,#what=oBody,#wave_rsc=i);
      if pbLogged_on
      {
         Send(self,@WaveSendUser,#what=self,#wave_rsc=i);
      }

      if poMercenary <> $ 
         AND NOT IsTimer(poMercenary)
         AND (Send(poMercenary,@GetOwner) = poOwner)
      {
         Send(poMercenary,@Killed);
      }

      if NOT bNo_drop_death
         AND piDeathCost
      {
         Send(self,@DeathLoseHonor,#killer=what);
      }

      piLastDeathTime = GetTime();

      // Teleport to the Underworld.
      Send(self,@UserGotoDeadRoom);

      // Change health, mana, vigor.
      if Send(SYS,@GetChaosNight)
      {
         // It's a frenzy!  Give us a leg up.
         piHealth = 80 * piMax_health;
         piMana = 80 * piMax_mana;
         piVigor = 20000;
      }
      else
      {
         // We're not in a frenzy.  Give us the bare minimums.
         piMana = 1;
         piHealth = 1;
         piVigor = Bound(piVigor/4,1500,5000);
      }

      Send(self,@UpdateRates);

      // Refresh the client with what's really going on.
      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);

         // Wake up with red foggy hangover.
         Send(self,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=5000);
      }

      if piDeathCost > 0
         AND NOT (piFlags & PFLAG_TUTORIAL)
         AND NOT (piFlags & PFLAG_MURDERER)
      {
         // Give an encouraging gmail and some mana to broadcast.
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_death_mail]);
         Send(self,@MsgSendUser,#message_rsc=player_death_mail_notice);

         // Give them half their mana to broadcast for help with.
         piMana = piMax_mana * 50 + 200;
         Send(self,@NewMana);
      }

      if poOwner = oRoom
         AND pbLogged_on
      {
         Debug("Player didn't teleport after death!",vrName);
      }

      propagate;
   }

   DeathLoseHonor(killer = $)
   {
      local i, j, iHonorLost, iNumHurters, iHonorEach, iLostTotal, iKillHonor,
            oHurter, oHurterOwner, bIsNear;

      if NOT Send(SETTINGS_OBJECT,@HonorSystemActive)
         OR killer = $
      {
         return;
      }

      iHonorLost = 0;
      iNumHurters = 0;
      iHonorEach = 0;
      iLostTotal = 0;
      iKillHonor = Send(SETTINGS_OBJECT,@GetHonorLossKill);

      // Find out how many people assisted in the kill.
      foreach i in plHurtMeRecently
      {
         oHurter = First(i);
         // Don't count the killer or ourselves for assists.
         if IsClass(oHurter,&Player)
            AND oHurter <> killer
            AND oHurter <> self
         {
            ++iNumHurters;
         }
      }

      // If other players assisted, distribute part of the kill honor among them.
      if iNumHurters <> 0
      {
         iHonorEach = ((iKillHonor * 3) / 10) / iNumHurters;
         iKillHonor = (iKillHonor * 7) / 10;
      }

      if IsClass(killer,&Player)
         AND killer <> self
      {
         iHonorLost = Send(self,@TransferHonorPoints,#who=self,
                           #what=killer,#honor=iKillHonor);
         Send(killer,@MsgSendUser,#message_rsc=player_honor_gain_kill,
               #parm1=iHonorLost,#parm2=Send(self,@GetName));
         iLostTotal += iHonorLost;
      }

      // Attempt to give the honor points from the victim to the attacker(s).
      foreach i in plHurtMeRecently
      {
         bIsNear = FALSE;
         oHurter = First(i);
         // Only count players that can fight.
         if oHurter = self
            OR oHurter = killer
            OR NOT IsClass(oHurter,&Player)
            OR Send(oHurter,@IsOfflineOrCannotInteract)
         {
            continue;
         }
         oHurterOwner = Send(oHurter,@GetOwner);
         if poOwner = oHurterOwner
         {
            bIsNear = TRUE;
         }
         else
         {
            // The attacker can fight but isn't in the same room as the victim.
            // Check if they are in a nearby combat area since PvP involves movement.
            foreach j in Send(poOwner,@GetYellZone)
            {
               if Send(SYS,@FindRoomByNum,#num=j) = oHurterOwner
                  AND NOT Send(oHurterOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
                  AND NOT Send(oHurterOwner,@CheckRoomFlag,#flag=ROOM_NO_PK)
                  AND NOT Send(oHurterOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
               {
                  bIsNear = TRUE;
               }
            }
         }
         if bIsNear
         {
            // The attacker is nearby and can participate in PvP. Give them the points.
            iHonorLost = Send(self,@TransferHonorPoints,#who=self,
                              #what=oHurter,#honor=iHonorEach);
            iLostTotal += iHonorLost;
            Send(oHurter,@MsgSendUser,#message_rsc=player_honor_gain_assist,
                  #parm1=iHonorLost,#parm2=Send(self,@GetName));
         }
      }

      // Don't inform the player if they didn't lose any points. Reasons for this can include
      // them not having any to give or all attackers having fled the battlefield.
      if iLostTotal > 0
      {
         Send (self,@MsgSendUser,#message_rsc=player_honor_loss_death,#parm1=iLostTotal);
      }
      // Clear attacker list so old attackers don't get anything if the player
      // pens/dies again soon and they didn't participate.
      Send(self,@ClearHurtMeRecently);

      return;
   }

   ApplyDeathPenalties()
   {
      local iXPLoss, iAmount, i, bTempSafe;

      bTempSafe = FALSE;

      if (piFlags & PFLAG_KILLED_BY_PLAYER)
      {
         bTempSafe = TRUE;
         piFlags = piFlags & ~PFLAG_KILLED_BY_PLAYER;
      }

      if (piflags & PFLAG_DEATH_RIFTING)
      {
         // Leaving the Underworld while protected, no penalties. Protection
         // is removed in NewOwner to allow them to log off without penalties.
         return;
      }

      if Send(SYS,@GetChaosNight)
      {
         // Remove any revenants.
         Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);

         // Return out.  Don't apply death penalties during frenzies.
         return;
      }

      iXPLoss = 0;

      // Lose your revenant, satisfied if you took a real death.
      if piDeathCost >= Send(SETTINGS_OBJECT,@GetDefaultDeathCost)
      {
         // As an outlaw, justice was met by dying. But, not if it's a cheap death!
         Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
         Post(self,@EvaluatePKStatus);

         if (piFlags & PFLAG_HAUNTED)
         {
            if pbLogged_on
            {
               Send(self,@MsgSendUser,#message_rsc=player_haunted_off);
            }

            Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
         }
      }

      // Only do this stuff if the cost of death is not zero.
      if piDeathCost > 0
      {
         if NOT (piFlags & PFLAG_TUTORIAL)
            AND NOT (piFlags & PFLAG_MURDERER)
         {
            piDeathCost = piDeathCost / 3;
         }
         else
         {
            iXPLoss = Send(SYS,@GetXPDiffForLevel,#iLevel=piBase_max_health);
            // Lose piDeathCost// of 20// of current level XP.
            iXPLoss = Bound((iXPLoss * piDeathCost) / 500,0,MAX_XP_DEATH_LOSS);
            Send(self,@AddXP,#iAmount=-iXPLoss);

            // Under 100HP and killed by a player? Receive a temporary angel.
            if bTempSafe
               AND piBase_max_health <= 99
               AND NOT ((piFlags & PFLAG_MURDERER)
                  OR (piFlags & PFLAG_OUTLAW))
               AND (piPreferences & CF_TEMPSAFE)
               AND Send(self,@FindUsing,#class=&SoldierShield) = $
               AND ptTempSafe = $
            {
               Post(self,@StartTempSafe);
            }
         }
      }
      else
      {
         return;
      }

      if Send(self,@CheckLog)
      {
         if iXPLoss
         {
            Debug("LOG:  ",vrName," died, lost XP: ",
                  iXPLoss,Send(self,@GetBaseMaxHealth),
                  "Death Cost = ",piDeathCost);
         }
         else
         {
            Debug("LOG:  ",vrName," died, but made death cost check: ",
                  piDeathCost);
         }
      }

      // Remove from guild if now under min HP
      if piBase_max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
      {
         Send(self, @QuitGuild);
      }

      // Lose some skill or spell proficiency.

      // Murderers get hit harder.
      if (piFlags & PFLAG_MURDERER)
      {
         iAmount = -2;
      }
      else
      {
         iAmount = -1;
      }

      foreach i in plSpells
      {
         if Send(self,@DecodeSpellAbility,#compound=i) > 5
            AND Random(1,100) > Send(self,@GetStamina)
            AND Random(1,100) < piDeathCost
         {
            Send(self,@ChangeSpellAbility,#spell_num=Send(self,@DecodeSpellNum,
                  #compound=i),#amount=iAmount);
         }
      }

      foreach i in plSkills
      {
         if Send(self,@DecodeSkillAbility,#compound=i) > 5
            AND Random(1,100) > Send(self,@GetStamina)
            AND Random(1,100) < piDeathCost
         {
            Send(self,@ChangeSkillAbility,#skill_num=Send(self,@DecodeSpellNum,
                  #compound=i),#amount=iAmount);
         }
      }

      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);
      }

      Debug("Player ",Send(self,@GetTrueName),self," took death penalties of ",
            piDeathCost," percent.");

      piDeathCost = 0;

      return;
   }

   SetDeathCost(DeathCost = $, bOverride = FALSE)
   {
      // Don't raise the cost of death, unless we want to override it.
      if DeathCost < piDeathCost
         OR bOverride
      {
         piDeathCost = DeathCost;
      }

      return;
   }

   GetDeathCost()
   {
      return piDeathCost;
   }

   CreateCorpse(Assassinated=FALSE)
   {
      local oRoom;

      // Send current pant/shirt color to body only if they both use
      // the new two-color xlats. Otherwise, Send default colors.
      if pbLogged_on
      {
         oRoom = Send(self,@GetOwner);
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=Send(self,@GetSaveRoom));
      }

      if Send(SYS,@IsTwoColorXLAT,#xlat=Send(self,@GetBodyTranslation))
         AND Send(SYS,@IsTwoColorXLAT,#xlat=Send(self,@GetLegsTranslation))
      {
         if piGender = GENDER_MALE
         {
            // male, current colors
            return Create(&DeadBody,
                          #victim=self,
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #oRoom=oRoom);
         }
         else
         {
            // female, current colors
            return Create(&DeadBody,
                          #victim=self,
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #oRoom=oRoom);
         }
      }

      if piGender = GENDER_MALE
      {
         // male, default colors
         return Create(&DeadBody,
                       #victim=self,
                       #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                       #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                       #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                       #oRoom=oRoom);
      }
      // female, default colors
      return Create(&DeadBody,
                    #victim=self,
                    #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                    #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                    #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                    #oRoom=oRoom);
   }

   GetDeadName()
   {
      if piGender = GENDER_MALE
      {
         return player_dead_male_name_rsc;
      }

      return player_dead_female_name_rsc;
   }

   GetDeadIcon()
   {
      if piGender = GENDER_MALE
      {
         return player_dead_male_icona_rsc;
      }

      return player_dead_female_icona_rsc;
   }

   FreeHands()
   "Attempts to remove all items from hands if possible."
   {
      local i;

      foreach i in plUsing
      {
         if (Send(i,@GetItemUseType) & ITEM_USE_HAND)
            AND Send(i,@ReqUnuse)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   DoDance()
   {
      local i, iSpace;

      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_dance);

            return FALSE;
         }
      }

      if (piBattlerFlags & BFLAG_RESTING)
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_dance_resting);

         return FALSE;
      }
      
      Send(self,@MsgSendUser,#message_rsc=player_dance);

      piAnimation = PANM_DANCE;
      Send(poOwner,@SomethingChanged,#what=self);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=TRUE,#flagset=2);
      piAnimation = PANM_NONE;

      return;
   }

   StopDancing()
   {
      Send(self,@MsgSendUser,#message_rsc=player_stop_dance);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=FALSE,#flagset=2);
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   DoWave()
   "Causes the user do the wave animation, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_wave);

      piAnimation = PANM_WAVE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoFistAttack()
   "Causes the user do the fight animation w/fist, 1st and 3rd person"
   {
      Send(self,@DoWindowOverlayFistAttack);

      piAnimation = PANM_FIST_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoPoint()
   "Causes the user to point, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_point);

      piAnimation = PANM_POINT;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoCast()
   "Causes the user to do spell casting arm, 1st & 3rd person"
   {
      Send(self,@DoWindowOverlayHandGlow);

      piAnimation = PANM_CAST;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoBowFire()
   {
      piAnimation = PANM_BOW_FIRE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoWindowOverlayFistAttack()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_OVERLAY, 1,HS_SE, 4,PWO_RIGHT_HAND,
                   4,player_window_overlay_hand, 4,0, 4,0, 1,0, 4,0, 4,0,
                   1,0, 1,0, 1,ANIMATE_ONCE, 4,175, 2,1, 2,3, 2,0, 1,0);

         SendPacket(poSession);
      }

      return;
   }

   DoWindowOverlayHandGlow()
   {
      local i,iGroup;

      if pbLogged_on
      {
         iGroup = 0;
         foreach i in plWindow_overlays
         {
            if Send(i,@GetWindowOverlayID) = PWO_RIGHT_HAND
            {
               // Of right hand overlay already exists, we can't
               // restore it correctly yet, so just don't change it
               return;
            }
         }

         AddPacket(1,BP_PLAYER_OVERLAY, 1,HS_SE, 4,PWO_RIGHT_HAND,
                   4,player_window_overlay_hand, 4,0, 4,0, 1,0, 4,0, 4,0,
                   1,0, 1,0, 1,ANIMATE_ONCE,4,300,2,4,2,6,2,iGroup, 1,1);
         AddPacket(4,player_window_overlay_glow, 1,HS_RIGHT_HAND,
                   1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,0);

         SendPacket(poSession);
      }

      return;
   }

   SetWindowOverlay(what = $)
   "Sends a message to the client about a window overlay, and adds <what> "
   "to plWindow_overlays."
   {
      Send(self,@AddWindowOverlayObject,#what=what);
      Send(self,@ChangeWindowOverlay,#what=what);

      return;
   }

   ChangeWindowOverlay(what = $)
   "Things can call this when they have a current window overlay and want "
   "to change it, such as for an attack.  Verifies the item is in overlays."
   {
      if pbLogged_on
         AND FindListElem(plWindow_overlays, what)
      {
         AddPacket(1,BP_PLAYER_OVERLAY, 1,Send(what,@GetWindowOverlayHotspot),
                   4,Send(what,@GetWindowOverlayID), // supposedly "object id" in client
                   4,Send(what,@GetWindowOverlay),
                   4,Send(what,@GetName), // useless field, used to make client parsing easier
         // Flags, drawing flags, minimapflags, namecolor, playertype, moveon type.
                   4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         Send(what,@SendWindowOverlayAnimation);
         Send(what,@SendWindowOverlayOverlays);

         SendPacket(poSession);
      }

      return;
   }

   AddWindowOverlayObject(what = $)
   "Adds <what> to plWindow_overlays, in case the user leaves and relogs on"
   {
      local i;

      foreach i in plWindow_overlays
      {
         if i = what
         {
            return;
         }
      }

      plWindow_overlays = Cons(what,plWindow_overlays);

      return;
   }

   RemoveWindowOverlay(what = $)
   "Removes <what> from plWindow_overlays if it's in there, "
   "after updating client."
   {
      Send(self,@ChangeWindowOverlay,#what=what);
      Send(self,@RemoveWindowOverlayObject,#what=what);

      return;
   }

   RemoveWindowOverlayObject(what = $)
   "Removes <what> from plWindow_overlays if it's in there."
   {
      local i;

      foreach i in plWindow_overlays
      {
         if i = what
         {
            plWindow_overlays = DelListElem(plWindow_overlays,what);
            return;
         }
      }

      return;
   }

   VerifyOverlays()
   "Removes overlays of any overlaid item whose owner is not the player."
   {
      local i;

      foreach i in plOverlays
      {
         if Send(i,@GetOwner) <> self
         {
            Send(self,@RemoveOverlay,#what=i);
         }
      }

      return;
   }

   SetOverlay(what = $)
   "Adds <what> to plOverlays, and tells everyone we changed."
   {
      Send(self,@AddOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveOverlay(what = $)
   "Removes <what> from plOverlays if it's in there, and "
   "tells everyone we changed."
   {
      Send(self,@RemoveOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   AddOverlayObject(what = $)
   "Adds <what> to plOverlays, so we can keep track of whom to "
   "call about overlays"
   {
      local i;

      foreach i in plOverlays
      {
         if i = what
         {
            return;
         }
      }

      plOverlays = Cons(what,plOverlays);

      return;
   }

   RemoveOverlayObject(what = $)
   "Removes <what> from plOverlays if it's in there."
   {
      local i;

      foreach i in plOverlays
      {
         if i = what
         {
            plOverlays = DelListElem(plOverlays,what);

            return;
         }
      }

      return;
   }

   GetRemoveHair()
   {
      return poHair_remove;
   }

   RemoveHair(what = $)
   {
      if what = $
      {
         return;
      }

      poHair_remove = what;
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   ResetHair()
   {
      poHair_remove = $;

      if poOwner
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx | drawfx;
      if poOwner <> $ AND SendSomethingChanged
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx & drawfx;

      if poOwner <> $ AND SendSomethingChanged
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIcon(what = $,new_icon = $,translation = $, alldone = TRUE)
   "Sets our icon to <new_icon>, and keeps track of <what> to undo "
   "when necessary. Tells everyone we changed."
   {
      poIcon_set = what;
      vrIcon = new_icon;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations |
                  (translation * PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   GetPlayerIcon()
   {
      return vrIcon;
   }

   ResetPlayerIcon(alldone=TRUE)
   "Sets our icon to its natural, unarmored state."
   {
      local i;

      poIcon_set = $;

      // A player may be wearing something under his armor.
      foreach i in plUsing
      {
         // Shirt or armor.
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            Send(i,@SetIcon);

            return;
         }
      }

      if piGender = GENDER_MALE
      {
         vrIcon = player_male_icon_rsc;
      }
      else
      {
         vrIcon = player_female_icon_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations |
            (Send(self,@GetDefaultShirtTranslation)*PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerArms(what=$,new_left_arm=$,new_right_arm=$,translation=$,alldone=TRUE)
   "Sets our legs to <new_legs>, and keeps track of <what> to undo "
   "when necessary. Tells everyone we changed."
   {
      poArms_set = what;
      prleft_Arm = new_left_arm;
      prRight_Arm = new_right_arm;

      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 |
            (translation * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerArms(alldone = TRUE)
   "Sets our icon to its natural, default-shirted state."
   {
      local iShirt_xlat, i, bFound;
      poArms_set = $;

      bFound = FALSE;
      foreach i in plUsing
      {
         if Send(i,@OverrideArms)
         {
            // Gauntlets, probably.
            prRight_arm = Send(i,@GetOverrideRightArm,#who=self);
            prleft_arm = Send(i,@GetOverrideleftArm,#who=self);
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         if piGender = GENDER_MALE
         {
            prRight_arm = player_Rightarm_a_rsc;
            prLeft_arm = player_leftarm_a_rsc;
         }
         else
         {
            prRight_arm = player_Rightarm_b_rsc;
            prLeft_arm = player_leftarm_b_rsc;
         }
      }

      iShirt_xlat = Send(self,@GetDefaultShirtTranslation);
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 |
            (iShirt_xlat * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerLegs(what = $,new_legs = $,translation = $)
   "Sets our legs to <new_legs>, and keeps track of <what> to "
   "undo when necessary. Tells everyone we changed."
   {
      poLegs_set = what;
      prLegs = new_legs;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations |
               (translation * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerLegs()
   "Sets our icon to its natural, un-panted state."
   {
      poLegs_set = $;

      if piGender = GENDER_MALE
      {
         prLegs = player_legs_a_rsc;
      }
      else
      {
         prLegs = player_legs_b_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations |
            (Send(self,@GetDefaultPantsTranslation) * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetDefaultClothes(pants_color=-1,shirt_color=-1,rand=FALSE,increment=TRUE)
   {
      local shirt_color_xlat, pants_color_xlat, skin_color, i,
            bShirt, bLegs, bArms;

      skin_color = Send(self,@GetSkinColor);
      skin_color = Send(self,@ConvertSkinColorToXLAT,#skin_color=skin_color);

      if rand
      {
         pants_color = Random(XLAT_TO_SKIN1, XLAT_TO_SKIN4);
         shirt_color = Random(XLAT_TO_ORANGE, XLAT_HIGH_VALUE);
         if shirt_color = XLAT_TO_SKIN4
         {
            shirt_color = XLAT_TO_RED;
         }

         shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                 #color1=shirt_color,#color2=skin_color);
         pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                 #color1=pants_color,#color2=skin_color);
      }

      else
      {
         if shirt_color = -1
         {
            shirt_color_xlat = Send(self,@GetDefaultShirtTranslation);
         }
         else
         {
            shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                    #color1=shirt_color,#color2=skin_color);
         }

         if pants_color = -1
         {
            pants_color_xlat = Send(self,@GetDefaultPantsTranslation);
         }
         else
         {
            pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                    #color1=pants_color,#color2=skin_color);
         }
      }

      piDefault_clothes = (shirt_color_xlat*SHIRT_MUL) | (pants_color_xlat*PANTS_MUL);

      bShirt = FALSE;
      bLegs = FALSE;
      bArms = FALSE;

      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
         {
            bArms = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            // ITEM_USE_BODY is armor
            bShirt = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_LEGS
         {
            bLegs = TRUE;
         }
      }

      if NOT bArms
      {
         Send(self,@ResetPlayerArms);
      }

      if NOT bShirt
      {
         Send(self,@ResetPlayerIcon);
      }

      if NOT bLegs
      {
         Send(self,@ResetPlayerLegs);
      }

      Send(self,@RefreshPlayerVisualGear);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RefreshPlayerVisualGear()
   {
      local n, lRefreshItemTypes, i, iHighestLayer, oHighestGear,
            iLowestLayer, oLowestGear, oSoldierShield, bSoldierShieldSlung;

      lRefreshItemTypes = [ITEM_USE_SHIRT,ITEM_USE_BODY,ITEM_USE_LEGS];

      foreach n in lRefreshItemTypes
      {
         iHighestLayer = 0;
         oHighestGear = $;
         foreach i in plUsing
         {
            if IsClass(i,&DefenseModifier)
               AND Send(i,@GetItemUseType) & n
            {
               if Send(i,@GetLayer) >= iHighestLayer
               {
                  iHighestLayer = Send(i,@GetLayer);
                  oHighestGear = i;
               }
            }
         }

         if oHighestGear <> $
         {
            Send(oHighestGear,@DoPlayerArt);
         }
      }

      // Check for headgear, which has special overlays
      // In this case, we actually refresh the lowest layer to put it underneath
      iLowestLayer = 100000;
      oLowestGear = $;
      foreach i in plUsing
      {
         if IsClass(i,&DefenseModifier)
            AND Send(i,@GetItemUseType) & ITEM_USE_HEAD
         {
            if Send(i,@GetLayer) <= iLowestLayer
            {
               iLowestLayer = Send(i,@GetLayer);
               oLowestGear = i;
            }
         }

         if oLowestGear <> $
         {
            Send(oLowestGear,@UndoPlayerArt);
            Send(oLowestGear,@DoPlayerArt);
         }
      }

      // Check for Soldier Shield sling
      bSoldierShieldSlung = FALSE;
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
      {
         foreach i in plUsing
         {
            if (IsClass(i,&Shield)
               AND NOT IsClass(i,&SoldierShield))
               OR IsClass(i,&Bow)
               OR IsClass(i,&Lute)
            {
               Send(oSoldierShield,@SlingOnBack,#report=FALSE);
               bSoldierShieldSlung = TRUE;

               // Now restore the first-person view of other shield
               // if we're using one
               foreach n in plUsing
               {
                  if (IsClass(n,&Shield)
                     AND NOT IsClass(n,&SoldierShield)
                     AND NOT IsClass(n,&Torch))
                  {
                     Send(self,@SetWindowOverlay,#what=n);
                  }
               }
            }
         }

         if bSoldierShieldSlung = FALSE
         {
            Send(oSoldierShield,@RemoveFromBack,#report=FALSE);
         }
      }

      return;
   }

   ConvertskincolortoXLAT(Skin_color = 0)
   {
      // Since the face translates use a single translate and the body uses
      // a double translate which has less color values available,
      // here we map the face translate to a similar body translate.
      if skin_color = PT_BLUE_TO_SKIN1
         OR skin_color = PT_BLUE_TO_SKIN2
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_SKIN3
      {
         return XLAT_TO_SKIN2;
      }

      if skin_color = PT_BLUE_TO_SKIN4
      {
         return XLAT_TO_SKIN4;
      }

      if skin_color = PT_BLUE_TO_GREEN
         OR skin_color = PT_BLUE_TO_YELLOW
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_GRAY
         OR skin_color = PT_BLUE_TO_ASHEN
      {
         return XLAT_TO_GRAY;
      }

      if skin_color = PT_BLEND25YELLOW
         OR skin_color = PT_BLUE_TO_LBLUE
      {
         return XLAT_TO_SKY;
      }

      if skin_color = PT_BLEND25RED
      {
         return XLAT_TO_BLUE;
      }

      if Send(SYS,@IsTwoColorXLAT,#Xlat=skin_color)
      {
         return Send(SYS,@DecodeSecondaryColor,#Xlat=skin_color);
      }

      return XLAT_TO_SKIN1;
   }

   SetSkinTranslation(translation = $)
   {
      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_Skin_MASK;
      piBody_translations = piBody_translations | (translation * PLAYER_TRANSLATION_SKIN_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetHairTranslation(translation = $)
   {
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_HAIR_MASK;
      piBody_translations2 = piBody_translations2 | (translation * PLAYER_TRANSLATION2_HAIR_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIllusion(what = $)
   "Stores <what> as the object to call back to get our animation and overlays."
   "Tells everyone we changed."
   {
      poIllusion_set = what;

      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   GetIllusionForm(what = $)
   "Returns what is setting our illusion, if anything is."
   {
      if poIllusion_set = $
      {
         return $;
      }

      return Send(poIllusion_set,@IllusionGetTemplate,#who=self);
   }

   GetIllusionSet()
   {
      return poIllusion_set;
   }

   ResetPlayerIllusion()
   "Restores default lighting and DrawFX."
   {
      poIllusion_set = $;

      // Recalculate the flicker flag.
      Send(self,@RecalcFlickerFlag);

      // Reset our drawFX. Also does the SomethingChanged bit if appropriate.
      Send(self,@ResetPlayerDrawFX);

      return;
   }

   DoAttackSwing()
   {
      piAnimation = PANM_WEAPON_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   GetIcon(trueicon=FALSE)
   {
      // trueicon is set to true anytime you want to know what
      // a person really looks like.  Good example: statues.

      if poIllusion_set <> $ AND NOT trueicon
      {
         return Send(poIllusion_set,@IllusionGetIcon,#who=self);
      }

      propagate;
   }

   SendAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendAnimation,#who=self,
               #animation=iAnimation);

         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,2, 2,4, 2,1);

         return;
      }

      if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,3, 2,4, 2,1);

         return;
      }

      if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,5, 2,5, 2,1);

         return;
      }

      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE,4, 150, 2,6, 2,22);

         return;
      }

      propagate;
   }

   SendMoveAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveAnimation,#who=self);

         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_DANCE
      {    
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,6, 2,22);

         return;
      }

      // use standing torso
      AddPacket(1, ANIMATE_NONE, 2,1);

      return;
   }

   SendMoveOverlays(iAnimation = $)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveOverlays,#who=self);

         return;
      }

      // Player has 7 standard overlays:
      // right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;

      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      // Which group of arm images do we use?
      iLeft_group = 1;
      iRight_group = 1;

      foreach i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            // Bend the arm if we have a shield, a bow, or a token.
            if hotspot = HS_LEFT_WEAPON 
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1,iOverlays, 4,prLeft_arm, 1,HS_LEFT_HAND);
      iArms_xlat = Send(self,@GetArmsTranslation);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iLeft_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
         }
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iLeft_group); 
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iRight_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
         }
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }
      
      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }
      else
      {
         AddPacket(1,ANIMATE_CYCLE, 4,100, 2,2, 2,5);
      }

      iSkin_xlat = Send(self,@GetSkinColor);

      // Don't send information about face elements if we're wearing the
      //  shrunken head mask.  See shrnkmsk.kod for details.
//      if prHead <> ShrunkenHeadMask_icon_male_rsc
//         AND prHead <> ShrunkenHeadMask_icon_female_rsc
//      {
      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1,
                4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,piAction);
      AddPacket(4,prEyes,1, HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,piAction,
                4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);
//      }

      if poHair_remove = $
      {  
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1); 
      }

      foreach i in plOverlays
      {
         // Moved all of this to the item kod, since items may now
         //  have more than one overlay.
         Send(i,@SendOverlayInformation,#iAnimation = $);
      }

      return;
   }

   SendOverlays(iAnimation=$)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $ and iAnimation <> $
      {
         Send(poIllusion_set,@IllusionSendOverlays,#who=self,
              #animation=iAnimation);

         return;
      }


      // Send overlay bitmap info to user.

      // Player has 7 standard overlays:
      //  right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;

      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      // Overlay info -- display correct group for animation & action

      iLeft_group = 1;
      iRight_group = 1;
      foreach i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays,#iAnimation=iAnimation);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            if hotspot = HS_LEFT_WEAPON
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1, iOverlays, 4,prLeft_arm, 1,HS_LEFT_HAND);

      iArms_xlat = Send(self,@GetArmsTranslation);
      if iArms_Xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,8, 2,8, 2,iLeft_group);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,5, 2,6, 2,iLeft_group);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,9, 2,9, 2,iLeft_group);
      }
      else if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,iLeft_group);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE,2,iLeft_group);
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iAnimation = PANM_NONE
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }
      else if iAnimation = PANM_WAVE
      {
         AddPacket(1,ANIMATE_ONCE, 4,100, 2,7, 2,10, 2,iRight_group);
      }
      else if iAnimation = PANM_POINT
      {
         AddPacket(1,ANIMATE_ONCE, 4,700, 2,12, 2,12, 2,iRight_group);
      }
      else if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,11, 2,11, 2,iRight_group);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,13, 2,14, 2,iRight_group);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,15, 2,16, 2,iRight_group);
      }
      else if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,17);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,900, 2,6, 2,6, 2,1);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,6, 2,6, 2,1);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,7, 2,7, 2,1);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,1);
      }

      iSkin_xlat = Send(self,@GetSkinColor);

      // Don't send information about face elements if we're wearing the
      //  shrunken head mask.  See shrnkmsk.kod for details.
//      if prHead <> ShrunkenHeadMask_icon_male_rsc
//         AND prHead <> ShrunkenHeadMask_icon_female_rsc
//      {
      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1,
                4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,piAction);
      AddPacket(4,prEyes, 1,HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,piAction,
                4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);
//      }

      if poHair_remove = $
      {
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1);
      }

      foreach i in plOverlays
      {
         Send(i,@SendOverlayInformation,#iAnimation=iAnimation);
      }

      return;
   }

   MsgPlayerHitResisted(what=$,resistance=$,target=$,color_rsc=player_hit_color_none)
   "Send a message to the player if the person hit has a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5)
      {
         if resistance > (3*MAX_RESISTANCE/5)
         {
            rMessage = player_hit_immunity;
         }
         else
         {
            rMessage = player_hit_resisted;
         }
      }

      if resistance <= (MIN_RESISTANCE/5)
      {
         if resistance <= (3*MIN_RESISTANCE/5)
         {
            rMessage = player_hit_anti_immunity;
         }
         else
         {
            rMessage = player_hit_anti_resisted;
         }
      }

      if rMessage <> $
      {
         Send(what,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc,
               #parm2=Send(target,@GetCapDef),#parm3=Send(target,@GetName));
      }

      return;
   }

   MsgPlayerResistsHit(what=$,resistance=$,color_rsc=player_hit_color_none)
   "Send a message to the player if they have a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5) 
      {
         if resistance > (2*MAX_RESISTANCE/3)
         {
            rMessage = player_immune_to_hit;
         }
         else
         {
            rMessage = player_resists_hit;
         }
      }

      if resistance < (MIN_RESISTANCE/5)
      {
         if resistance < (2*MIN_RESISTANCE/3)
         {
            rMessage = player_anti_immune_to_hit;
         }
         else
         {
            rMessage = player_anti_resists_hit;
         }
      }

      if rMessage <> $
      {
         Send(self,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc);
      }

      return;
   }

   PlayerWasHit(atype = 0, stype = 0)
   "Select a message to Send the player when they are hit."
   {
      if stype > 0 // do spell attacks first, so flaming swords use the special
      {
         if (stype & SPL_TYPE_FIRE) > 0 { return player_was_burned;}
         if (stype & SPL_TYPE_SHOCK) > 0 { return player_was_shocked;}
         if (stype & SPL_TYPE_COLD) > 0 { return player_was_frozen;}
         if (stype & SPL_TYPE_HOLY) > 0 { return player_was_holyhit;}
         if (stype & SPL_TYPE_UNHOLY) > 0 { return player_was_unholyhit;}
         if (stype & SPL_TYPE_QUAKE) > 0 { return player_was_quaked;}
      }

      if atype > 0   // do weapon attacks (odd ones first).
      {
         if (atype & ATK_TYPE_BITE) > 0 { return player_was_bitten;}
         if (atype & ATK_TYPE_CLAW) > 0 { return player_was_clawed;}
         if (atype & ATK_TYPE_STING) > 0 { return player_was_stung;}
         if (atype & ATK_TYPE_SLASH) > 0 { return player_was_slashed;}
         if (atype & ATK_TYPE_BLUDGEON) > 0 { return player_was_bludgeoned;}
         if (atype & ATK_TYPE_PIERCE) > 0 { return player_was_pierced;}
         if (atype & ATK_TYPE_THRUST) > 0 { return player_was_thrusted;}
         if (atype & ATK_TYPE_COLD) > 0 { return player_was_frozen;}

         // Put non-weapon strokes here.
         if (atype & ATK_TYPE_PUNCH) > 0 {return player_was_punched;}
         if (atype & ATK_TYPE_KICK) > 0 {return player_was_kicked;}
      }

      return player_was_hit;
   }

   AddMight(points = 0, bAbsolute = TRUE)
   "Returns signed change to might (negative means decrease)"
   "If bAbsolute = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMight;

      iOrigMight = piMightMod;
      piMightMod = piMightMod + points;

      if NOT bAbsolute
      {
         piMightMod = Bound(piMightMod,-piMight,(MAXIMUM_STAT-piMight));
      }

      if (pbLogged_on)
      {
         Send(self,@DrawMight);
         Post(self,@DrawCapacity);
      }

      return piMightMod - iOrigMight;
   }

   AddIntellect(points = 0, bAbsolute = TRUE)
   "Returns signed change to intellect (negative means decrease)"
   "If bAbsolute = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigIntellect;

      iOrigIntellect = piIntellectMod;
      piIntellectMod = piIntellectMod + points;

      if NOT bAbsolute
      {
         piIntellectMod = Bound(piIntellectMod,-piIntellect,(MAXIMUM_STAT-piIntellect));
      }

      Send(self,@DrawIntellect);

      return piIntellectMod - iOrigIntellect;
   }

   AddAim(points = 0, bAbsolute = TRUE)
   "Returns signed change to aim (negative means decrease)"
   "If bAbsolute = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAim;

      iOrigAim = piAimMod;
      piAimMod = piAimMod + points;

      if NOT bAbsolute
      {
         piAimMod = Bound(piAimMod,-piAim,(MAXIMUM_STAT-piAim));
      }

      if (pbLogged_on)
      {
         Send(self,@DrawAim);
         Post(self,@DrawOffense);
      }

      return piAimMod - iOrigAim;
   }

   AddStamina(points = 0, bAbsolute = TRUE)
   "Returns signed change to stamina (negative means decrease)"
   "If bAbsolute = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigStamina, iMaxHP, iNewMaxHP;

      iMaxHP = Send(self,@GetBaseMaxHealth);

      iOrigStamina = piStaminaMod;
      piStaminaMod = piStaminaMod + points;

      if NOT bAbsolute
      {
         piStaminaMod = Bound(piStaminaMod,-piStamina,(MAXIMUM_STAT-piStamina));
      }

      iNewMaxHP = Send(self,@GetBaseMaxHealth);

      // Set their max health to the correct level.
      if (iMaxHP <> iNewMaxHP)
      {
         Send(self,@GainMaxHealth,#amount=iNewMaxHP - iMaxHP);
         Send(self,@NewHealth);
      }

      Send(self,@DrawStamina);

      return piStaminaMod - iOrigStamina;
   }

   AddAgility(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If bAbsolute = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAgility;

      iOrigAgility = piAgilityMod;
      piAgilityMod = piAgilityMod + points;

      if NOT bAbsolute
      {
         piAgilityMod = Bound(piAgilityMod,-piAgility,(MAXIMUM_STAT-piAgility));
      }

      if (pbLogged_on)
      {
         Send(self,@DrawAgility);
         Post(self,@DrawDefense);
      }

      return piAgilityMod - iOrigAgility;
   }

   AddMysticism(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMysticism;

      iOrigMysticism = piMysticismMod;
      piMysticismMod = piMysticismMod + points;

      if NOT bAbsolute
      {
         piMysticismMod = Bound(piMysticismMod,-piMysticism,(MAXIMUM_STAT-piMysticism));
      }

      Send(self,@DrawMysticism);
      Send(self,@ComputeMaxMana);

      return piMysticismMod - iOrigMysticism;
   }

   StartResting()
   {
      Send(self,@BreakTrance,#event=EVENT_REST);
      piBattlerFlags |= BFLAG_RESTING;
      Send(self,@ResetPlayerFlagList);
      Send(self,@NewVigor);

      // If we have a follower, make them take a break, too.
      if (poMercenary <> $)
         AND NOT IsTimer(poMercenary)
         AND IsClass(poMercenary,&Follower)
         AND (Send(poMercenary,@GetOwner) = poOwner)
      {
         Send(poMercenary,@StartResting);
      }

      return;
   }

   StopResting()
   {
      piBattlerFlags &= ~BFLAG_RESTING;
      Send(self,@ResetPlayerFlagList);
      Send(self,@NewVigor);

      // Followers gotta follow.
      if (poMercenary <> $)
         AND NOT IsTimer(poMercenary)
         AND IsClass(poMercenary,&Follower)
         AND (Send(poMercenary,@GetOwner) = poOwner)
      {
         Send(poMercenary,@StopResting);
      }

      return;
   }

   IsCursedByItems()
   "Returns TRUE if player is using an item that's cursed, FALSE otherwise."
   {
      local i;

      foreach i in plUsing
      {
         if Send(i,@IsCursed)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   RemoveCurseAllItems()
   "Returns TRUE if the player has a cursed item stripped away, FALSE if not."
   {
      local i, bFound;

      bFound = FALSE;
      foreach i in plUsing
      {
         if Send(i,@IsCursed)
         {
            Send(self,@UnuseItem,#what=i);
            bFound = TRUE;
         }
      }

      return bFound;
   }

   GetArmor()
   "If plUsing holds any armor, return that object."
   {
      return GetListElemByClass(plUsing,&Armor);
   }

   IsDead()
   {
      return (piHealth <= 0);
   }

   SetTranceFlag()
   {
      piFlags |= PFLAG_TRANCE;

      return;
   }

   ClearTranceFlag()
   {
      piFlags &= ~PFLAG_TRANCE;

      return;
   }

   BreakTrance(event = 0, what = $, disruption = 0)
   {
      local i, oEnch,state, bFound, oYellNum, oYellRoom;

      bFound = FALSE;
      foreach i in plEnchantments
      {
         oEnch = Nth(i,2);
         if IsClass(oEnch,&Spell) OR IsClass(oEnch,&Trance)
         {
            state = $;
            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               state = Nth(i,3);
            }

            Send(oEnch,@BreakTrance,#who=self,#state=state,
                  #event=event,#what=what,#disruption=disruption);
            bFound = TRUE;
         }
      }

      foreach i in plRadiusEnchantments
      {
         oEnch = Nth(i,2);
         state = Nth(i,3);
         if (First(state) = self) // Nth(state,RE_STATE_CASTER)
         {
            Send(oEnch,@BreakTrance,#who=self,#state=state,#event=event);
         }
      }

      if event = EVENT_NEWOWNER
      {
         foreach oYellNum in Send(poOwner,@GetYellZone)
         {
            oYellRoom = Send(SYS,@FindRoomByNum,#num=oYellNum);
            if Send(oYellRoom,@BreakTrance,#who=self)
            {
               bFound = TRUE;

               break;
            }
         }
      }

      if Send(poOwner,@BreakTrance,#who=self,#event=event)
      {
         bFound = TRUE;
      }

      return bFound;
   }

   RecalcBulkAndWeight()
   {
      return;
   }

   RecalcLight()
   {
      local i, iLight, iState;

      // TODO: Make this into a general check.

      // Default base value
      iLight = 5;

      foreach i in plUsing
      {
         // Torch, Amulet
         if IsClass(i,&Torch)
            OR IsClass(i,&ShadowAmulet)
            OR IsClass(i,&DaemonHelm)
         {
            iLight += Send(i,@GetLightEffect);
         }
         // Glowing weapons?
         else if ((IsClass(i,&Weapon) OR IsClass(i,&Lute))
            AND Send(i,@HasAttribute,#ItemAtt=WA_GLOWING))
         {
            iState = Send(i,@GetAttributeData,#ItemAtt=WA_GLOWING);
            if (iState <> $)
            {
               iLight += Nth(iState,3);
            }
         }
      }

      iState = Send(self,@GetEnchantedState,
                    #what=Send(SYS,@FindSpellByNum,#num=SID_NIGHTVISION));
      if iState <> $
      {
         iLight += iState;
      }

      // Touch attacks can add or remove light.
      foreach i in Send(self,@GetEnchantmentsByClass,#EnchClass=&TouchAttackSpell)
      {
         iLight += Send(Nth(i,2),@GetEnchantmentLight);
      }

      if piLight <> iLight
      {
         Debug("Player ",Send(self,@GetName)," had wrong light value ",piLight,
               ".  Setting it to ",iLight);
         piLight = iLight;
         Send(self,@NewLight);
      }

      return;
   }

   GetLightLevel()
   "Calls RecalcLight and returns the light level."
   {
      Send(self,@RecalcLight);

      // This should be accurate after calling RecalcLight.
      return piLight;
   }

   UnuseAllItems()
   {
      local i;

      foreach i in plUsing
      {
         Send(self,@UnuseItem,#what=i,#Recalibrate=TRUE);
      }

      if plUsing <> $
      {
         plUsing = $;
      }

      return Send(SYS,@GetSuccessRsc);
   }

   RecalibratePlayer()
   {
      local i, bSoldier;

      bSoldier = FALSE;
      if Send(self,@FindUsing,#class=&SoldierShield) <> $
      {
         bSoldier = TRUE;
      }

      Send(self,@UnuseAllItems);
      Send(self,@RemoveAllEnchantments);
      Send(self,@DeleteAllOverTimeEffects);
      Send(self,@RecalcBulkAndWeight);
      Send(self,@ResetPlayerFlagList);
      Send(self,@SetVigorRestThreshold,#amount=80);
      Send(self,@EndCrystalizeManaSurge);

      // All attack modifiers should be a room enchantment, a personal
      // enchantment or something they are wearing. If one still exists,
      // bug.  This is also true for defense modifiers and resistances.
      if plAttack_modifiers <> $
      {
         foreach i in plAttack_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had attmod",Send(i,@GetName));
         }

         plAttack_modifiers = $;
      }

      if plDefense_modifiers <> $
      {
         foreach i in plDefense_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had defmods",Send(i,@GetName));
         }
         
         plDefense_modifiers = $;
      }

      if plResistances <> $
      {
         foreach i in plResistances
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had resistance",first(i),Nth(i,2));
         }

         plResistances = $;
      }

      piStomach = 50;
      piTimeLastStomachUpdate = GetTime();
      piKill_count_decay = Bound(piKill_count_decay,0,$);

      if plEnchantments <> $
      {
         foreach i in plEnchantments
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had enchantments",Send(Nth(i,2),@GetName));
         }

         plEnchantments = $;
      }

      if piLight <> 5
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "had bad light value",piLight,"after being stripped!");
         piLight = 5;
      }

      if piMax_health <> piBase_max_health
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "with max health",piMax_health,"did not match Base Max Health",
               piBase_max_health);
         piMax_health = Send(self,@GetBaseMaxHealth);
      }

      Send(self,@ComputeMaxMana);

      if piDrawfx <> 0
      {
         Debug("Recalibrating: Player",Send(self,@GetTrueName),
               "with piDrawFX was equal to",piDrawFX,"instead of 0.");
         piDrawFX = 0;
      }

      if poIllusion_set <> $
      {
         Debug("recalibrating: Player",Send(self,@GetTrueName),
               "with illusion_set not set to $!");
         poIllusion_set = $;
      }

      if poGuild <> $ AND NOT Send(poGuild,@IsMember,#who=self)
      {
         Debug("Player",Send(self,@GetTrueName),"points to guild",
               Send(poGuild,@GetName)," but guild doesn't point to player!");
      }
      
      // Reset our modifiers
      Send(self,@ZeroMods);

      if bSoldier
      {
         foreach i in plPassive
         {
            if IsClass(i,&SoldierShield)
            {
               Send(self,@TryUseItem,#what=i);
            }
         }
      }

      // Reset death costs to 0.
      piDeathCost = 0;

      // Set our second wind ability.
      piWind = Send(self,@GetSkillAbility,#skill_num=SKID_SECOND_WIND);

      // Set our resources to max.
      piHealth = 100* piMax_health;
      piMana = 100* piMax_mana;
      piVigor = 100* piMax_vigor;

      // Reset our active summons.
      piActiveSummons = 0;

      Send(self,@UpdateRates);
      Send(self,@PeriodicSounds,#bSuspend=TRUE);

      Send(self,@RemoveAttackingEvilTwin);

      return Send(SYS,@GetSuccessRsc);
   }

   GetBulkMax()
   {
      return viBulk_hold_max + (Send(self,@GetMight) * 20);
   }

   GetWeightMax()
   {
      return viWeight_hold_max + (Send(self,@GetMight) * 20);
   }

   CountKnownAtLevel(school=$,level=$)
   {
      local i, count, nSID, nObj;

      count = 0;
      foreach i in plSkills
      {
         nSID = Send(self,@DecodeSkillNum,#compound=i);
         nObj = Send(SYS,@FindSkillByNum,#num=nSID);

         if nObj = $
         {
            continue;
         }

         // Is this in the same school?
         if (Send(nObj,@GetSchool) = school)
            AND ((level = $)
               OR (Send(nObj,@GetLevel) = level))
         {
            count = count + 1;
         }
      }
      foreach i in plSpells
      {
         nSID = Send(self,@DecodeSpellNum,#compound=i);
         nObj = Send(SYS,@FindSpellByNum,#num=nSID);

         if nObj = $
         {
            continue;
         }

         if IsClass(nObj,&UtilitySpell)
            OR IsClass(nObj,&Blink)
         {
            continue;
         }

         // Is this in the same school?
         if (Send(nObj,@GetSchool) = school)
            AND ((level = $)
               OR (Send(nObj,@GetLevel) = level))
         {
            count = count + 1;
         }
      }

      return count;
   }

   PlayerCanLearn(spell_num=0,skill_num=0,scryer=$)
   "New routine as of 14 June 97. Intended to allow for more schools, "
   "odd numbers of spells at a spell level and easier understanding."
   "The proverbial trick is that players have to know WHY they aren't "
   "learning. For example, if a player can't learn because he has too "
   "many competing schools, he needs to know that."
   {
      local obj, level, school, division, iHave, prev_level, iSamediv,
            iOtherdiv, aHigh, bHigh, cHigh, iBase, i, temp, nObj, nSID,
            index, iNeed, nSchool, nLevel, msg, bKnowOne, iWeapon, iKraanan,
            iShalille, iQor, iFaren, iRiija, iJala, iPoints;

      // Phase one. Assert our data. Be sure we have been fed a valid spell
      // and skill num for a spell item that actually exists.
      if spell_num = 0
      {
         if skill_num = 0
         {
            Debug("No data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }
         else
         {
            obj = Send(SYS,@FindSkillByNum,#num=skill_num);
         }
      }
      else
      {
         if skill_num <> 0
         {
            Debug("Too much data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }
         else
         {
            obj = Send(SYS,@FindSpellByNum,#num=spell_num);
         }
      }
      if obj = $
      {
         Debug("Fed a spell number for a spell that does not exist in the "
               "system.");

         return PLAYER_LEARN_ERROR;
      }

      if NOT Send(obj,@IsAccessible)
      {
         // Sacred Haven server.
         return PLAYER_LEARN_ERROR;
      }

      if IsClass(obj,&Spell) AND NOT Send(obj,@IsEnabled)
      {
         // Spell is temporarily disabled.
         return PLAYER_LEARN_ERROR;
      }

      // Phase two:  get the hard data.
      level = Send(obj,@GetLevel);
      school = Send(obj,@GetSchool);
      division = Send(obj,@GetDivision);

      // Phase three. We begin to find our need.  Start by finding out how many
      // spells exist at ALL at that level. While we are going through the spell
      // skill list, count the spells/skills that count towards our total. Note
      // that we only want the top three spells/skills at that school and level.

      bKnowOne = FALSE;

      // Check to see if they have any spells of the next level.
      //  If so, let them buy any spells they want.
      iHave = Send(self,@CountKnownAtLevel,#school=school,#level=level+1);
      if iHave > 0
      {
         return PLAYER_LEARN_SUCCESS;
      }

      // See how many spells they have at this level.
      iHave = Send(self,@CountKnownAtLevel,#school=school,#level=level);
      if iHave > 0
      {
         // For level 3 or higher, they can learn if they have another spell
         // in that school and level. If they have two spells at a lower level,
         // they need 2 or more spells in that school or level. This prevents
         // people getting all level 2 spells fresh out of character creation.
         if level > 2
            OR iHave >= 2
         {
            return PLAYER_LEARN_SUCCESS;
         }

         // Flag it so we know that they already have a spell in that level.
         bKnowOne = TRUE;
      }

      if level > 1
      {
         prev_level = Send(SYS,@GetNumAtLevel,#school=school,#level=level-1);
      }
      else
      {
         prev_level = 0;
      }

      aHigh = 0; bHigh = 0; cHigh = 0;

      iWeapon = 0;
      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;

      foreach i in plSkills
      {
         nSID=Send(self,@DecodeSkillNum,#compound=i);
         nobj=Send(SYS,@FindSkillByNum,#num=nSID);

         if nobj = $
         {
            Debug("bad data in skill list!");

            return PLAYER_LEARN_ERROR;
         }

         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         nLevel = Send(nobj,@GetLevel);
         nSchool = Send(nobj,@GetSchool);

         // Is this in the same school at level N-1?
         if school = nSchool AND (level-1) = (nLevel)
         {
            index = Send(self,@DecodeSkillAbility,#compound=i);
            if index > aHigh
            {
               temp = aHigh;
               aHigh = index;
               index = temp;
            }

            if index > bHigh
            {
               temp = bHigh;
               bHigh = index;
               index = temp;
            }

            if index > cHigh
            {
               cHigh = index;
            }
         }

         switch (nSchool)
         {
         case SKS_WEAPONCRAFT:
            if nLevel > iWeapon
            {
               iWeapon = nLevel;
            }
            break;
         }
      }

      foreach i in plSpells
      {
         nSID=Send(self,@DecodeSpellNum,#compound=i);
         nobj=Send(SYS,@FindSpellByNum,#num=nSID);

         if nobj = $
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }

         nSchool = Send(nobj,@GetSchool);
         nLevel = Send(nobj,@GetLevel);

         if (NOT IsClass(nobj,&Spell)) OR (nLevel> 10)
         {
            continue;
         }

         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         if nSchool = SS_DM_COMMAND
         {
            continue;
         }

         // Is this in the same school at level N-1?
         if school = nSchool AND (level-1) = (nlevel)
         {
            index = Send(self,@DecodeSpellAbility,#compound=i);

            if index > aHigh
            {
               temp = aHigh; aHigh = index; index = temp;
            }

            if index > bHigh
            {
               temp = bHigh; bHigh = index; index = temp;
            }

            if index > cHigh
            {
               cHigh = index;
            }
         }

         if NOT IsClass(nobj,&Blink)  // DON'T COUNT BLINK!
            AND NOT IsClass(nobj,&UtilitySpell) // Don't count utility spells
         {
            switch (nSchool)
            {
            case SS_KRAANAN:
               if nLevel > iKraanan
               {
                  iKraanan = nLevel;
               }
               break;
            case SS_SHALILLE:
               if nLevel > iShalille
               {
                  iShalille = nLevel;
               }
               break;
            case SS_QOR:
               if nLevel > iQor
               {
                  iQor = nLevel;
               }
               break;
            case SS_FAREN:
               if nLevel > iFaren
               {
                  iFaren = nLevel;
               }
               break;
            case SS_RIIJA:
               if nLevel > iRiija
               {
                  iRiija = nLevel;
               }
               break;
            case SS_JALA:
               if nLevel > iJala
               {
                  iJala = nLevel;
               }
               break;
            }
         }
      }

      if level > 1
      {
         // Only top three matter in the math.
         iHave = aHigh + bHigh + cHigh;
      }
      else
      {
         // You always have the "max" for level 1
         iHave = (3 * 99);
      }

      // Do easy checks to prevent unnecessary math.
      // Keep these checks here so they are of lower precedence than
      // the 'you already have this spell' check.

      if NOT Send(obj,@KarmaCheck,#who=self)
      {
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,#message_rsc=player_Debug_noKarma,
                 #parm1=Send(self,@GetTrueName),#parm2=Send(obj,@GetName));
         }
         
         return PLAYER_LEARN_KARMA;
      }

      // Player can't learn level this because he knows nothing of
      //  previous level.
      if iHave = 0
      {
         return PLAYER_LEARN_NOBASE;
      }

      // We have done all the information gathering, so now, lets compute:

      iPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
               + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
               + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
               + Send(SYS,@GetLevelLearnPoints,#level=iQor)
               + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
               + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
               + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      // Okay, we're going into new territory if we don't already know one
      //  spell in the school, so we're increasing the level of our
      //  knowledge.  Add points.
      if not bKnowOne
      {
         iPoints = iPoints + Send(SYS,@GetLevelLearnPoints,#level=level)
                           - Send(SYS,@GetLevelLearnPoints,#level=(level-1));
      }

      // How this oddball equation works: You have a POINTS_SLOPE that determines
      //  how steep the advancement slope is.  A higher slope results in lower
      //  levels requiring less points, but each school level gained counts more
      //  against future learning.  You hit your max when you get to 297 points
      //  (3*99), so when your points equals max points, you've maxxed out.  
      //  Intellect gives you a bonus to learning, currently about 20 points
      //  for 50 Intellect (approximately mastering 2 extra schools)
      iNeed =   (iPoints * POINTS_SLOPE)
              + (297 - (Send(SETTINGS_OBJECT, @GetMaxLearnPoints) * POINTS_SLOPE))
              - ((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5);

      // NOTE: if you modify the above equation, also modify GivePlayerAllSkills
      //  and GivePlayerAllSpells as needed

      // Bound iNeed to a reasonable low level so people can't just rush in and
      //  get high level with very little work.
      iNeed = Bound(iNeed,MIN_NEEDED_TO_ADVANCE,$);

      if scryer <> $
      {
         // nSchool will equal how much the intended school's points added.
         if school = SKS_WEAPONCRAFT
         {
            nSchool = iWeapon;
         }
         else if school = SS_KRAANAN
         {
            nSchool = iKraanan;
         }
         else if school = SS_SHALILLE
         {
            nSchool = iShalille;
         }
         else if school = SS_QOR
         {
            nSchool = iQor;
         }
         else if school = SS_FAREN
         {
            nSchool = iFaren;
         }
         else if school = SS_RIIJA
         {
            nSchool = iRiija;
         }
         else if school = SS_JALA
         {
            nSchool = iJala;
         }

         // Bring the points back down to the original total, before learning.
         if NOT bKnowOne
         {
            iPoints = iPoints - Send(SYS,@GetLevelLearnPoints,#level=level)
                              + Send(SYS,@GetLevelLearnPoints,#level=(level-1));
         }

         Send(scryer,@MsgSendUser,#message_rsc=player_Debug_playercanlearn,
              #parm1=Send(self,@GetName),#parm2=Send(obj,@GetLevel),
              #parm3=Send(obj,@GetSchoolStr),#parm4=iPoints,#parm5=nSchool,
              #parm6=((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5),
              #parm7=iNeed,#parm8=iHave);
      }

      // If the previous level has fewer than three spells, help them out.
      if prev_level = 1
      {
         iNeed= iNeed / 3;
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,
                  #message_rsc=player_Debug_playercanlearn_scarcity,
                  #parm1=iNeed);
         }
      }

      if prev_level = 2
      {
         iNeed = (iNeed*2)/3;
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,
                  #message_rsc=player_Debug_playercanlearn_scarcity,
                  #parm1=iNeed);
         }
      }

      if iHave >= iNeed
      {
         return PLAYER_LEARN_SUCCESS;
      }

      // Okay, at this point, we know that they didn't pass the test.  Now give
      // them a good reason why.  Essentially, if they know a lot of other
      // divisions and it's slowing them down, tell them that.  Otherwise,
      // be more generic.
      
      // Is it now impossible to actually learn this spell level?  This would
      // mean that the need is greater than 99// in three of the previous
      // level's spells, or 297 (most of the time).  Levels with fewer than
      // three spells are a special instance.
      if iNeed > (99*(Bound(prev_level,1,3)))
      {
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,#message_rsc=player_Debug_noway,
                 #parm1=Send(self,@GetTrueName),#parm2=Send(obj,@GetName));
         }

         return PLAYER_LEARN_IMPOSSIBLE;
      }

      // Return info in this format (base 10):  xxxy, where xxx is the number
      // of spell or skill points they need, and y is the reason why they
      // failed.  Only condition is "not enough points".
      return ((10*(iNeed-iHave))+PLAYER_LEARN_BASE);
   }

   GetTotalLearnPoints(except = $)
   {
      local iSpell, iSID, oSpellObj, iSchool, iLevel, iKraanan, iShalille,
            iQor, iFaren, iRiija, iJala, iWeapon, iTotalLearnPoints;

      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      iWeapon = 0;

      foreach iSpell in plSpells
      {
         iSID = Send(self,@DecodeSpellNum,#compound=iSpell);
         oSpellObj = Send(SYS,@FindSpellByNum,#num=iSID);

         iSchool = Send(oSpellObj,@GetSchool);
         iLevel = Send(oSpellObj,@GetLevel);

         if NOT IsClass(oSpellObj,&Blink)  // DON'T COUNT BLINK!
            AND NOT IsClass(oSpellObj,&UtilitySpell) // Don't count utility spells
            AND iSchool <> SS_DM_COMMAND
            AND except <> iSchool
         {
            switch (iSchool)
            {
            case SS_KRAANAN:
               if iLevel > iKraanan
               {
                  iKraanan = iLevel;
               }
               break;
            case SS_SHALILLE:
               if iLevel > iShalille
               {
                  iShalille = iLevel;
               }
               break;
            case SS_QOR:
               if iLevel > iQor
               {
                  iQor = iLevel;
               }
               break;
            case SS_FAREN:
               if iLevel > iFaren
               {
                  iFaren = iLevel;
               }
               break;
            case SS_RIIJA:
               if iLevel > iRiija
               {
                  iRiija = iLevel;
               }
               break;
            case SS_JALA:
               if iLevel > iJala
               {
                  iJala = iLevel;
               }
               break;
            }
         }
      }

      foreach iSpell in plSkills
      {
         iSID = Send(self,@DecodeSkillNum,#compound=iSpell);
         oSpellObj = Send(SYS,@FindSkillByNum,#num=iSID);

         iSchool = Send(oSpellObj,@GetSchool);
         iLevel = Send(oSpellObj,@GetLevel);

         if iSchool <> SKS_DM
            AND except <> iSchool
         {
            switch (iSchool)
            {
            case SKS_WEAPONCRAFT:
               if iLevel > iWeapon
               {
                  iWeapon = iLevel;
               }
               break;
            }
         }
      }

      iTotalLearnPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
                         + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
                         + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
                         + Send(SYS,@GetLevelLearnPoints,#level=iQor)
                         + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
                         + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
                         + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      return iTotalLearnPoints;
   }

   EvaluatePKStatus(dbug=FALSE)
   "This should always be run AFTER the player undergoes whatever changes "
   "(i.e. quits a guild or drops below 30 health).  Also, take steps to ensure "
   "it is not run immediately prior to death."
   {
      local i, ass_game;

      if (piFlags & PFLAG_PKILL_LOCK)
      {
         return FALSE;
      }

      // Tell the room that our status changed, recalc enchantments.
      if (poOwner <> $)
      {
         Post(poOwner,@EnchantPlayerStatusChanged,#who=self);
      }

      if (piFlags & PFLAG_PKILL_ENABLE)
      {
         if poGuild = $
            AND piBase_Max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            AND NOT (piFlags & PFLAG_MURDERER)
            AND NOT (piFlags & PFLAG_OUTLAW)
         {
            ass_game = Send(SYS,@GetAssassinGame);
            if Send(ass_game,@IsCombatant,#who=self)
            {
               Send(self,@MsgSendUser,#message_rsc=Player_dagger_shatters);
               Send(ass_game,@RemoveFromGame,
                     #who=self,#RemoveFromRecords=FALSE);
            }

            Send(self,@MsgSendUser,#message_rsc=player_regain_angel);
            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
            Send(self,@PlayerIsIntriguing);
         }
      }
      else
      {
         if poGuild <> $
            OR piBase_Max_health >= Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            OR (piFlags & PFLAG_MURDERER)
            OR (piFlags & PFLAG_OUTLAW)
         {
            if Send(SYS,@IsPKAllowed)
            {
               // Happylanders don't get 'vulnerable' message.
               Send(self,@MsgSendUser,#message_rsc=player_no_angel);
            }

            // Once you've become killable, you no longer get tutorial messages
            // and bonuses.  You also lose your newbie string.
            Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
            Send(self,@RemoveHonorString,#string=player_newbie_honor_string);

            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);
            if dbug = TRUE
            {
               Debug("Someone with less than 30 health managed to guild or "
                     "outlaw",self);
            }
         }
      }

      return;
   }

   CanPlayerPvP()
   {
      return (piFlags & PFLAG_PKILL_ENABLE)
         AND NOT (piFlags & PFLAG_PERMA_NO_PVP)
         AND NOT (piFlags & PFLAG_TEMPSAFE);
   }

   PKillEnable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      if Send(SYS,@IsPKAllowed)
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_angel);
      }

      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);

      return Send(SYS,@GetSuccessRsc);
   }

   PkillDisable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   // Note: a player with PKILL_ENABLE set will have it reset at will if 
   // an event naturally causes it to.  If you want to not have this change,
   // then call PkillLock below.  This will ensure that the status of
   // PKILL_ENABLE will never change, with the exception of a suicide.

   PkillLock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=TRUE);

      return Send(SYS,@GetSuccessRsc);
   }

   PkillUnlock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   StartTempSafe()
   {
      local iTime;

      // First, check if we're in a guild hall. Players can exploit this
      // system by dying in a guild hall and using PoL or the UW node to
      // teleport back to their bodies with temp safe activated, which would
      // leave them unable to be killed and inside a hall. Teleport players
      // from the guild hall to their hometown.
      if poOwner <> $
         AND IsClass(poOwner,&GuildHall)
      {
         Send(self,@AdminGotoSafety);
      }

      // This returns minutes, so convert to milliseconds.
      iTime = Send(SETTINGS_OBJECT,@GetTempSafeTime);
      iTime = iTime * 60 * 1000;

      if (ptTempSafe <> $
         AND IsTimer(ptTempSafe))
      {
         DeleteTimer(ptTempSafe);
      }

      piFlags = piFlags | PFLAG_TEMPSAFE;

      // Only set a timer if logged on.
      if (pbLogged_on)
      {
         ptTempSafe = CreateTimer(self,@EndTempSafe,iTime);
         Send(self,@MsgSendUser,#message_rsc=player_temp_safe);
         if (poOwner <> $)
         {
            Send(poOwner,@SomethingChangedFlags,#what=self);
         }
      }
      else
      {
         ptTempSafe = iTime;
      }

      return;
   }

   EndTempSafe()
   {
      piFlags = piFlags & ~PFLAG_TEMPSAFE;
      if poOwner <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_temp_safe_end);
         Send(poOwner,@SomethingChangedFlags,#what=self);
      }

      ptTempSafe = $;

      return;
   }

   PauseTempSafe()
   {
      local iTemp;

      if (NOT IsTimer(ptTempSafe))
      {
         return;
      }

      iTemp = GetTimeRemaining(ptTempSafe);
      DeleteTimer(ptTempSafe);
      ptTempSafe = iTemp;

      return;
   }

   UnpauseTempSafe()
   {
      if (ptTempSafe = $)
      {
         return;
      }

      if (NOT IsTimer(ptTempSafe))
      {
         ptTempSafe = CreateTimer(self,@EndTempSafe,ptTempSafe);
      }

      piFlags = piFlags | PFLAG_TEMPSAFE;
      Send(self,@MsgSendUser,#message_rsc=player_temp_safe);

      return;
   }

   SetPlayerPvPPermaOff()
   "Called to switch the player to non-pvp mode."
   {
      local oShield;

      piflags |= PFLAG_PERMA_NO_PVP;

      // Drop shield if we have one.
      oShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oShield <> $
      {
         Send(oShield,@LostFaction);
      }

      if (poOwner <> $)
      {
         Send(poOwner,@SomethingChangedFlags,#what=self);
      }

      return;
   }

   SetPlayerPvPPermaOn()
   {
      piflags &= ~PFLAG_PERMA_NO_PVP;

      if (poOwner <> $)
      {
         Send(poOwner,@SomethingChangedFlags,#what=self);
      }

      return;
   }

   ResetFaction(faction = FACTION_NEUTRAL)
   {
      local oSoldierShield;

      if faction < FACTION_NEUTRAL
         OR faction > FACTION_NORMAL_MAX
      {
         return FALSE;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      if oSoldierShield <> $
         AND faction <> Send(oSoldierShield,@GetFaction)
      {
         Send(oSoldierShield,@LostFaction);
      }

      piFaction = faction;

      return TRUE;
   }

   GetFaction()
   {
      return piFaction;
   }

   // Need to be able to keep track of their service...
   // When players join, and subsequently log on, the
   // updated time gets set and the timer gets started.

   UpdateFactionService(full=FALSE,middle=FALSE,front=FALSE,adjust=TRUE)
   {
      local tyme, oSoldierShield;

      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      tyme = GetTime();

      // Don't require new service if the player has been an active soldier.
      if oSoldierShield = $
      {
         piFactionServiceUpdate += tyme - piFactionTimeUpdated;
      }
      else
      {
         // Get rid of warnings.
         if piFactionServiceUpdate > FACTION_WARN_TIME
         {
            piFactionServiceUpdate = FACTION_WARN_TIME;
         }
      }

      piFactionTimeUpdated = tyme;

      if NOT adjust
      {
         return;
      }

      if full
      {
         piFactionServiceUpdate = 0;
      }
      else if middle
      {
         piFactionServiceUpdate = piFactionServiceUpdate / 2;
      }
      else if front
      {
         piFactionServiceUpdate = 3* piFactionServiceUpdate / 4;
      }

      return;
   }

   FactionServiceTimer(renew=TRUE)
   {
      // Attempts to delete any existing timer, then passes to
      // FactionServiceRenew which creates a new timer if conditions are met.

      if ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
         ptFactionTimer = $;
      }

      Send(Self,@FactionServiceRenew,#renew=renew);

      return;
   }

   FactionServiceRenew(renew=TRUE)
   {
      // This function now handles renewal of ptFactionTimer and should
      // only be accessed from FactionServiceTimer() after the $ check.

      local iHistory;
      
      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      Send(Self,@UpdateFactionService,#adjust=FALSE);
      if piFactionServiceUpdate > FACTION_RESIGN_TIME
      {
         // Add bNoTimer = TRUE so we don't try to delete a non-existent timer.
         Send(self,@ResignFaction,#bNoTimer=TRUE);

         return;
      }

      if piFactionServiceUpdate > FACTION_WARN_TIME
      {
         Send(self,@MsgSendUser,#message_rsc=player_faction_time);
         // This should be unnecessary (since loyalty quests reschedule
         // themselves at completion), but is included nonetheless to 
         // ensure that if you've been warned, there's a quest waiting for you.

         if piFaction = FACTION_PRINCESS
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
            iHistory = First(Send(self,@GetQuestHistory,
                        #index=QST_ID_PRINCESS_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_PRINCESS_SERVICE);
            }
         }

         if piFaction = FACTION_DUKE
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_DUKE_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,
                  #index=QST_ID_DUKE_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_DUKE_SERVICE);
            }
         }

         if piFaction = FACTION_REBEL
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_REBEL_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,
                  #index=QST_ID_REBEL_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_REBEL_SERVICE);
            }
         }
      }

      if renew AND Send(SYS,@GetParliament) <> $
         AND (NOT Send(Send(SYS,@GetParliament),@IsShutdown))
      {
         ptFactionTimer = CreateTimer(self,@FactionServiceRenew,
                                             FACTION_UPDATE_TIME);
      }

      return;
   }

   PlayerIsIntriguing()
   "Evaluates player and sets the PFLAG_INTRIGUING"
   {
      local bIntrigue, wasint, i, oParl;

      bIntrigue=0;

      oParl=Send(SYS,@GetParliament);
      if oParl = $
      {
         return FALSE;
      }

      wasint = (piFlags & PFLAG_INTRIGUING);

      if wasint AND Send(oParl,@IsShutdown)
      {
         Send(self,@MsgSendUser,#message_rsc=player_intrigue_shut);
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=FALSE);
         Send(oParl,@UpdateEffects,#who=self);
         if ptFactionTimer<>$
         {
            DeleteTimer(ptFactionTimer);
            ptFactionTimer=$;
         }

         foreach i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused,#what=self);

               break;
            }
         }
         return FALSE;
      }

      if Send(oParl,@IsShutdown)
      {
         return FALSE;
      }

      if (piFlags & PFLAG_PKILL_ENABLE)
         AND (Send(self,@PlayerIsHPIntrigue)
              OR Send(self,@PlayerIsAdept))
      {
         bIntrigue = PFLAG_INTRIGUING;
      }

      if wasint <> bIntrigue
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=bIntrigue);
      }

      if NOT wasint AND bIntrigue
      {
         if piFactionEffect <> 0
         {
            Debug("NonIntriguing Player",Send(self,@GetName),"had effects "
                  "set:",piFactionEffect);
            piFactionEffect=0;
         }

         piFaction = FACTION_NEUTRAL;
         Send(oParl,@UpdateEffects,#who=self);
         Send(oParl,@MovetoFaction,#who=self,#faction=FACTION_NEUTRAL);
         Send(self,@ReceiveNestedMail,#from=intrigue_ambassador,
              #dest_list=[self],#nest_list=[4,player_intrigue_mail]);
      }

      if wasint AND NOT bIntrigue
      {
         Send(self,@MsgSendUser,#message_rsc=player_lost_intriguing);
         Send(self,@ResignFaction);
         Send(oParl,@MovetoFaction,#who=self,#faction=(-1));
         foreach i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused);

               break;
            }
         }
      }

      return bIntrigue;
   }

   JoinFaction(new_faction=FACTION_NEUTRAL)
   "Returns true if the joining was a success"
   {
      local factliege, oParliament, oQuestEngine;

      if NOT Send(Self,@PlayerIsIntriguing)
      {
         return FALSE;
      }

      if new_faction <= FACTION_NEUTRAL
         OR new_faction > FACTION_NORMAL_MAX
      {
         return FALSE;
      }

      if piFaction <> FACTION_NEUTRAL
      {
         return FALSE;
      }

      piFaction = new_faction;
      // Increase the max number of loyalty quests by one, and schedule one.
      oQuestEngine = Send(SYS,@GetQuestEngine);
      
      if piFaction = FACTION_PRINCESS
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_PRINCESS_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_PRINCESS_SERVICE),
                                     QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
         Post(self,@DrawDefense);
      }

      if piFaction = FACTION_DUKE
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_DUKE_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_DUKE_SERVICE),
                                     QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_DUKE_SERVICE,#override=TRUE);
      }

      if piFaction = FACTION_REBEL
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_REBEL_SERVICE,
               #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                      #index=QST_ID_REBEL_SERVICE),
                                      QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_REBEL_SERVICE,#override=TRUE);
         Post(self,@DrawOffense);
      }

      piFactionTimeUpdated = GetTime();
      piFactionServiceUpdate = 0;
      oParliament = Send(SYS,@GetParliament);

      if piFaction <> FACTION_NEUTRAL
      {
         factliege = Send(oParliament,@GetLiege,#faction=piFaction);
      }

      ptFactionTimer = $;
      Send(Self,@FactionServiceTimer);
      Send(oParliament,@MoveToFaction,#who=self,#faction=piFaction);
      Send(oParliament,@UpdateEffects,#who=self);
      Send(self,@MsgSendUser,#message_rsc=player_join_faction,
            #parm1=Send(factliege,@GetDef),#parm2=Send(factliege,@GetName));

      return TRUE;
   }

   ResignLoyaltyFailed()
   {
      // Don't boot the player unless they've been factioned longer
      // than 5400 seconds (90 minutes)

      if piFactionServiceUpdate < 5400
      {
         return;
      }

      Send(self,@ResignFaction);

      return;
   }

   ResignFaction(bNoTimer=FALSE)
   {
      local numMembers, oParliament, oQuestEngine, oQuest, oFlagPole;

      if poOwner <> $
      {
         oFlagPole = Send(poOwner,@FindHoldingActive,#Class=&Flagpole);
         if oFlagPole <> $ AND Send(oFlagPole,@IsClaimAttemptInProgress)
         {
            if Send(oFlagPole,@GetClaimer) = self
            {
               Send(oFlagPole,@ClaimFailed);
            }
         }
      }

      oQuestEngine = Send(SYS,@GetQuestEngine);
      if (oQuestEngine = $)
      {
         return;
      }

      if Send(Self,@PlayerIsIntriguing)
         AND piFaction <> FACTION_NEUTRAL
      {
         Send(self,@MsgSendUser,#message_rsc=player_unfactioned);
      }

      // Decrease the max number of loyalty quests by one
      if piFaction = FACTION_PRINCESS
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_PRINCESS_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,
                 #index=QST_ID_PRINCESS_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Princess faction members!");
         }
         Post(self,@DrawDefense);
      }

      if piFaction = FACTION_DUKE
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_DUKE_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);

         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_DUKE_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Duke faction members!");
         }
      }

      if piFaction = FACTION_REBEL
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_REBEL_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_REBEL_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Rebel faction members!");
         }
         Post(self,@DrawOffense);
      }

      Send(self,@ResetFaction,#faction=FACTION_NEUTRAL);

      if NOT bNoTimer
         AND ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
      }

      ptFactionTimer=$;
      piFactionTimeUpdated = 0;
      piFactionServiceUpdate = 0;

      oParliament = Send(SYS,@GetParliament);
      if oParliament <> $
      {
         if Send(self,@PlayerIsIntriguing)
         {
            Send(oParliament,@MoveToFaction,#who=self,#faction=piFaction);
         }
         else
         {
            Send(oParliament,@MoveToFaction,#who=self,#faction=(-1));
         }

         Send(oParliament,@UpdateEffects,#who=self);
      }

      return;
   }

   PlayerIsHPIntrigue()
   "If player has over 40hp base."
   {
      return (piBase_Max_health >= Send(SETTINGS_OBJECT,@GetIntrigueEnableHP));
   }

   PlayerIsAdept()
   "If player has 5th level spell over the enabling percent, then true"
   {
      local i, sid, oSpell;

      foreach i in plSpells
      {
         sid = abs(i/100);
         oSpell = Send(SYS,@FindSpellByNum,#num=sid);
         if IsClass(oSpell,&Spell) AND Send(oSpell,@GetLevel) = 5
            AND (i % 100) >= INTRIGUE_ENABLE_SPELL
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   CheckTokenInNewRoom(what=$)
   "If we are carrying a token, lets drop it."
   {
      local i, bFound;

      if what = $
         OR poOwner = $
         OR Send(poOwner,@CanTokenEnterRoom)
      {
         return;
      }

      bFound = FALSE;

      foreach i in plPassive
      {
         if IsClass(i,&Token)
         {
            bFound = TRUE;
            Send(i,@NewUnused,#where=what);
         }
      }

      if bFound
      {
         // Give a different message depending on the room.
         if IsClass(poOwner,&GuildHall)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_hall);

            return;
         }

         if Send(poOwner,@IsArena)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_arena);

            return;
         }

         if IsClass(poOwner,&SurvivalRoom)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_survival);

            return;
         }

         Send(self,@MsgSendUser,#message_rsc=player_lost_token_generic);
      }

      return;
   }

   GetFactionService()
   {
      return piFactionServiceUpdate;
   }

   GetFactionEffect()
   {
      return piFactionEffect;
   }

   SetFactionEffect(effect=0)
   {
      piFactionEffect = effect;

      return;
   }

   TokenDeliveryReward(mob=$)
   {
      local tobj,classes;

      classes = Send(Send(SYS,@GetLibrary),@GetQuestRewardList);
      if classes = $
      {
         return;
      }

      if IsClass(mob,&Council)
         OR (IsClass(mob,&Factions) AND Send(mob,@GetFaction) = piFaction)
         OR (IsClass(mob,&ShalillePriestess) AND piFaction = FACTION_NEUTRAL)
      {
         tobj = Create(Nth(classes,Random(1,Length(classes))));
         if Send(self,@ReqNewHold,#what=tobj)
         {
            Send(self,@NewHold,#what=tobj);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                  #string=player_token_reward,#parm1=Send(tobj,@GetDef),
                  #parm2=Send(tobj,@GetName));
         }
         else
         {
            Send(poOwner,@NewHold,#what=tobj,#new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                  #string=player_token_reward_heavy,#parm1=Send(tobj,@GetDef),
                  #parm2=Send(tobj,@GetName));
         }
      }

      return;
   }

   GetInstrumentLevel()
   "Returns the power of the instrument we are holding."
   {
      local i, iPower;

      iPower = 0;

      // Search through for the instrument of the highest power.
      //  We could have a necklace and a lute.  Let the lute contribute
      //  its power, rather than the necklace.
      foreach i in plUsing
      {
         if IsClass(i,&Instrument)
         {
            iPower = iPower + Send(i,@GetInstrumentLevel);
         }
      }

      return iPower;
   }

   ZeroMods()
   "Should NOT be called before removing all potential stat-modifying things"
   {
      piMightMod = 0;
      piIntellectMod = 0;
      piMysticismMod = 0;
      piAgilityMod = 0;
      piStaminaMod = 0;
      piAimMod = 0;

      return;
   }

   CheckLog()
   {
      return (piFlags & PFLAG_LOG);
   }

   DecayPKillCount()
   {
      // 50// chance to reduce the kill count.  This is to eliminate
      // the people who attempt to exploit this system for gain.
      if Random(1,100) > 50
      {
         --piKill_count_decay;
         piKill_count_decay = Bound(piKill_count_decay,0,$);
      }

      return;
   }

   GetUnjustifiedKills()
   {
      return piKill_count;
   }

   GetDecayedUnjustifiedKills()
   {
      return piKill_count_decay;
   }

   GetJustifiedKills()
   {
      return piJustified_kill_count;
   }

   UserReqNewOwner(RID=0)
   {
      local oRoom;

      if RID = 0
      {
         return;
      }

      oRoom = Send(SYS,@FindRoomByNum,#num=RID);
      if oRoom = $
      {
         Debug("Got an invalid room!");
         return FALSE;
      }

      if IsClass(oRoom,&GuildHall)
         AND (NOT Send(self,@CanPlayerPvP))
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_enter);

         return FALSE;
      }

      Send(self,@BreakTrance,#event=EVENT_REQNEWOWNER);

      return TRUE;
   }

   GivePlayerAllSpells(school=0,level=-1,upto=TRUE,iability=99,override=FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints,
            iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      // Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(SETTINGS_OBJECT, @GetMaxLearnPoints) +
                              (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints +
                     Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               // Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;
               
               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         // nothing to do here
         return FALSE;
      }

      foreach i in Send(SYS,@GetSpells)
      {
         if NOT IsClass(i,&Spell)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSpell,#num=Send(i,@GetSpellNum),
                     #iability=iAbility,#dontSend=TRUE);
            }
         }
      }

      // Set Karma enough for them to cast their highest level spell.
      if school = SS_SHALILLE
      {
         // Need 10 Karma per spell level (+10 for fudge).
         piKarma = level * 1000;
      }

      if school = SS_QOR
      {
         // Need -10 Karma per spell level (-10 for fudge).
         piKarma = level * -1000;
      }
      Send(self,@ToCliSpells);
      Send(self,@DrawKarma);

      return TRUE;
   }

   GivePlayerAllSkills(school=0,level=-1,upto=TRUE,iability=99,override=FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints,
            iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      // Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(SETTINGS_OBJECT, @GetMaxLearnPoints) +
            (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints +
                     Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               // Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;

               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         // nothing to do here
         return FALSE;
      }

      foreach i in Send(SYS,@GetSkills)
      {
         if NOT IsClass(i,&Skill)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSkill,#num=Send(i,@GetSkillNum),
                     #iability=iAbility,#dontSend=TRUE);
            }
         }
      }

      Send(self,@ToCliSkills);

      return TRUE;
   }

   // Designed this just like GetSpellSchoolLevels in case a skill school
   // is added later and this needs to be extended.
   GetSkillSchoolLevels()
   {
      local i, lSchoolLevels, oSkill, iLevel, iSchool, weaponcraft_level;

      weaponcraft_level = 0;
      iLevel = 0;

      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                      #compound=i));
         iLevel = Send(oSkill,@GetLevel);
         iSchool = Send(oSkill,@GetSchool);
         if (iSchool = SKS_WEAPONCRAFT)
         {
            if iLevel > weaponcraft_level
            {
               weaponcraft_level = iLevel;
            }
         }
      }

      lSchoolLevels = [weaponcraft_level];

      return lSchoolLevels;
   }

   GetSpellSchoolLevels(include_cant_forget=FALSE)
   {
      local i, lSchoolLevels, oSpell, iSchool, iLevel, iCanForget,
            shalille_level, qor_level, kraanan_level, faren_level,
            riija_level, jala_level;

      shalille_level = 0;
      qor_level = 0;
      kraanan_level = 0;
      faren_level = 0;
      riija_level = 0;
      jala_level = 0;
      iCanForget = TRUE;

      // Get max level in each school. Yes, this is ugly but I'm trying for
      // the least number of comparisons possible per spell. Schools in order
      // of popularity, your results may vary. 10/25/2014 103 stats: 578 kran,
      // 228 faren, 284 shal, 160 riija, 216 qor, 151 jala
      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                      #compound=i));
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iCanForget) OR (NOT iCanForget AND include_cant_forget)
         {
            if (iSchool = SS_KRAANAN)
            {
               if (iLevel > kraanan_level)
               {
                  kraanan_level = iLevel;
               }
            }
            else if (iSchool = SS_SHALILLE)
            {
               if (iLevel > shalille_level)
               {
                  shalille_level = iLevel;
               }
            }
            else if (iSchool = SS_QOR)
            {
               if (iLevel > qor_level)
               {
                  qor_level = iLevel;
               }
            }
            else if (iSchool = SS_FAREN)
            {
               if (iLevel > faren_level)
               {
                  faren_level = iLevel;
               }
            }
            else if (iSchool = SS_RIIJA)
            {
               if (iLevel > riija_level)
               {
                  riija_level = iLevel;
               }
            }
            else if (iSchool = SS_JALA)
            {
               if (iLevel > jala_level)
               {
                  jala_level = iLevel;
               }
            }
         }
      }

      // Order matters here, they appear in the order listed in blakston.khd.
      lSchoolLevels = [shalille_level,qor_level,kraanan_level,
                       faren_level,riija_level,jala_level];

      return lSchoolLevels;
   }

   StripSpellsOfSchool(school = 0, All = FALSE)
   {
      local i, j, k;

      if (ALL)
      {
         j = 1;
         while (j < NUM_SCHOOLS)
         {
            k = 1;
            while (k < NUM_SPELL_LEVELS)
            {
               Send(self, @StripSpellsOfSchoolByLevel, #school=j, #level=k);
               ++k;
            }
            ++j;
         }
      }
      else
      {
         k=1;
         while (k < NUM_SPELL_LEVELS)
         {
            Send(self, @StripSpellsOfSchoolByLevel, #school=school, #level=k);
            ++k;
         }
      }

      return;
   }

   StripSpellsOfSchoolByLevel(school = 0, level = 0)
   {
      local i, oSpell, iSchool, iLevel, iCanForget, iSpellNum;

      foreach i in plSpells
      {
         iSpellNum = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iSchool = school) AND (iLevel = level) AND iCanForget
         {
            Send(self,@RemoveSpell,#num=iSpellNum);
         }
      }

      return;
   }

   StripSkillsOfSchoolByLevel(school = 0, level = 0)
   {
      local i, oSkill, iSchool, iLevel;

      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oSkill,@GetSchool);
         iLevel = Send(oSkill,@GetLevel);

         if (iSchool = school) AND (iLevel = level)
         {
            Send(self,@RemoveSkill,#num=Send(self,@DecodeSkillNum,#compound=i));
         }
      }

      return;
   }

   IsWizard()
   {
      return Length(plSpells) > 50;
   }

   ClearSpellList()
   {
      plSpells = $;

      return;
   }

   GetMaster()
   {
      return $;
   }

   IsInvisible()
   {
      return (piFlags & PFLAG_INVISIBLE);
   }

   IsShadowForm()
   {
      return (piDrawFX = DRAWFX_BLACK);
   }

   IsMorphed()
   {
      return (piFlags & PFLAG_MORPHED);
   }

   IsMorphedOrIllusioned()
   {
      return (poIllusion_set <> $) OR (piFlags & PFLAG_MORPHED);
   }

   //// Get Color Routines

   GetSkinColor()
   {
      return (piBody_translations & PLAYER_TRANSLATION_Skin_MASK)
                  /PLAYER_TRANSLATION_Skin_MUL;
   }

   GetHairColor()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_HAIR_MASK)
                  /PLAYER_TRANSLATION2_HAIR_MUL;
   }

   GetLegsTranslation()
   {
      // This returns the whole translation, including skin color.
      return (piBody_translations & PLAYER_TRANSLATION_LEGS_MASK)
                  /PLAYER_TRANSLATION_LEGS_MUL;
   }

   GetArmsTranslation()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_ARMS_MASK)
                  /PLAYER_TRANSLATION2_ARMS_MUL;
   }

   GetBodyTranslation()
   {
      // This returns the armor/shirt torso (not arms) color.  note that skin is
      //  included in this, in the case of a low-cut dress, for example.
      return (piBody_translations & PLAYER_TRANSLATION_BODY_MASK)
               /PLAYER_TRANSLATION_BODY_MUL;
   }

   GetDefaultShirtTranslation()
   "This includes skin tones - important for the arms."
   {
      return ((piDefault_Clothes & SHIRT_MASK) / SHIRT_MUL);
   }

   GetDefaultShirtColor()
   "This does not include skin tones."
   {
      local iXlat;

      iXlat = Send(self,@GetDefaultShirtTranslation);

      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   GetCurrentShirtColor()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&ShirtBase)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }

      return Send(self,@GetDefaultShirtTranslation);
   }

   GetDefaultPantsTranslation()
   "This includes skin tones."
   {
      return (((piDefault_Clothes & PANTS_MASK) / PANTS_MUL));
   }

   GetDefaultPantsColor()
   "This does not include skin tones."
   {
      local iXlat;

      iXlat = Send(self,@GetDefaultPantsTranslation);

      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   SetSkinColor(color = 1)
   {
      local iColor, i;

      // Arms (hands) and face are the only default things that need to
      // have skin colors associated with it.  Other items in use
      // may need to, though (low cut dress).

      Send(self,@SetSkinTranslation,#translation=color);
      iColor = Send(self,@GetDefaultShirtColor);
      Send(self,@SetDefaultClothes,#shirt_color = iColor);
      foreach i in plUsing
      {
         Send(i,@DoPlayerArt);
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetHead(head=$)
   {
      if head <> $
      {
         prHead = head;
      }

      return;
   }

   SetEyes(eyes=$)
   {
      if eyes <> $
      {
         prEyes = eyes;
      }

      return;
   }

   SetNose(Nose=$)
   {
      if Nose <> $
      {
         prNose = Nose;
      }

      return;
   }

   SetMouth(Mouth=$)
   {
      if Mouth <> $
      {
         prMouth = Mouth;
      }

      return;
   }

   GetHeadRsc()
   {
      return prHead;
   }

   GetEyesRsc()
   {
      return prEyes;
   }

   GetMouthRsc()
   {
      return prMouth;
   }

   GetNoseRsc()
   {
      return prNose;
   }

   GetHairRsc()
   {
      return prToupee;
   }

   GetLeftArmRsc()
   {
      return prLeft_arm;
   }

   GetRightArmRsc()
   {
      return prRight_arm;
   }

   GetLegsRsc()
   {
      return prLegs;
   }

   GetExpression()
   {
      return piAction;
   }

   GetShieldRsc()
   {
      local i;

      foreach i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlay);
         }
      }

      return $;
   }

   GetShieldOverlayHotspot()
   {
      local i;
      
      foreach i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlayHotspot);
         }
      }

      return $;
   }

   GetShieldTranslation()
   {
      local i;

      foreach i in plOverlays
      {
         if IsClass(i,&GuildShield)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }

      return 0;
   }

   GetOverlays()
   {
      return plOverlays;
   }

   IsLoggedOn()
   {
      return pbLogged_on;
   }

   ClearQuestHistory()
   "Stubbed here, since variable is defined in user - DOH!"
   "(real function is also in user.kod)"
   {
      return;
   }

   ResetLoggedOffMonsterChasers()
   "For admin mode - resets monster chasers for logged off players."
   {
      if (NOT pbLogged_on)
      {
         piMonsterChasers = 0;
      }

      return;
   }

   ResetMonsterChasers()
   {
      piMonsterChasers = 0;

      return;
   }

   AddToMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers + level;

      return;
   }

   SubtractFromMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers - level;

      return;
   }

   GetMonsterChasers()
   {
      return piMonsterChasers;
   }

   SomeoneSaid(what=$,type=$,string=$,parm1=$,parm2=$,
               parm3=$,parm4=$,parm5=$,parm6=$,parm7=$,parm8=$)
   {
      local oSnoop;

      if type = SAY_NORMAL AND IsClass(what,&Player)
      {
         // si: removed (and what <> self) to allow communication
         // between shrunken head and owner.
         oSnoop = GetListElemByClass(plPassive,&ShrunkenHead);
         if oSnoop <> $
         {
            Send(oSnoop,@SomeoneOverheard,#from=what,#to=self,#string=string);
         }
      }

      propagate;
   }

   SomeoneOverheard(from=$,to=$,type=$,string=$)
   {
      return;
   }

   RemoveInaccessibleSpells()
   {
      local num, i, oSpell, iability;

      foreach i in plSpells
      {
         num = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=num);
         if NOT Send(oSpell,@IsAccessible)
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            Send(self,@RemoveSpell,#num=num);
         }
      }

      Send(self,@ToCliStats,#group=3);
      Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      return;
   }

   ResetPlayerView()
   {
      AddPacket(1,BP_RESET_VIEW);
      SendPacket(poSession);

      return;
   }

   SetPlayerView(what = $, iFlags = 0, iHeight = 0, iLight = 0)
   {
      if what = $
      {
         Send(self,@ResetPlayerView);
      }
      else
      {
         AddPacket(1,BP_SET_VIEW, 4,what, 4,iFlags, 4,iHeight, 1,iLight);

         SendPacket(poSession);
      }

      return;
   }

   // Removes the shirt.  Used by the WarEvent event.
   RemoveShirt()
   {
      local i;
      
      foreach i in plUsing
      {
         if IsClass(i,&ShirtBase)
            OR IsClass(i,&LightRobe)
            OR IsClass(i,&Robe)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   BondItem(what=$)
   {
      if what = $ OR NOT IsClass(what,&Item)
      {
         Debug("Tried to bond to invalid item.");
      }

      if Send(what,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         //  this should only be possible through Admin fiddling
         return Send(SYS,@GetFailureRsc);
      }

      if poBondedItem <> $
      {
         Send(self,@ClearBondedItem);
      }

      poBondedItem = what;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@AddtoItem,
           #oItem=poBondedItem,#oPlayer=self);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      return;
   }

   ClearBondedItem()
   {
      local oldBondedItem;

      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      if poBondedItem = $
      {
         return;
      }

      oldBondedItem = poBondedItem;
      poBondedItem = $;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@RemoveFromItem,
            #oItem=oldBondedItem);

      return;
   }

   BondedItemReport()
   {
      ptBondedItemReport = $;
      if poBondedItem = $
      {
         Debug("trying to report location with no bonded item!");

         return;
      }

      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),
           @BondedItemReport,#BondedItem=poBondedItem,#BondedPlayer=self);

      return;
   }

   IsUndead()
   {
      return Send(self,@IsUsingA,#class=&NecromancerAmulet);
   }

   UpdateTimeValues()
   "Sets all time variables to the current time.  Useful for when changing "
   "server time."
   {
      local time;

      // Reset our attack timer, a traditional use of this function when attack
      //  time was a timestamp instead of a timer.

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      time = GetTime();

      // Can be 0 if never died.
      if (piLastDeathTime > 0)
      {
         piLastDeathTime = time;
      }

      // Set to 0, so we don't cause any guild join delays.
      piGuildRejoinTimestamp = 0;

      // Can be 0 for non-created players.
      if (piLast_restart_time > 0)
      {
         piLast_restart_time = time;
      }

      if (piFactionTimeUpdated > 0)
      {
         piFactionTimeUpdated = time;
      }

      piTimeLastStomachUpdate = 0;
      piTimeAttackedPlayer = 0;
      piTimeAttackedByPlayer = 0;
      piTimeLastMurder = 0;
      piReward_timestamp = 0;

      return;
   }

   IsInSameRoom(what = $)
   "Determine if given object is in same room as we are."
   {
      local what_owner, found;

      if poOwner = $ OR what = $
      {
         return FALSE;
      }

      found = FALSE;
      what_owner = Send(what,@GetOwner);
      while what_owner <> $
      {
         if what_owner = poOwner
         {
            found = TRUE;
            break;
         }
         what_owner = Send(what_owner,@GetOwner);
      }

      return found;
   }

   AddDonationYear(year = $)
   "Add to the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      local y;

      // Already in the list?
      foreach y in plDonationYears
      {
         if y = year
         {
            return;
         }
      }

      plDonationYears = Cons(year, plDonationYears);

      return;
   }

   RemoveDonationYear(year = $)
   "Remove from the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      plDonationYears = DelListElem(plDonationYears, year);

      return;
   }

   SetLoadoutList(set_list = $)
   {
      plLoadout_list = set_list;

      return;
   }

   GetLoadoutList()
   {
      return plLoadout_list;
   }

   BindPlayerToCurrentLocation()
   "Saves the player's current location as a special teleport destination."
   {
      if poOwner = $
      {
         return;
      }

      piBound_Room = Send(poOwner,@GetRoomNum);
      piBound_row = piRow;
      piBound_col = piCol;
      piBound_fine_row = piFine_row;
      piBound_fine_col = piFine_col;
      piBound_angle = Send(self,@GetAngle);

      return;
   }

   SendPlayerToBoundLocation()
   "Sends the player to their saved teleport destination."
   {
      if poOwner = $
         OR piBound_Room = $
         OR NOT pbLogged_on
      {
         return;
      }

      Send(SYS,@UtilGoNearSquare,#what=self,
            #where=Send(SYS,@FindRoomByNum,#num=piBound_room),
            #new_row=piBound_row,#new_col=piBound_col,
            #fine_row=piBound_fine_row,#fine_col=piBound_fine_col,
            #new_angle=piBound_angle, #max_distance=3);

      return;
   }

   GetBoundLocationName()
   {
      if piBound_room <> $
      {
         return Send(Send(SYS,@FindRoomByNum,#num=piBound_room),@GetName);
      }

      return $;
   }

   GetBoundLocationRoomNum()
   {
      return piBound_room;
   }

   GetBoundLocationRow()
   {
      return piBound_row;
   }

   GetBoundLocationCol()
   {
      return piBound_col;
   }

   SetDeathRiftProtection(value=FALSE)
   {
      if value
      {
         if poOwner <> $
            AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         {
            // Only allow Death Rift Protection for those already
            // logged on and in the Underworld
            piFlags = piflags | PFLAG_DEATH_RIFTING;

            return;
         }
      }
      else
      {
         if ptDeathRiftTimer <> $
         {
            DeleteTimer(ptDeathRiftTimer);
            ptDeathRiftTimer = $;
         }
         piFlags = piflags & ~PFLAG_DEATH_RIFTING;
      }

      return;
   }

   StartDeathRiftTimer()
   {
      ptDeathRiftTimer = CreateTimer(self,@DeathRiftBoot,DEATH_RIFT_INTERVAL);

      return;
   }

   DeathRiftBoot()
   "Players that linger too long will find themselves cast "
   "out of the Underworld."
   {
      ptDeathRiftTimer = $;

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         AND (piflags & PFLAG_DEATH_RIFTING)
      {
         Send(self,@AdminGoToSafety);

         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=death_rift_stayed_too_long);
         }
      }

      return;
   }

   LeaveBuilderGroupTimer()
   {
      ptLeaveBuilderGroupTimer = $;

      Send(self,@LeaveBuilderGroup);

      return;
   }

   LeaveBuilderGroup()
   {
      local i, each_obj;

      if ptLeaveBuilderGroupTimer <> $
      {
         DeleteTimer(ptLeaveBuilderGroupTimer);
         ptLeaveBuilderGroupTimer = $;
      }

      if poOwner <> $
      {
         Send(poOwner,@RemoveFromBuilderGroup,#who=self);
         Send(poOwner,@SomethingChangedFlags,#what=self);

         // Let's see that we left the group
         foreach i in Send(poOwner,@GetPlActive)
         {
            each_obj = First(i);
            if IsClass(each_obj,&User)
               AND Send(poOwner,@AreGroupedHere,#who=self,#what=each_obj)
            {
               Send(self,@SomethingChangedFlags,#what=each_obj);
            }
         }
      }

      return;
   }

   JoinBuilderGroup()
   {
      local i, each_obj;

      // Refresh an active group membership
      if ptLeaveBuilderGroupTimer <> $
      {
         DeleteTimer(ptLeaveBuilderGroupTimer);
         ptLeaveBuilderGroupTimer = CreateTimer(self,@LeaveBuilderGroupTimer,
                                       Send(poOwner,@GetGroupTime));

         return;
      }

      if poOwner <> $
      {
         Send(poOwner,@AddToBuilderGroup,#who=self);
         Send(poOwner,@SomethingChangedFlags,#what=self);
         ptLeaveBuilderGroupTimer = CreateTimer(self,@LeaveBuilderGroupTimer,
                                       Send(poOwner,@GetGroupTime));

         // Let's see our new group
         foreach i in Send(poOwner,@GetPlActive)
         {
            each_obj = First(i);
            if IsClass(each_obj,&User)
               AND Send(poOwner,@AreGroupedHere,#who=self,#what=each_obj)
            {
               Send(self,@SomethingChangedFlags,#what=each_obj);
            }
         }
      }

      return;
   }

   IsCrystalizeManaSurging()
   {
      return piFlags2 & PFLAG2_CRYST_MANA_SURGE;
   }

   StartCrystalizeManaSurge(surge_time=1000)
   {
      if ptCrystalizeManaSurgeTimer = $
      {
         ptCrystalizeManaSurgeTimer =
               CreateTimer(self,@EndCrystalizeManaSurgeTimer,surge_time);
         piFlags2 |= PFLAG2_CRYST_MANA_SURGE;
         Send(self,@ComputeMaxMana);
      }

      return;
   }

   EndCrystalizeManaSurgeTimer()
   {
      if ptCrystalizeManaSurgeTimer <> $
      {
         ptCrystalizeManaSurgeTimer = $;
      }

      Send(self,@EndCrystalizeManaSurge);

      return;
   }

   EndCrystalizeManaSurge()
   {
      if ptCrystalizeManaSurgeTimer <> $
      {
         DeleteTimer(ptCrystalizeManaSurgeTimer);
         ptCrystalizeManaSurgeTimer = $;
      }

      Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSpellByNum,
            #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
      piFlags2 &= ~PFLAG2_CRYST_MANA_SURGE;
      Send(self,@ComputeMaxMana);

      return;
   }

   GetManaSurgeTimer()
   {
      return ptCrystalizeManaSurgeTimer;
   }

   RechargeAllRods()
   {
      local i, bGainedCharges;

      bGainedCharges = FALSE;

      foreach i in plPassive
      {
         if IsClass(i,&Rod)
            AND Send(i,@FullyRecharge)
         {
            bGainedCharges = TRUE;
         }
      }

      if bGainedCharges
      {
         Send(self,@MsgSendUser,#message_rsc=rods_recharged_by_safe_place_msg);
      }

      return;
   }

   // Not in use anymore (2017-04-12)
   CommandMinionAttack(oTarget=$)
   {
      local oActive;

      // If we have minions, we only want them to attack Battlers,
      // not items or anything else that can damage us.
      if plControlledMinions = $
         OR oTarget = $
         OR oTarget = self
         OR NOT IsClass(oTarget,&Battler)
         OR IsClass(oTarget,&Revenant)
      {
         return;
      }

      // Lets not have the minions kill each other. Check if the target is
      // a minion under our control.
      if IsClass(oTarget,&Monster)
         AND Send(oTarget,@GetMaster) = self
      {
         return;
      }

      // Check here for phase/spectate, as calling AllowBattlerAttack with
      // actual=FALSE will bypass that check for accurate minimap dots.
      // It is unlikely we still even have minions if phased, but better to
      // be safe here.
      if (Send(self,@IsInCannotInteractMode))
      {
         return;
      }

      if Send(self,@AllowBattlerAttack,#victim=oTarget,#actual=FALSE)
      {
         foreach oActive in plControlledMinions
         {
            if IsClass(oActive,&Monster)
               AND Send(oActive,@GetMaster) = self
               AND Send(oActive,@GetTarget) <> oTarget
            {
               Send(oActive,@TargetSwitch,#what=oTarget,
                     #iHatred=100);
               Send(oActive,@EnterStateEngage,#target=oTarget,
                     #actnow=TRUE);
            }
         }
      }

      return;
   }

   // Mercenary related messages...
   GetMercenary()
   {
      return poMercenary;
   }

   // Validity checks are handled on the side of the mercenary.
   SetMercenary(oMercenary=$)
   {
      poMercenary = oMercenary;

      return;
   }

   MercenarySentAway()
   {
      if poMercenary = $
      {
         poMercenary = CreateTimer(self,@MercenaryTimer,300000);
      }

      return;
   }

   MercenaryTimer()
   {
      poMercenary = $;

      return;
   }

   SumDamageReduction()
   {
      local iArmor, d;

      iArmor = 0;

      foreach d in plDefense_modifiers
      {
         if IsClass(d,&DefenseModifier)
         {
            iArmor = iArmor + Send(d,@GetDamageReduction);
         }

         if IsClass(d,&ArmorOfGort)
         {
            iArmor = iArmor + (Send(self,@GetEnchantedState,#what=d) / 25);
         }
      }

      return iArmor;
   }

   CanEvilTwin()
   {
      return TRUE;
   }

   GetReagentBag()
   {
      return GetListElemByClass(plPassive,&ReagentBag);
   }

   GetReagentBagContents()
   {
      local oBag;

      oBag = GetListElemByClass(plPassive,&ReagentBag);
      if oBag <> $
      {
         return Send(oBag,@GetReagentBagContents);
      }

      return $;
   }

   StartPhaseTimer()
   {
      local i;

      // If phase time regen timer is active, delete it.
      if (ptPhaseRegenTimer <> $)
      {
         DeleteTimer(ptPhaseRegenTimer);
         ptPhaseRegenTimer = $;
      }

      if ptPhaseTimer = $
      {
         ptPhaseTimer = CreateTimer(self,@PhaseTimerEnd,piRemainingPhaseTime);

         // Stop any rescue attempts if the user phases out.
         if ptRescue <> $
         {
            Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue_phase);
            DeleteTimer(ptRescue);
            ptRescue = $;
         }
      }

      Send(self,@PhaseVisualEffectTimer);

      // Add phase time to piTimeAttackedPlayer if it is currently
      // preventing the player from casting escape spells.
      if piTimeAttackedPlayer + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer += (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }

   PhaseVisualEffectTimer(timer = $)
   {
      local iTimeLeft;

      if ptPhaseVisualEffectTimer <> $
      {
         if ptPhaseVisualEffectTimer <> timer
         {
            DeleteTimer(ptPhaseVisualEffectTimer);
         }
         ptPhaseVisualEffectTimer = $;
      }

      iTimeLeft = Send(Send(SYS,@FindSpellByNum,#num=SID_PHASE),
                        @AdjustVisualEffectBasedOnTimeRemaining,#who=self);

      if ptPhaseVisualEffectTimer = $
         AND (piFlags & PFLAG_PHASED)
         AND iTimeLeft > 0
      {
         ptPhaseVisualEffectTimer = CreateTimer(self,@PhaseVisualEffectTimer,iTimeLeft);
      }

      return;
   }

   FreezePhaseTimer()
   {
      if ptPhaseTimer <> $
      {
         piRemainingPhaseTime = GetTimeRemaining(ptPhaseTimer);
         DeleteTimer(ptPhaseTimer);
         ptPhaseTimer = $;
         
         if ptPhaseVisualEffectTimer <> $
         {
            DeleteTimer(ptPhaseVisualEffectTimer);
            ptPhaseVisualEffectTimer = $;
         }
      }

      // If we added phase time to piTimeAttackedPlayer before,
      // remove what is remaining (restore to original time).
      if piTimeAttackedPlayer + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer -= (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      // Possibly start phase time regen.
      if (ptPhaseRegenTimer <> $)
      {
         DeleteTimer(ptPhaseRegenTimer);
      }
      // 5 sec delay so phasing in/out doesn't regen time.
      ptPhaseRegenTimer = CreateTimer(self,@RegenPhaseTime,5000);

      return;
   }

   RegenPhaseTime(timer = $)
   {
      local iBaseTime;

      if (ptPhaseRegenTimer <> timer)
      {
         DeleteTimer(ptPhaseRegenTimer);
      }
      ptPhaseRegenTimer = $;

      if (Send(self,@IsOfflineOrCannotInteract))
      {
         return;
      }

      iBaseTime = Send(self,@GetBasePhaseTime);

      // Add time in 3 second increments to reduce timers needed.
      piRemainingPhaseTime = Bound(piRemainingPhaseTime + 3000,0,iBaseTime);

      // Make another timer if we are still regenerating phase time.
      if (piRemainingPhaseTime < iBaseTime)
      {
         ptPhaseRegenTimer = CreateTimer(self,@RegenPhaseTime,3000);
      }

      return;
   }

   PhaseTimerEnd(timer = $)
   {
      local oPhase;

      if (timer = $
         OR timer <> ptPhaseTimer)
      {
         DeleteTimer(ptPhaseTimer);
      }

      ptPhaseTimer = $;

      if ptPhaseVisualEffectTimer <> $
      {
         DeleteTimer(ptPhaseVisualEffectTimer);
         ptPhaseVisualEffectTimer = $;
      }

      Send(self,@RefreshPhaseTimeToBase);

      oPhase = Send(SYS,@FindSpellByNum,#num=SID_PHASE);
      Send(self,@RemoveEnchantment,#what=oPhase);
      Send(oPhase,@InflictPenalties,#who=self);

      Post(self,@AdminGoToLastSafeRoom);

      return;
   }

   GetRemainingPhaseTime()
   {
      if ptPhaseTimer <> $
      {
         return GetTimeRemaining(ptPhaseTimer);
      }

      return piRemainingPhaseTime;
   }

   GetBasePhaseTime()
   {
      if (piFlags & PFLAG_MURDERER)
         OR (piFlags & PFLAG_OUTLAW)
      {
         return Send(SETTINGS_OBJECT,@GetOutlawMurdererLogPenGhostTime);
      }

      return Send(SETTINGS_OBJECT,@GetLogPenGhostTime);
   }

   RefreshPhaseTimeToBase()
   {
      if piRemainingPhaseTime <> Send(self,@GetBasePhaseTime)
      {
         piRemainingPhaseTime = Send(self,@GetBasePhaseTime);
      }

      return;
   }

   SetPhaseTimeEqualTo(amount=60000)
   "Used by logoff ghosts to sync up penalty times."
   {
      piRemainingPhaseTime = amount;

      // Logoff ghosts call this when the player returns, so we remove
      // the phase time remaining from piTimeAttackedPlayer here if we
      // added it when the user logged off.
      if piTimeAttackedPlayer + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer -= (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }

   IsAtMaxPhaseTime()
   {
      return piRemainingPhaseTime = Send(self,@GetBasePhaseTime);
   }

   CanPhaseAgain(time=$)
   {
      if ptCanPhaseTimer <> $
      {
         return FALSE;
      }

      if time > 0
      {
         ptCanPhaseTimer = CreateTimer(self,@CanPhaseTimer,time);
      }

      return TRUE;
   }

   CanPhaseTimer()
   {
      ptCanPhaseTimer = $;

      return;
   }

   GetLastAttackedByPlayerTime()
   {
      return piTimeAttackedByPlayer;
   }

   DoPvpNotify()
   {
      local iTime, iNotify;

      iTime = GetTime();
      iNotify = iTime - PVP_NOTIFY_DECAY;

      // Don't gong if we are already in pvp
      if (piTimeAttackedPlayer < iNotify
         AND piTimeAttackedByPlayer < iNotify
         AND poOwner <> $)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=pvp_notify_wav);
      }

      // Set our attacked-by time here.
      piTimeAttackedByPlayer = iTime;

      return;
   }

   GetTimeLastMurder()
   {
      return piTimeLastMurder;
   }

   // Use this for when either phase or spectator do the same thing
   IsInCannotInteractMode()
   {
      return (piFlags & PFLAG_PHASED) OR (piFlags & PFLAG_SPECTATOR);
   }

   // Use this when something should check whether a player has
   // 'exited play' by logging, being spectated, or phasing.
   // Basically IsInCannotInteractMode() or logged off.
   IsOfflineOrCannotInteract()
   {
      return (NOT pbLogged_on)
         OR (piFlags & PFLAG_PHASED)
         OR (piFlags & PFLAG_SPECTATOR);
   }

   IsLikelyVictim()
   {
      if Send(self,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      propagate;
   }

   // Ends maintained spells, most likely because we ran out of mana.
   CancelMaintainedSpells()
   {
     Send(self,@BreakTrance,#event=EVENT_OOM);

     propagate;
   }

   ZeroVigor()
   "Uh oh! Are we in trouble?"
   {
      local i;

      // Unequip ring of lethargy.
      foreach i in plUsing
      {
         if IsClass(i,&RingofLethargy)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   DeathOverTime()
   "Player is dying to damage over time."
   {
      local oEffect, iStrength, use_weapon, oKiller, i, each_obj;

      // The strength of the DoT. We are looking at
      // negative values here.
      iStrength = 0;

      // The source of the dot as well as the associated spell.
      // If no source/spell have been associated with the dot,
      // 0 - not nil - is passed.
      oKiller = 0;
      use_weapon = 0;

      // Let's check who pained us most.
      foreach i in Send(self,@GetOverTimeEffects)
      {
         oEffect = Nth(i,5);

         if (Nth(i,3) < iStrength)
            AND Send(oEffect,@IsLethal,#who=self)   // Not all effects are lethal.
            AND Nth(i,10) = FALSE                   // ...or real.
         {
            oKiller = Nth(i,6);
            use_weapon = oEffect;
            iStrength = Nth(i,3);
         }
      }

      // Looks like we only had a mild case of death after all...
      if iStrength = 0
      {
         return;
      }

      // Convert 0 to regular nil for further processing.
      // To-do: Check for more elegant solution.
      if use_weapon = 0
      {
         use_weapon = $;
      }

      if oKiller = 0
      {
         oKiller = $;
      }

      if oKiller <> $
      {
         Send(oKiller,@KilledSomething,#what=self,#use_weapon=use_weapon);
      }
      else
      {
         Send(self,@KilledSomething,#what=self,#use_weapon=use_weapon);
      }

      return;
   }

   GetStealth(what=$)
   {
      local iStealth, iLight;

      if (what = $) OR (poOwner = $)
      {
         return FALSE;
      }

      if ((Abs(piLastMoveUpdateTime - GetTickCount()) >=
            Send(SETTINGS_OBJECT,@GetStealthDelay))
         OR (Send(self,@GetTimeSinceLogin) <=
            (Send(SETTINGS_OBJECT,@GetStealthDelay) / 1000)))
         AND (ptAttackTimer = $)
      {
         return 300;
      }

      // Stealth is primarily based on our agility and intellect.
      iStealth = 2 * Send(self,@GetAgility) + Send(self,@GetIntellect);

      // Sneaking increases stealth.
      if (Send(self,@GetSpeed) < 1000)
      {
         iStealth += 100;
      }

      // Invisibility grants greatly increased stealth.
      if Send(self,@IsInvisible)
      {
         iStealth += 200;
      }

      // Shadowform grants slightly increased stealth.
      if Send(self,@IsShadowForm)
      {
         iStealth += 50;
      }

      // A blind target has a very hard time spotting enemies.
      if Send(what,@IsEnchanted,#byClass=&Blind)
         OR Send(what,@IsEnchanted,#byClass=&Dazzle)
      {
         iStealth += 200;
      }

      iLight = Send(poOwner,@GetRoomLight);
      iLight += Send(what,@GetLightLevel);

      iStealth += Bound(155 - iLight,-100,150);

      return Bound(iStealth,0,300);
   }

   IsAlly(target=$)
   {
      local oTargetMaster;

      if (target = $)
         OR NOT IsClass(target,&Battler)
      {
         return FALSE;
      }

      if (target = self)
      {
         return TRUE;
      }

      // All other alliances are off for arena.
      if (poOwner <> $
         AND Send(poOwner,@IsArena))
      {
         return FALSE;
      }

      oTargetMaster = Send(target,@GetMaster);

      if (oTargetMaster <> $)
      {
         return Send(self,@IsAlly,#target=oTargetMaster);
      }

      return Send(self,@IsAlliedClass,#what=target);
   }

   IsAlliedClass(what=$)
   {
      local iFaction;

      if IsClass(what,&Battler)
      {
         // Let's get the target's faction.
         iFaction = Send(what,@GetFaction);

         // If we aren't neutral ourselves, we are
         // allied with targets of the same faction.
         if piFaction <> FACTION_NEUTRAL
         {
            if (iFaction = piFaction)
            {
               return TRUE;
            }
         }
         // If we are neutral, we are allied with all
         // troops, as long as they aren't necromancers.
         else if IsClass(what,&FactionTroop)
            AND (iFaction <> FACTION_NECROMANCER)
            AND (poKill_target <> what
               AND Send(what,@GetTarget) <> self)
         {
            return TRUE;
         }
      }

      if IsClass(what,&Follower)
         AND ((what = poMercenary)
            OR (piBase_max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)))
      {
         return TRUE;
      }

      return FALSE;
   }

   CreateFollower(iDifficulty=$,iGender=$,bContracted=FALSE)
   {
      local oFollower;

      if (poMercenary <> $)
      {
         if IsTimer(poMercenary)
         {
            DeleteTimer(poMercenary);
            poMercenary = $;
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_already_leader);

            return FALSE;
         }
      }

      oFollower = Create(&Follower,#oLeader=self,#iLevel=piBase_Max_Health,
                     #iDifficulty=iDifficulty,#iGender=iGender);

      Send(poOwner,@NewHold,#what=oFollower,#new_row=piRow+2,#new_col=piCol+2,
                          #fine_row=piFine_row,#fine_col=piFine_col);

      Send(oFollower,@SetLeader,#oLeader=self,#bContracted=bContracted);

      Send(oFollower,@FollowerDing,#bCreation=TRUE);

      Send(oFollower,@FaceLeader);

      Send(oFollower,@DoWave);

      return TRUE;
   }

   CountsAsMonster()
   {
      return FALSE;
   }

   CountsAsHero()
   {
      return TRUE;
   }

   IsLegitimateSpawn()
   {
      return TRUE;
   }

   StoreFollower()
   {
      if (poMercenary <> $)
         AND IsClass(poMercenary,&Follower)
      {
         poSavedFollower = poMercenary;
         poMercenary = $;
      }

      return;
   }

   RestoreFollower()
   {
      if (poSavedFollower <> $)
      {
         if (poMercenary <> $)
         {
            Send(poMercenary,@SetLeader,#report=FALSE);
         }

         poMercenary = poSavedFollower;
      }

      return;
   }

   TransferHonorPoints(what = $, who = $, honor = 0)
   {
      // Attempts to transfer honor points from 'who' to 'what'
      local iHonor;

      if who = $
         OR what = $
      {
         Debug("Attempted to transfer honor points from ",who," to ",what,".");

         return;
      }

      iHonor = 0;

      // Does the victim have any honor points to transfer?
      if piHonorPoints = 0
      {
         iHonor = 0;
         //Debug("Honor is 0");
      }
      else if NOT Send(who,@CanParticipateInHonorSystem)
              OR NOT Send(what,@CanParticipateInHonorSystem)
      {
         iHonor = 0;
         //Debug("Attacker or victim don't qualify for honor system.");
      }
      // No honor in attacking your own character!
      else if Send(SETTINGS_OBJECT,@NoHonorSameIP)
              AND IsListMatch(Send(who,@GetIP),Send(what,@GetIP))
      {
         iHonor = 0;
         Debug(what, "tried to gain honor from ",who," - both have the same IP.");
      }
      // Don't award honor if the victim died recently.
      else if GetTime() < (piLastDeathTime + Send(SETTINGS_OBJECT,@GetHonorDeathTime))
      {
         iHonor = 0;
         //Debug("Victim died too recently.");
      }
      // Don't award honor if the victim took too many penalties recently.
      else if Send(who,@GetLogoffPenaltyCount) > Send(SETTINGS_OBJECT,@GetHonorMaxPenalty)
      {
         iHonor = 0;
         Debug("Honor system: Victim ",Send(who,@GetTrueName),
               " took too many penalties recently, no points awarded.");
      }
      // They have some, but not the full amount. Grab the rest.
      else if piHonorPoints < honor
      {
         iHonor = piHonorPoints;
         //Debug("piHonor is < Honor");
      }
      // The victim can pay the full cost.
      else
      {
         iHonor = honor;
      }

      //Debug("Points transferred: ",iHonor," out of original ",honor);
      if iHonor <> 0
      {
         // Keep track so we notice any suspicious activity.
         // If we had SQL setup, that would be a better place to log this.
         Debug("Transferred ",iHonor," from ",Send(who,@GetTrueName),
               " to ", Send(what,@GetTrueName));
         Send(who,@AddHonorPoints,#who=who,#honor=-iHonor);
         Send(what,@AddHonorPoints,#who=what,#honor=iHonor);
      }

      return iHonor;
   }

   AddHonorPoints(who = $, honor = 0)
   {
      piHonorPoints += honor;
      piLastHonorChangeTime = GetTime();
      Send(SYS, @UpdateHonorPoints,#who=who);

      return;
   }

   GetHonorPoints()
   {
      return piHonorPoints;
   }

   SetHonorPoints(honor = 0)
   {
      piHonorPoints = honor;

      return;
   }

   SetHonorRank(rank = 0)
   {
      piHonorRank = rank;

      return;
   }

   CanParticipateInHonorSystem()
   {
      // Checks whether a player can participate in the honor system.
      if NOT Send(SETTINGS_OBJECT,@HonorSystemActive)
      {
         return FALSE;
      }

      if (piFlags & PFLAG_PERMA_NO_PVP)
      {
         return FALSE;
      }

      // Unused character slots aren't counted.
      if Send(self,@GetLastLoginTime) = 0
      {
         return FALSE;
      }

      // Use level (base max HP).
      if Send(self,@GetBaseMaxHealth) < Send(SETTINGS_OBJECT,@GetHonorMinHP)
      {
         return FALSE;
      }

      if Send(self,@GetTotalLearnPoints) < Send(SETTINGS_OBJECT,@GetHonorMinLevels)
      {
         return FALSE;
      }

      return TRUE;
   }

   ShowHonorTitle(iTitle=0)
   {
      if iTitle = 0
      {
         piHonorTitle = 0;
         Send(self,@MsgSendUser,#message_rsc=player_honor_title_off);
      }
      else if iTitle = 1
      {
         piHonorTitle = 1;
         Send(self,@MsgSendUser,#message_rsc=player_honor_title_on);
      }
      else if iTitle = 2
      {
         piHonorTitle = 2;
         Send(self,@MsgSendUser,#message_rsc=player_honor_title_alt);
      }

      return;
   }

   IsUserHonorInactive()
   {
      // Returns TRUE if the player hasn't gained or lost points in the past 60 days.
      return ((GetTime() - piLastHonorChangeTime) > USER_HONOR_INACTIVE_TIME);
   }

   PeriodicSounds(timer=$,bSuspend=FALSE)
   {
      local i, j, rSound, oEffect, lSound, tTimer;

      if bSuspend
      {
         foreach i in plPeriodicSounds
         {
            if First(i) <> $
            {
               DeleteTimer(First(i));
               SetFirst(i,$);
               SetNth(i,2,$);
               plPeriodicSounds = DelListElem(plPeriodicSounds,i);
            }
         }

         return;
      }

      if timer <> $
      {
         foreach i in plPeriodicSounds
         {
            if First(i) = timer
            {
               if NOT Send(self,@HasOverTimeEffect,#what=Nth(i,2))
               {
                  rSound = Send(Nth(i,2),@GetPeriodicSoundEnd);
               }

               SetFirst(i,$);
               SetNth(i,2,$);
               plPeriodicSounds = DelListElem(plPeriodicSounds,i);

               if rSound = $
               {
                  continue;
               }

               Send(self,@WaveSendUser,#wave_rsc=rSound);
            }
         }
      }

      foreach j in plOverTimeEffects
      {
         oEffect = Nth(j,5);

         if (oEffect <> 0) AND IsClass(oEffect,&Spell)
         {
            rSound = Send(oEffect,@GetPeriodicSound);
         }
         else
         {
            continue;
         }

         if rSound = $
         {
            continue;
         }

         if (GetListNode(plPeriodicSounds, 2, oEffect) = $)
         {
            tTimer = CreateTimer(self,@PeriodicSounds,
               Send(oEffect,@GetPeriodicSoundDuration));
            lSound = [tTimer,oEffect];
            plPeriodicSounds = Cons(lSound,plPeriodicSounds);
            Send(self,@WaveSendUser,#wave_rsc=rSound);
         }
      }

      return;
   }

   // Returns the spell that is currently in the process of being cast.
   GetTranceAbility()
   {
      local lState;

      lState = Send(self,@GetEnchantedState,
         #what=Send(SYS,@FindSpellByNum,#num=SID_TRANCE));

      if lState <> $
      {
         return First(lState);
      }

      return;
   }

   SetTranceTime(time=0,bAdd=FALSE)
   "Override the current trance timer with specified value."
   {
      local i, tTimer;

      foreach i in plEnchantments
      {
         if IsClass(Nth(i,2),&Trance)
         {
            tTimer = First(i);
         }
         else
         {
            continue;
         }

         if bAdd
         {
            time += GetTimeRemaining(tTimer);
         }

         DeleteTimer(tTimer);

         tTimer = $;

         if time
         {
            tTimer = CreateTimer(self,@EnchantmentTimer,time);
         }

         SetFirst(i,tTimer);

         return TRUE;
      }

      return FALSE;
   }

   SetTranceFocus(focus=0,bAdd=FALSE)
   "Override the current trance timer with specified value."
   {
      local lState;

      lState = Send(self,@GetEnchantedState,
         #what=Send(SYS,@FindSpellByNum,#num=SID_TRANCE));

      if lState <> $
      {
         if bAdd
         {
            focus = Bound(focus+Nth(lState,6),0,$);
         }

         SetNth(lState,6,focus);

         return focus;
      }

      return;
   }

end
////////////////////////////////////////////////////////////////////////////////
