// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
User is Player

constants:

   include blakston.khd
   include protocol.khd

   // parameter to ToCliObject

   SHOW_NORMAL = 1
   SHOW_LOOK = 2
   SHOW_INVENTORY = 3
   SHOW_ENCHANTMENT = 4
   SHOW_CHANGE = 5

   GOOD_COLOR = 82
   BAD_COLOR =  83

   // How much wait between suicides?  Curently 10 minutes.
   SUICIDE_REPEAT_TIME = 600 

   // What's the length of the Posting timer check? Currently 30 mins.
   NEWS_POSTING_DELAY = 30 * 60
   // How many times can we Post during the delay?
   NEWS_POSTING_LIMIT = 2
   // how long can news messages be
   NEWS_POSTING_MAX_LENGTH = 4096
   // Max subject length client can handle.
   NEWS_POSTING_MAX_SUBJECT_LENGTH = 50

   // how long a mail message may be (the client currently can;t handle > 4096)
   MAIL_MESSAGE_MAX_LENGTH = 4096
   
   // How long since last login before someone is considered "inactive"?
   //  This is measured in seconds.  Currently 60 days.
   //  This is used because the user objects have no concept of suspended
   //  accounts.
   USER_INACTIVE_TIME = 60 * 60 * 24 * 60

   // How many packets incoming per second do we allow?
   INCOMING_PACKET_THROTTLE = 25

   // Speedhack/cheating detection:
   // What's the maximum number of times we should log a violation?
   MAX_LOGGED_THRESHOLD = 50

   // Constants for stat groups sent in ToCliStats.
   STAT_GROUP_MAIN = 1
   STAT_GROUP_STATS = 2
   STAT_GROUP_SPELLS = 3
   STAT_GROUP_SKILLS = 4
   STAT_GROUP_QUESTS = 5

resources:

   include user.lkod

   user_name_rsc = "user name"

   user_garbage_collecting = "System is saving; please wait."
   user_garbage_collecting_done = "System save completed; resume play."
   user_saving_wav_rsc = system_save.ogg

   user_err_get_unk = "You can't pick up %s%s; it is no longer accessible."
   user_err_get_dist = "You can't pick up %s%s; it's too far away."
   user_disallow_get = "You're unable to pick up %s%s."
   user_got_some = "You can't pick up all the %s."
   user_cant_pickup_item_wav_rsc = player_cannot_carry.ogg
   user_disallow_drop = "You are unable to drop %s%s."
   user_err_drop = "You're not holding that."
   user_err_put = "You can't put %s%s in %s%s; %s%s can't hold things!"
   user_disallow_put = "You're unable to put %s%s in %s%s."
   user_err_get_contents = "You can't look inside %s%s!"
   user_chest_too_far = "You can't look inside %s%s; it's too far away."

   user_err_activate_unk = \
      "You can't activate %s%s; it is no longer accessible."
   user_activate_failed = "You can't activate %s%s."

   user_cap_Someone_string = "Someone"
   user_Someone_string = "someone"
   user_blank_string = ""
   admin_icon_blank = blank.bgf

   user_said_str = "%s says, \"%q~n\""
   user_said_echo_str = "You say, \"%q~n\""
   user_yelled_str = "%s yells, \"%q~n\""
   user_yelled_nearby_str = "You hear %s yelling, \"%q~n\""
   user_yelled_echo_str = "You yell, \"%q~n\""
   user_broadcast_str = "%s broadcasts, \"%q~n\""
   user_broadcast_echo_str = "You broadcast, \"%q~n\""
   user_send_str = "%s sends, \"%q~n\""
   user_send_one_str = "%s tells you, \"%q~n\""
   user_said_resource_str = "%s%s says, \"%s~n\""
   user_emote_str = "%s %q"
   user_echo_str = "%q"

   user_send_echo_str = "You send, \"%q~n\""
   user_send_single_echo_str = "You tell %s, \"%q~n\""

   user_no_respond = \
      "~IDue to your state, this user may not be able to respond to you."

   user_said_str_morphed = "~n%s%s says, \"%q~n\""
   user_yelled_str_morphed = "~n%s%s yells, \"%q~n\""
   user_emote_str_morphed = "~n%s%s %q" 

   user_no_cast = "You find yourself unable to cast a spell."
   user_no_perform = "You find yourself unable to perform this action."
   user_no_fight = "You find yourself unable to lift your weapon."
   user_cant_mail_to = "Can't mail to nonexistent user %s."
   user_mail_to = "Sending mail."
   user_new_mail = "You have new mail from %s."
   user_new_nested_mail = "You have new mail."
   user_show_mail = "%q"
   user_show_nested_mail = "%s"
   user_logon_one_mail = "You have %i piece of new mail."
   user_logon_many_mail = "You have %i pieces of new mail."
   user_mail_squelched = "Your mail posting privileges have been revoked."
   user_mail_toobig = \
      "Sorry, that message was so large the courier died trying to carry it, "
      "delivery failed."
   user_mail_forcedignore = \
      "Not sending mail to %q due to server-enforced ignore."
   user_was_killed = \
      "You are dead, poor soul.  Go now, and take revenge on %s%s!"
   user_was_killed_bridge_faith = "Ouch, that last step was a doozy."

   user_is_resting = "You are sitting and resting."
   user_is_standing = "You are standing."

   user_stat_might = "Might"
   user_stat_intellect = "Intellect"
   user_stat_stamina = "Stamina"
   user_stat_agility = "Agility"
   user_stat_mysticism = "Mysticism"
   user_stat_aim = "Aim"
   user_stat_karma = "Karma"
   user_stat_capacity = "Weight Carried"
   user_stat_bulk = "Bulk Carried"
   user_stat_offense = "Offense"
   user_stat_defense = "Defense"
   user_stat_armor = "Armor"
   user_stat_training = "Training Pts"
   user_stat_unbound_energy = "Unbound Energy"

   user_resist_magic = "Magic Resist"
   user_resist_fire = "Fire Resist"
   user_resist_shock = "Shock Resist"
   user_resist_cold = "Cold Resist"
   user_resist_holy = "Holy Resist"
   user_resist_unholy = "Unholy Resist"
   user_resist_acid = "Acid Resist"
   user_resist_quake = "Quake Resist"
   user_resist_nerudite = "Nerudite"
   user_resist_silver = "Silver"
   user_resist_unarmed = "Unarmed"
   user_resist_punch = "Punch"
   user_resist_kick = "Kick"
   user_resist_hunt = "Hunt Sword"
   user_resist_claw = "Claw"
   user_resist_bite = "Bite"
   user_resist_sting = "Sting"
   user_resist_ichor = "Ichor"
   user_resist_weapons = "Weapon Resist"
   user_resist_weapon_nonmagic = "Mundane"
   user_resist_weapon_magic = "Enchanted"
   user_resist_hit = "Hit"
   user_resist_bludgeon = "Bludgeon Resist"
   user_resist_pierce = "Pierce Resist"
   user_resist_thrust = "Thrust Resist"
   user_resist_slash = "Slash Resist"
   user_resist_whip = "Whip"
   
   user_shal_power = "Shal'ille"
   user_qor_power = "Qor"
   user_faren_power = "Faren"
   user_kraanan_power = "Kraanan"
   user_riija_power = "Riija"
   user_jala_power = "Jala"

   user_stat_health = heal.bgf
   user_stat_mana = ankh.bgf
   user_stat_vigor = bolticon.bgf  //stickman.bgf
   user_stat_xp = exp.bgf

   user_group_condition = "Condition"
   user_group_stats = "Stats"
   user_group_spells = "Spells"
   user_group_skills = "Skills"
   user_group_quests = "Quests"

   user_active_quests_header = "Active Quests: "
   user_no_active_quests_header = "No Active Quests"
   user_completed_quests_header = "Completed Quests: "
   user_no_completed_quests_header = "No Completed Quests"
   user_failed_quests_header = "Failed Quests: "

   user_got_offer = "You have a trade offer from %s%s."
   user_cant_offer = "You can't offer to %s%s."
   user_cant_offer_arena = \
      "Trading is not permitted in gaming areas such as this."
   user_offer_busy = "%s%s can't deal with you now."
   user_cant_cancel_offer = "You can't cancel a nonexistent offer."
   user_canceled_offer = "%s%s canceled the offer."
   user_cant_counteroffer = "You can't counter a nonexistent offer."
   user_cant_acceptoffer = "You can't accept a nonexistent offer."
   user_dont_have_offer = \
      "Offer invalid, you don't have everything you offered."
   user_dont_have_number_offer = \
      "Offer invalid, you don't have enough of everything you offered."
   user_offer_too_many = "You can't offer that many %s!"
   user_cant_drop_offer = \
      "Realizing %s%s will not be given away, you cancel the offer."
   user_didnt_have_offer = \
      "Offer invalid, %s%s didn't have everything offered."
   user_didnt_drop_offer = \
      "%s%s tries to give you %s%s, but it doesn't seem to want to be given!"
   user_cant_offer_get = \
      "You can't take %s%s from the trade -- it is on the ground."
   user_offer_not_online = "%s%s is not online to accept your offer."
   user_offer_not_here = \
      "You try to offer your goods to %s%s, but %s is no longer here."
   user_couldnt_carry_offer = \
      "%s%s can't carry all the items you have offered."
   user_cant_carry_offer = \
      "You can't carry all the items that %s%s has offered you."
   user_not_item = "You cannot pick that up."

   user_not_have_number = "You don't have that amount of %s to drop."
   user_cant_deal_number = "You can't do anything with %i items."
   user_cant_attack_non_battler = "You can't attack %s%s."
   user_no_say_guild = \
      "You cannot Send a message to your guild, as you do not belong to a "
      "guild."
   user_no_guild_logged_on = "No one else from your guild is logged on."
   user_someone_logon = "~B~U~k[###]~n ~B~vPlease welcome %s."
   user_someone_logoff = "~B~U~k[###]~n ~B~vAu revoir to %s."
   user_guildmate_logon = "~IHail your guildmate %s!"
   user_guildmate_logoff = "~IYour guildmate %s has just departed."
   user_guild_shield_error_time = \
      "You will be able to claim a new design for your guild's herald "
      "shield in %i %s."
   user_guild_shield_error_disabled = \
      "Your guild is unable to claim a different heraldic design at this "
      "time – you have already claimed one."
   user_time_days = "days"
   user_time_hours = "hours"
   user_time_minutes = "minutes"
   user_time_seconds = "seconds"
   user_time_second = "second"

   user_safety_on = \
      "~B~U~k[###]~n ~B~vYour safety is now ~I~gON~n~B:  You can no longer "
      "strike innocents."
   user_safety_off = \
      "~B~U~k[###]~n ~B~vYour safety is now ~B~rOFF~n~B:  Be careful, you are "
      "now able to hurt those around you."
   user_temp_safe_on = \
      "~B~U~k[###]~n ~B~vYou will receive a temporary guardian angel on death."
   user_temp_safe_off = \
      "~B~U~k[###]~n ~B~vYou will no longer receive a temporary guardian "
      "angel on death."
   user_temp_safe_invalid = \
      "~B~U~k[###]~n ~B~vYour guardian angel can no longer protect you."
   user_grouping_on = \
      "~B~U~k[###]~n ~B~vYou will now join builder groups."
   user_grouping_off = \
      "~B~U~k[###]~n ~B~vYou will no longer join builder groups."
   user_autocombine_on = \
      "You decide to combine spell items as you get them."
   user_autocombine_off = \
      "You decide to stop combining spell items as you get them."
   user_autoloot_on = "You decide to pick up treasure as it drops."
   user_autoloot_off = "You stop picking up treasure as it drops."

   user_cant_go = "You are unable to go anywhere."
   user_cant_go_wav_rsc = cant_go_anywhere_louder.ogg
   user_blocked_send = "%s is ignoring messages from you."

   user_cant_suicide = \
      "You just can't bear to kill yourself because you have too much to live "
      "for.  You must abdicate the leadership of your guild before you can "
      "commit suicide."

   user_cant_suicide_justicar = \
      "It would be unseemly for such a high official to take his own life!"

   user_cant_suicide_yet = \
      "You can't seem to kill yourself, you feel you've only just begun this "
      "life. Give it a day."

   user_cant_suicide_token = \
      "You can't kill yourself now, not when you're the sacred guardian of a "
      "Meridian token!"

   user_cant_suicide_hp = \
      "You've accomplished much so far in your time here, and you can't quite "
      "stomach the thought of ending your journey now.  If you have a good "
      "reason for suiciding, perhaps one of the Gods will assist you."

   user_cant_suicide_OOG = \
      "Somehow, even though you deserve it, you are unable to bear the "
      "thought of killing yourself now."

   user_no_seller = "You can't buy anything here."

   user_no_guild = "You do not belong to a guild."
   user_no_guild_broke = \
      "Come back when you have enough money to create a guild."
   user_no_guildhall_broke = \
      "Come back when you have enough money to put a payment down on the "
      "guildhall."
   user_duplicate_guildname = \
      "There is already a guild with that name.  Please choose another."
   user_duplicate_guild_username = \
      "Your guild name cannot have the name of a player.  Please choose "
      "another."

   user_couldnt_replace = \
      "You could not be restored to your previous location."

   user_logon = \
      "Welcome to the world of Meridian 59! (type \"help\" to see the manual)."
   user_goto_lastsaferoom = "You have been sent to the last safe place you visited."
   user_goto_safety = "You have been sent to a safe place."
   user_goto_object = "You have been sent to %s%s."
   user_goto_jail = "You have been thrown in the Barloque Jail!"
   user_last_known = "the last known location of "

   user_school_shallile = "School of Shal'ille"
   user_school_qor = "School of Qor"
   user_school_kraanan = "School of Kraanan"
   user_school_faren = "School of Faren"
   user_school_riija = "School of Riija"
   user_school_jala = "School of Jala"
   user_school_dm = "DM spells"

   user_admin_message = "%q"

   user_doesnt_know_stroke = "You do not know how to %s!"
   user_doesnt_know_spell = "You have not yet learned the spell '%s'!"

   user_interface_module = merintr.dll
   user_mailnews_module = mailnews.dll
   user_statchange_module = stats.dll

   user_cant_withdraw = "You can't withdraw anything here!"
   user_cant_withdraw_items = "You can't withdraw items here!"
   user_cant_deposit = "You can't deposit anything here!"
   user_cant_deposit_items = "You can't deposit items here!"
   user_cant_balance = "You can't check any balance here!"

   user_appeal = "~B~cAPPEAL: ~v%s ~Bappeals, \"%q~n\""
   user_first_time_appeal = \
      "~B~U~k[###]~n ~B~v%s has just logged on for the first time."
   user_did_appeal = "~B~cYou appeal, ~n\"%q~n\""
   user_appeal_squelched = "Your appeal privileges have been revoked."
   user_kill_zone = \
      "Your guardian angel whispers to you, \"I cannot defend you here.\""
   user_angel_rejoins = "Your guardian angel rejoins you."

   user_fumble = "You fumble and drop your %s."     

   user_wait_for_news_posting = \
      "You must wait a while before you can post to a news globe again."
   user_news_squelched = \
      "Your news posting privileges have been revoked."
   user_news_toobig = \
      "WHOA BUDDY!  Take a breath, that message was WAY too big!"
   user_news_subject_toobig = \
      "Your newsglobe subject length was too long."
   user_news_los = "You cannot see the newsglobe from here."

   user_guildofficer_rsc = "guildofficer"

   user_default_url = "https://www.meridiannext.com/"

   user_safety_on_wav_rsc = safety_on.ogg
   user_safety_off_wav_rsc = safety_off.ogg
   user_quest_advance_wav = questadvance.ogg
   user_quest_complete_wav = questcomplete.ogg

   user_quest_log_updated = "~IYour quest log has been updated."
   user_no_quest_item = \
      "You don't have the required item to complete this quest."

   // Guild MOTD user say commands.
   user_say_guild_motd = "motd"
   guild_motd_command = "set motd "
   guild_clear_motd_command = "clear motd"

   // Inventory sorting user say commands.
   user_say_inventory = "inventory"
   user_say_inv_sort_clear = "inventory sort clear"
   user_say_inv_sort_report = "inventory sort report"
   user_say_inv_sort_add = "inventory sort add "
   user_say_inv_sort_help = "inventory sort help"
   user_say_inv_sort = "sort inventory"

   // Survival arena user say commands.
   user_say_survival = "survival"
   user_say_start_solo_survival = "start solo survival"
   user_say_start_pub_survival = "start public survival"
   user_say_join_pub_survival = "join public survival"
   user_say_start_guild_survival = "start guild survival"
   user_say_join_guild_survival = "join guild survival"
   // Extra survival arena options for DMs.
   user_say_survival_opt_pvpon = "--pvpon"
   user_say_survival_opt_starthere = "--thisbase"

   guild_survival_too_late = \
      "Your guild is already running a survival room. You will have to wait."
   public_survival_too_late = \
      "A public survival room is already running. You will have to wait."

   survival_err_not_safe = \
      "You have to be somewhere safe to join a survival arena!"
   survival_err_no_guild = \
      "You don't have a guild!"
   survival_err_already_guild = \
      "There is already a guild survival arena running."
   survival_err_already_public = \
      "There is already a public survival arena running."
   survival_no_public_rooms = \
      "There are no public survival rooms currently running."
   survival_no_guild_rooms = \
      "Your guild has no survival rooms running at this time."

   phased_out_cant_drop = "You can't drop items while phased out of existence."
                               
   user_reagentbag_on = "You start putting new reagents in your bag."
   user_reagentbag_off = "You stop putting new reagents in your bag."
   user_spellpower_on = \
      "You will now see the power at which your spells are cast."
   user_spellpower_off = \
      "You will no longer see the power at which your spells are cast."

   user_logon_delay = \
      "You take a moment to recollect your senses."
   
   inventory_sort_cleared = \
      "Your sort preferences have been cleared."
   inventory_class_added = \
      "You add %s to your sort preferences."
   inventory_sort_no_item = \
      "There is no item or type of item with that name."
   inventory_sort_help = \
      "Say 'inventory sort add scimitar' to add a scimitar, for example, to "
      "your preferences. Any item will work; you may also use item types, "
      "such as weapons, armors, helmets, shields, rings, potions, scrolls, "
      "wands, rods, reagents, ammo, and food. Say 'sort inventory' to "
      "instantly sort your inventory at any time. Say 'inventory sort clear' "
      "to delete your current preferences. Say 'inventory sort report' to "
      "see your current preferences."
   inventory_sort_report_header = \
      "Your inventory will sort with this order:"
   inventory_sort_report = \
      "%s"
   inventory_already_in_list = \
      "That is already in your list."

   user_time_string =  \
   "The time in Meridian is %i:00.  It is the %q day of the year %i."

   user_self_phase_out = \
      "You phase out of existence, confident that you can hold onto "
      "reality for another %i seconds."
   user_phase_out_high = "%s phases out while completely unharmed."
   user_phase_out_med = \
      "Sensing the battle turning unfavorably, %s phases out."
   user_phase_out_low = "Moments before death, %s phases out!"
   user_phase_out_onehp = "%s phases out a split second before death!"
   user_self_phase_in = \
      "Only %i seconds away from losing your grip on reality, you phase "
      "back into existence."
   user_phase_in = "%s phases back into existence!"
   user_spectate_on = \
      "%s has lost physical touch with this reality."
   user_self_spectate_on = \
      "You have lost your physical connection to this place!"
   user_spectate_off = \
      "%s has regained physical touch with this reality."
   user_self_spectate_off = \
      "You have regained your physical connection to this place."

   user_honor_gain_penalty = \
      "You gain %i honor points from your victory over %s as they cowardly "
      "flee the battlefield."
   user_honor_loss_penalty = \
      "You lose %i honor points as you retreat from the battlefield."

classvars:

   viIndefinite = ARTICLE_NONE
   viDefinite = ARTICLE_NONE
   viDM = FALSE

properties:

   vrName = user_name_rsc

   piHomeroom

   piLastSafeRoom = $

   plNew_mail = $

   poOffer_who = $
   plOffer_items = $

   piSave_room = $
   piSave_row = 0
   piSave_col = 0
   piSave_angle = 0
   piSave_fine_row = 0
   piSave_fine_col = 0

   // Have to save this for honor PvP system, to subtract points if logged.
   // Updated on login, so can use it for any IP checks.
   plIPAddress = $

   // default to never logged on
   piLastLoginTime = 0
   // counts total time logged in
   piTimeLoggedIn = 0

   psURL = $

   plQuestHistory = $
   plActiveQuests = $

   piLogoffPenaltyCount = 0

   piTimeNewsPosted = 0
   piNumberOfNewsPosts = 0

   piLastPacketTime = 0
   piPacketsPerSecond = 0

   // This is a token-bucket to limit speedhacking.
   // Moves are accepted unless there is not enough tokens in the bucket left.
   piMovementBucket = 0

   // Keeps track of when mobs have last been alerted of our presence.
   piLastMoveNotification = 0

   // Keeps track of when server last teleported this user inside the room
   piLastServerTeleport = 0

   piCheaterLogs = 0

   // What order do you want your inventory sorted in?
   plClassOrderPreferences = $

   // keep track of how much this player triggers flood protection
   piFloodCount = 0

   // Checks for actual changes before drawing. Removes flicker.
   plDraw = $

   // Keeps track of the most recent steps a user has taken.
   plUserTrail = $

   // Steps the player has taken since their last step was recorded.
   piTrailSteps = 0

   // List of user objects this user cannot receive communications from.
   plForcedIgnore = $

messages:

   Constructor(name = $,icon = $)
   {
      local oRoom,lPos;

      if name <> $
      {
         vrName = name;
      }

      if icon <> $
      {
         vrIcon = icon;
      }

      Send(SYS,@SystemUserCreate,#what=self);

      Send(self,@AdminGoToSafety);

      propagate;
   }

   Delete()
   {
      Send(SYS,@SystemUserDelete,#what=self);

      propagate;
   }

   //// Naming convention:
   // GetTrueName returns what an object's name IS, regardless of any way that
   //  that is modified.  This is especially important for users, esp mail,
   //  and it should be used for most all cross-server events (such as tells).
   // GetApparentName returns what the player sees in look description boxes and
   //  what other players see over his head.
   // GetName returns the modified version of a name for use in text.  Thus, a 
   //  anonymous player returns 'someone' and a morphed player returns the name
   //  of his morph target.

   GetUserName()
   "This function is now redundant.  However, since the server and/or client "
   "calls this directly, we leave this in."
   {
      return vrName;
   }

   // GetTrueName() - Defined in class above

   GetApparentName()
   "Returns a blank string for look and overhead purposes."
   {
      // Send a blank string if we're anonymous, if we're a blank or if we're
      //  a hidden admin.
      if (piFlags & PFLAG_ANONYMOUS)
         OR vrIcon = admin_icon_blank
         OR (IsClass(self,&DM) AND Send(self,@IsHidden))
      {
         return Send(self,@GetBlankName);
      }

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetName,#who=self);
      }

      propagate;
   }

   GetDef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetDef,#who=self);
      }

      propagate;
   }

   GetCapDef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetCapDef,#who=self);
      }

      propagate;
   }

   GetIndef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetIndef,#who=self);
      }

      propagate;
   }

   GetHisHer()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetHisHer,#who=self);
      }

      propagate;
   }

   GetCapIndef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetCapIndef,#who=self);
      }

      propagate;
   }

   GetName(cap=FALSE)
   {
      local rName;

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetName,#who=self);
      }

      if (piFlags & PFLAG_ANONYMOUS)
      {
         if cap
         {
            rName = user_cap_someone_string;
         }
         else
         {
            rName = user_someone_string;
         }

         return rName;
      }

      propagate;
   }

   GetUserIcon()
   {
      // Convenience function for the server to send list of char choices
      return vrIcon;
   }

   GetAction()
   {
      return piAction;
   }

   SetAction(action=$)
   "Used to set facial expression."
   {
      if action <> $
         AND action <> piAction
         AND action >= UA_NORMAL
         AND action <= UA_WRY
      {
         piAction = action;

         if poOwner <> $
         {
            Send(poOwner,@SomethingDidAction,#what=self,#action=action);
         }
      }

      return;
   }

   GetBlankName()
   {
      return user_blank_string;
   }

   IsFirstTime()
   {
      return piLastLoginTime = 0;
   }

   GetLastLoginTime()
   "Used by the assassin's game to see if the player is spending enough "
   "time online to remain part of the proceedings."
   {
      return piLastLoginTime;
   }

   IsUserInactive()
   "Returns TRUE if player hasn't logged on in a very long time."
   {
      // Has it been longer since USER_INACTIVE_TIME since we last logged in?
      return ((GetTime() - piLastLoginTime) > USER_INACTIVE_TIME);
   }

   // Returns a running count of player's logged in time, across sessions
   //  Used by quest engine to check how much time a player has spent online
   //  since performing a quest
   GetTimeLoggedIn()
   {
      local iTime;

      if piLastLoginTime = 0
      {
         return 0;
      }

      if pbLogged_on
      {
         iTime = GetTime() - piLastLoginTime + piTimeLoggedIn;
         if (iTime >= 0)
         {
            return iTime;
         }
      }

      return piTimeLoggedIn;
   }

   // Used by GetStealth in player.kod to check if the player enjoys login protection.
   GetTimeSinceLogin()
   {
      return GetTime() - piLastLoginTime;
   }

   SendFirstTimeAppeal()
   {
      Send(self,@UserAppeal,#first_time=TRUE);

      return;
   }

   FirstLogon()
   "Sets the last login time and sends an appeal "
   "when a new character is created."
   {
      if piLastLoginTime = 0 AND piLast_Restart_Time = 0
      {
         Debug("Sending first time appeal");
         Send(self,@SendFirstTimeAppeal);
      }

      piLastLoginTime = GetTime();

      return;
   }

   UserLogon(session_id = $)
   {
      local i, sGuild, oBRoom, oHRoom;

      poSession = session_id;
      plIPAddress = GetSessionIP(poSession);

      // Users logging on unsafely are held for a short time.
      Send(self,@LogonDelay);

      pbLogged_on = TRUE;

      piLastLoginTime = GetTime();

      // Reset draw list to make sure we load our vitals.
      plDraw = [-1,-1,-1,-1,-1,-1];

      // Gotta load interface early!
      Send(self,@UserLoadModule,#module=user_interface_module);

      Send(self,@MsgSendUser,#message_rsc=user_logon);

      Send(SYS,@SystemUserLogon,#what=self);

      // Let the user know whether safety is on or off.
      if piPreferences & CF_SAFETY_OFF
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_off);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_on);
      }

      if NOT (IsClass(self,&DM) AND Send(self,@IsHidden))
      {
         // Advertise as normally.
         Send(SYS,@SystemUserLogonAdvertise,#what=self);
      }
      else
      {
         // We don't want to be seen, except by admins
         foreach i in Send(SYS,@GetUsersLoggedOn)
         {
            // Only do this for admins
            if IsClass(i,&Admin)
            {
               Send(i,@SomeoneLogon,#what=self);
            }
         }
      }

      Send(self,@ToCliPlayers);

      // Enchantments are told to 'freeze' until a player logs back on.
      //   Must do this before they enter room.
      Send(self,@ReactivateAllEnchantments);

      Send(self,@UserLogonSetPosition);

      if plNew_mail <> $
      {
         if Length(plNew_mail) = 1
         {
            Send(self,@MsgSendUser,#message_rsc=user_logon_one_mail,
                 #parm1=Length(plNew_mail));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=user_logon_many_mail,
                 #parm1=Length(plNew_mail));
         }
      }

      Send(self,@ToCliSpellSchools);
      Send(self,@UserLogonHook);

      // Give a new user a buddy upon first login. Has to happen
      // after the user has arrived in poOwner.
      if (piXP_total = 0)
         AND (poMercenary = $)
         AND Send(SETTINGS_OBJECT,@IsFollowerEnabled)
      {
         Post(self,@CreateFollower,#iDifficulty=5);
      }

      if (poEvilTwin <> $)
      {
         Send(poEvilTwin,@PlaceEvilTwin,#who=self);
      }

      oHRoom = $;
      if piHomeroom <> $
      {
         oHRoom = Send(SYS,@FindRoomByNum,#num=abs(piHomeroom));
      }

       if piBound_Room <> $
      {
         oBRoom = Send(SYS,@FindRoomByNum,#num=abs(piBound_Room));
      }
      else
      {
         oBRoom = oHRoom;
      }

      sGuild = $;

      if poGuild <> $
      {  
         sGuild = Send(poGuild,@GetName);

         if Send(poGuild,@GetGuildHall) <> $
         {
            RecordStat(STAT_GUILD, sGuild, Send(Send(poGuild,@GetGuildMaster),@GetName), Send(Send(poGuild,@GetGuildHall),@GetName) );
         }
         else
         {
            RecordStat(STAT_GUILD, sGuild, Send(Send(poGuild,@GetGuildMaster),@GetName), system_blank_resource );
         }
      }

      RecordStat(STAT_PLAYER, poSession, Send(self,@GetTrueName), Send(oHRoom,@GetName), Send(oBRoom,@GetName), 
                  sGuild, Send(self,@GetBaseMaxHealth), piMax_mana, Send(self,@GetRawMight), 
                  Send(self,@GetRawIntellect), Send(self,@GetRawMysticism), Send(self,@GetRawStamina), Send(self,@GetRawAgility), 
                  Send(self,@GetRawAim));

      return;
   }

   LogonDelay()
   "Note that this occurs before the player enters the room."
   {
      local iLogonDelay, oSpell, oRoom;

      if (pbLogged_on)
      {
         oRoom = poOwner;
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=piSave_room);
      }

      if (oRoom = $)
      {
         Debug("User ", self, vrName, " got $ room in LogonDelay");

         return;
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_HOLD);

      if NOT Send(self,@IsEnchanted,#what=oSpell)
         AND NOT Send(oRoom,@CheckDefaultRoomFlag,#flag=ROOM_SAFELOGOFF)
      {
         iLogonDelay = Send(SETTINGS_OBJECT,@GetLogonDelay);
         Send(oSpell,@DoSpellEffects,#lTargets=[self],#iDuration=iLogonDelay,
               #report=FALSE,#bAllowFreeAction=FALSE);
         Post(self,@SysMsgSendUser,#message_rsc=user_logon_delay);
      }

      return;
   }

   UserLogoff()
   {
      local i;

      piTimeLoggedIn = Send(self,@GetTimeLoggedIn);
      Send(self,@BreakTrance);

      pbLogged_on = FALSE;

      Send(self,@CancelIfOffer);
      Send(self,@UserLogoffHook);

      // If player logs off somewhere other than an inn or inside a guildhall
      // they can normally enter (but not just in the foyer), create a ghost.
      if (NOT Send(poOwner,@CheckDefaultRoomFlag,#flag=ROOM_SAFELOGOFF))
         AND NOT (IsClass(self,&DM) OR IsClass(self,&EscapedConvict))
         AND Send(SYS,@GetLogoffPenaltyEnable)
         AND piLogoffPenaltyCount >= 0
         AND NOT (IsClass(poOwner,&GuildHall)
                  AND Send(poOwner,@GetGuildOwner) <> $
                  AND Send(poOwner,@CanEnter,#who=self)
                  AND NOT Send(poOwner,@InFoyer,#who=self))
      {
         Create(&LogoffGhost,#GhostedPlayer=self,
               #iPenaltyTime=Send(self,@GetRemainingPhaseTime));

         // Add phase time remaining to piTimeAttackedPlayer if it is currently
         // preventing the player from casting escape spells.
         if Send(self,@GetLastPlayerAttackTime)
               + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
               > GetTime()
         {
            piTimeAttackedPlayer += (Send(self,@GetRemainingPhaseTime) / 1000);
         }
      }
      else
      {
         // Reset our logoff penalty time since we're logging safely.
         Send(self,@RefreshPhaseTimeToBase);

         // If enabled and and a player logs off in a safe zone he will lose
         // half his mana and all buffs
         if Send(SETTINGS_OBJECT,@LogSafePenaltyEnable)
            AND Send(SYS,@GetLogoffPenaltyEnable)
         {
            Send(self,@LoseMana,#amount=(piMana/2));
            Send(Send(SYS,@FindSpellByNum,#num=SID_PURGE),@DoPurge,
                  #who=self,#iSpellPower=$);
         }
      }

      if piLogoffPenaltyCount < 0
      {
         piLogoffPenaltyCount = 0;
      }

      piSave_room = Send(poOwner,@GetRoomNum);
      piSave_row = piRow;
      piSave_col = piCol;
      piSave_angle = Send(self,@GetAngle);
      piSave_fine_row = piFine_row;
      piSave_fine_col = piFine_col;

      Send(poOwner,@LeaveHold,#what=self);
      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         AND (piflags & PFLAG_DEATH_RIFTING)
      {
         // Don't let players stay in the Underworld with Death Rift
         Post(self,@AdminGoToSafety);
      }

      poOwner = $;

      // If we still have an evil twin at this stage, tell it to delete itself.
      if poEvilTwin <> $
      {
         Send(poEvilTwin,@SomethingLeft,#what=self);
      }

      // Check for phase out
      foreach i in plEnchantments
      {
         if IsClass(Nth(i,2),&Phase)
         {
            Send(self,@FreezePhaseTimer);
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=FALSE);

            break;
         }
      }

      // Have to put here so room enchantments are removed first.
      Send(self,@FreezeAllEnchantments);

      Send(SYS,@SystemUserLogoff,#what=self);

      if NOT (IsClass(self,&DM) AND Send(self,@IsHidden))
      {
         // Advertise normally.
         Send(SYS,@SystemUserLogoffAdvertise,#what=self);
      }
      else
      {
         // We've already faked our own logoff.  Don't advertise to non-admins.
         foreach i in Send(SYS,@GetUsersLoggedOn)
         {
            // Only do this for admins
            if IsClass(i,&Admin)
            {
               Send(i,@SomeoneLogoff,#what=self);
            }
         }
      }

      poSession = $;

      return;
   }

#region Penalties

   IsRecentPvPCombatant()
   {
      local iTime, iRecent;

      iTime = GetTime();
      iRecent = iTime - Send(SETTINGS_OBJECT,@GetRecentPvPTime);

      return (piTimeAttackedByPlayer > iRecent OR piTimeAttackedPlayer > iRecent);
   }

   DecayLogoffPenaltyCount()
   {
      piLogoffPenaltyCount = Bound(piLogoffPenaltyCount - 1,0,$);

      return;
   }

   ResetLogoffPenaltyCount()
   {
      piLogoffPenaltyCount = 0;

      return;
   }

   GetLogoffPenaltyCount()
   {
      return piLogoffPenaltyCount;
   }

   IncrementLogoffPenaltyCount()
   {
      local iAmount;

      iAmount = 1;

      // This tracks to see if the player has attacked anyone recently.
      // If they have, then increase the penalty.
      if NOT Send(self,@CanHelpPlayer)
      {
         ++iAmount;
      }

      piLogoffPenaltyCount += iAmount;

      return;
   }

   ResetLogoffPenaltyTime()
   {
      Send(self,@RefreshPhaseTimeToBase);

      return;
   }

   CalculatePenalties(what=$)
   "'what' is the calling object, i.e. logoff ghost, phase spell."
   {
      local iPenCount, iEquivDeath, iPointLoss, iItemLoss, oDrop,
            iXPLoss, iNumItems, iNumSpellPts, iNumSkillPts, oSoldierShield,
            iHonorLoss;

      // Check if we're eligible for a free pen.
      if (Send(SETTINGS_OBJECT,@GetFreeNoPvPPenActive,
               #flag=piFlags & PFLAG_MURDERER)
         AND NOT Send(self,@IsRecentPvPCombatant))
      {
         // Reset the time to avoid any funny business like potential double
         // penalties.
         Send(self,@ResetLogoffPenaltyTime);

         // Calling object still needs to display a message for the free pen.
         if (what <> $)
         {
            Send(what,@SendPenaltyInfo,#who=self);
         }

         return;
      }

      // Handle users phasing in guild halls.
      if (poOwner <> $
         AND IsClass(poOwner,&GuildHall)
         AND Send(poOwner,@GetGuildOwner) <> $
         AND Send(poOwner,@CanEnter,#who=self)
         AND NOT Send(poOwner,@InFoyer,#who=self))
      {
         // User is inside a guild hall they own. Teleport them back to an
         // inn, and give penalties only if they were recently in combat.
         if NOT (Send(self,@IsRecentPvPCombatant))
         {
            Send(self,@ResetLogoffPenaltyTime);
            // Calling object still needs to display a message for the free pen.
            if (what <> $)
            {
               Send(what,@SendPenaltyInfo,#who=self);
            }

            return;
         }
      }

      // Add the penalty for repeat logging to the number of recent kills.
      iPenCount = (Send(self,@GetLogoffPenaltyCount)
                       + Send(self,@GetDecayedUnjustifiedKills));

      // The point at which iPenCount = same cost as a death.
      iEquivDeath = (Send(SYS,@GetLogoffPenaltyEquivDeath));

      // Increase the penalty counter due to taking a pen.
      Send(self,@IncrementLogoffPenaltyCount);

      // Flat pens are just x item, y spell, y skill, with iPenCount set to 0.
      if Send(SETTINGS_OBJECT,@GetFlatPenaltiesEnable,
               #flag=piFlags & PFLAG_MURDERER)
      {
         iPenCount = 0;
         iPointLoss = 2;
         iItemloss = 1;
      }
      else
      {
         iPointLoss = 0;
         iItemloss = 0;
      }

      if (pbLogged_On)
      {
         oDrop = self;
      }
      else
      {
         oDrop = what;
      }

      // Potentially lose XP
      iXPLoss = Send(self,@PenaltyLoseXP,#iPenCount=iPenCount,
                     #iEquivDeath=iEquivDeath);
      iNumItems = Send(self,@PenaltyDropItems,#iNumDrop=iItemloss,
                        #iPenCount=iPenCount,#iEquivDeath=iEquivDeath,
                        #where=oDrop);
      iNumSpellPts = Send(self,@PenaltyLoseSpellPoints,
                           #iNumPoints=iPointLoss,#iPenCount=iPenCount,
                           #iEquivDeath=iEquivDeath);
      iNumSkillPts = Send(self,@PenaltyLoseSkillPoints,
                           #iNumPoints=iPointLoss,#iPenCount=iPenCount,
                           #iEquivDeath=iEquivDeath);
      iHonorLoss = Send(self,@PenaltyLoseHonor,#where=oDrop);

      // Let the faction shield know of this person's naughtiness if we took a
      // penalty.
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
         AND iPenCount > 0
      {
         // Treat it like a death.
         Send(oSoldierShield,@OwnerDied,#logoff=TRUE);
      }

      // Reset the time to avoid any funny business like potential double
      // penalties.
      Send(self,@ResetLogoffPenaltyTime);

      // The calling object will let the user know what the penalties were.
      if (what <> $)
      {
         Send(what,@SendPenaltyInfo,#who=self,#iXPLost=iXPLoss,
               #iItemsLost=iNumItems,#iSpellPtLost=iNumSpellPts,
               #iSkillPtLost=iNumSkillPts,#iHonorLost=iHonorLoss);
      }

      return;
   }

   PenaltyLoseHonor(where = $)
   {
      local i, j, iHonorLost, iNumHurters, iHonorEach, iLostTotal, oHurter,
            oOwner, oHurterOwner, bIsNear;

      if NOT Send(SETTINGS_OBJECT,@HonorSystemActive)
      {
         return 0;
      }

      // 'where' should be the user (logged on) or a logoff ghost (logged off).
      // Account for $ room (try use poOwner) and room 'where' edge/future cases.
      if (where = $)
      {
         oOwner = poOwner;
      }
      else if (IsClass(where,&LogoffGhost))
      {
         oOwner = Send(where,@GetOwner);
      }
      else if (IsClass(where,&Room))
      {
         oOwner = where;
      }
      else if (poOwner <> $)
      {
         oOwner = poOwner;
      }

      // No owner at this stage, log and return.
      if (oOwner = $)
      {
         Debug("Tried to inflict honor penalty for player ",self," with no owner.");

         return 0;
      }

      iHonorLost = 0;
      iNumHurters = 0;
      iHonorEach = Send(SETTINGS_OBJECT,@GetHonorLossPen);
      iLostTotal = 0;

      // Find out how many people attacked us recently. Don't count ourselves.
      foreach i in plHurtMeRecently
      {
         oHurter = First(i);

         if oHurter <> self
            AND IsClass(oHurter,&Player)
         {
            ++iNumHurters;
         }
      }

      // Penned without being attacked by a player.
      if iNumHurters = 0
      {
         return 0;
      }

      iHonorEach = iHonorEach / iNumHurters;

      // Attempt to give the honor points from the victim to the attacker(s).
      foreach i in plHurtMeRecently
      {
         bIsNear = FALSE;
         oHurter = First(i);

         // Only count players that can fight.
         if (oHurter = self
            OR NOT IsClass(oHurter,&Player)
            OR Send(oHurter,@IsOfflineOrCannotInteract))
         {
            continue;
         }

         oHurterOwner = Send(oHurter,@GetOwner);
         if oOwner = oHurterOwner
         {
            bIsNear = TRUE;
         }
         else
         {
            // The attacker can fight but isn't in the same room as the victim.
            // Check if they are in a nearby combat area since PvP involves movement.
            foreach j in Send(oOwner,@GetYellZone)
            {
               if Send(SYS,@FindRoomByNum,#num=j) = oHurterOwner
                  AND NOT Send(oHurterOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
                  AND NOT Send(oHurterOwner,@CheckRoomFlag,#flag=ROOM_NO_PK)
                  AND NOT Send(oHurterOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
               {
                  bIsNear = TRUE;
               }
            }
         }
         if bIsNear
         {
            // The attacker is nearby and can participate in PvP. Give them the points.
            iHonorLost = Send(self,@TransferHonorPoints,#who=self,
                              #what=oHurter,#honor=iHonorEach);
            iLostTotal += iHonorLost;
            Send(oHurter,@MsgSendUser,#message_rsc=user_honor_gain_penalty,
                  #parm1=iHonorLost,#parm2=Send(self,@GetName));
         }
      }

      // Don't inform the player if they didn't lose any points. Reasons for
      // this can include them not having any to give or all attackers having
      // fled the battlefield.
      if iLostTotal > 0
      {
         Send(self,@MsgSendUser,#message_rsc=user_honor_loss_penalty,
               #parm1=iLostTotal);

         // System message that points were lost (but not to whom, due to spam).
         Send(SYS,@UserLostHonorPoints,#who=self);
      }

      return iLostTotal;
   }

   PenaltyLoseXP(iPenCount=0, iEquivDeath=0)
   {
      local iXPLoss;

      if iPenCount < iEquivDeath
         OR NOT Send(SETTINGS_OBJECT,@LoseXPOnPenalty)
      {
         return 0;
      }

      iXPLoss = Send(SYS,@GetXPDiffForLevel,#iLevel=Send(self,@GetBaseMaxHealth));
      Send(self,@AddXP,#iAmount=-iXPLoss);

      return iXPLoss;
   }

   PenaltyDropItems(iPenCount=0, iEquivDeath=0, iNumDrop=0, where=$)
   {
      local i, iNumInventory, iNumItemsLeft;

      if (where = $)
      {
         return 0;
      }

      iNumInventory = Send(self,@GetNumItemsInInventory);

      // If there's no parameter sent for the number of items to drop,
      // calculate it here.
      if (iNumDrop <= 0)
      {
         iNumDrop = iNumInventory * iPenCount / Bound(iEquivDeath, 1, $);

         // Add two items for murderers.
         if (piFlags & PFLAG_MURDERER)
         {
            iNumDrop += 2;
         }

      }
      else if (piFlags & PFLAG_MURDERER)
      {
         // Double item drop on flat pens for murderers.
         iNumDrop *= 2;
      }

      // Need to drop more items than we have.
      if iNumDrop >= iNumInventory
      {
         iNumDrop = iNumInventory;
         i = 1;
         while i <= iNumDrop
         {
            if Send(self,@DropItem,#index=i,#targetGhost=where)
            {
               --iNumDrop;
            }
            else
            {
               // If item doesn't drop, increment i.
               ++i;
            }
         }
         iNumItemsLeft = Send(self,@GetNumItemsInInventory);
      }
      else
      {
         iNumItemsLeft = iNumInventory;
         while iNumDrop-- > 0 AND iNumItemsLeft > 0
         {
            // Try to drop a random item.
            i = Random(1,iNumItemsLeft);
            if Send(self,@DropItem,#index=i,#targetGhost=where)
            {
               --iNumItemsLeft;
            }
            else
            {
               // If the Random drop fails, scan through and drop one.
               i = 1;
               while i <= iNumItemsLeft
                     AND NOT Send(self,@DropItem,#index=i,#targetGhost=where)
               {
                  ++i;
               }

               iNumItemsLeft = Send(self,@GetNumItemsInInventory);
               // If nothing can be dropped, exit.
               if i > iNumItemsLeft
               {
                  break;
               }
            }
         }
      }

      // iNumItemsLeft is still accurate here.
      return iNumInventory - iNumItemsLeft;
   }

   PenaltyLoseSpellPoints(iPenCount=0, iEquivDeath=0, iNumPoints=0)
   {
      local i, iSpellNum, iLoops, bLooped, iLossAmount, iPointsLost, iStart;

      if (plSpells = $)
      {
         return 0;
      }

      iPointsLost = 0;

      // Calculate the number of points to take if not set.
      if (iNumPoints <= 0)
      {
         iNumPoints = (Length(plSpells) * iPenCount) / iEquivDeath;
         if Random(1,(iEquivDeath - 1)) < (iPenCount % iEquivDeath)
         {
            ++iNumPoints;
         }
      }

      // Double the point loss for murderers.
      if (piFlags & PFLAG_MURDERER)
      {
         iLossAmount = -2;
      }
      else
      {
         iLossAmount = -1;
      }

      // Pick random spells to subtract points from.
      for (iLoops = 0; iNumPoints > 0 AND iLoops < 200; ++iLoops, --iNumPoints)
      {
         // Don't iterate more than once through the spell list.
         bLooped = FALSE;

         // Try to lower a random spell.
         i = Random(1,Length(plSpells));
         // Save this index as our starting point.
         iStart = i;
         // Iterate through if we couldn't lower this one.
         while (i <> iStart OR NOT bLooped)
            AND (Send(self,@DecodeSpellAbility,#compound=Nth(plSpells,i)) < 6)
         {
            if ++i > Length(plSpells) AND NOT bLooped
            {
               // We get one free reset (since we started in the middle)
               i = 1;
               bLooped = TRUE;
            }
         }

         // If we got all the way through the spell list without lowering
         // anything, bail.
         if i = iStart AND bLooped
         {
            break;
         }

         iSpellNum = Send(self,@DecodeSpellNum,#compound=Nth(plSpells,i));
         Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,#amount=iLossAmount);
         iPointsLost -= iLossAmount;
      }

      return iPointsLost;
   }

   PenaltyLoseSkillPoints(iPenCount=0, iEquivDeath=0, iNumPoints=0)
   {
      local i, iSkillNum, iLoops, bLooped, iLossAmount, iPointsLost, iStart;

      if (plSkills = $)
      {
         return 0;
      }

      iPointsLost = 0;

      // Calculate the number of points to take if not set.
      if (iNumPoints <= 0)
      {
         iNumPoints = (Length(plSkills) * iPenCount) / iEquivDeath;
         if Random(1,(iEquivDeath - 1)) < (iPenCount % iEquivDeath)
         {
            ++iNumPoints;
         }
      }

      // Double the point loss for murderers.
      if (piFlags & PFLAG_MURDERER)
      {
         iLossAmount = -2;
      }
      else
      {
         iLossAmount = -1;
      }

      // Pick random skills to subtract points from.
      for (iLoops = 0; iNumPoints > 0 AND iLoops < 200; ++iLoops, --iNumPoints)
      {
         // Don't iterate more than once through the skill list.
         bLooped = FALSE;

         // Try to lower a random spell.
         i = Random(1,Length(plSkills));
         // Save this index as our starting point.
         iStart = i;
         // Iterate through if we couldn't lower this one.
         while (i <> iStart OR NOT bLooped)
            AND (Send(self,@DecodeSkillAbility,#compound=Nth(plSkills,i)) < 6)
         {
            if ++i > Length(plSkills) AND NOT bLooped
            {
               // We get one free reset (since we started in the middle)
               i = 1;
               bLooped = TRUE;
            }
         }

         // If we got all the way through the skill list without lowering
         // anything, bail.
         if i = iStart AND bLooped
         {
            break;
         }

         iSkillNum = Send(self,@DecodeSkillNum,#compound=Nth(plSkills,i));
         Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,#amount=iLossAmount);
         iPointsLost -= iLossAmount;
      }

      return iPointsLost;
   }

   InstantPenIfUnsafe()
   "Causes an instant logoff pen if the user is phased or has a logoff ghost."
   "Won't do anything to logged-on users who are not phased."
   {
      local oRoom, i, each_obj;

      if (pbLogged_on)
      {
         if (piFlags & PFLAG_PHASED)
         {
            // End the phase timer prematurely, Phase spell handles penalty.
            Send(self,@PhaseTimerEnd);

            return;
         }
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=piSave_room);
         if (oRoom <> $)
         {
            foreach i in Send(oRoom,@GetHolderActive)
            {
               each_obj = First(i);
               if (IsClass(each_obj,&LogoffGhost)
                  AND Send(each_obj,@GetGhostedPlayer) = self)
               {
                  // Logoff ghost will delete itself and handle penalties.
                  Send(each_obj,@PenaltyTrigger);

                  return;
               }
            }
         }
      }

      return;
   }
#endregion Penalties

   AdminSystemMessage(string = $)
   {
      Send(self,@SysMsgSendUser,#message_rsc=user_admin_message,#parm1=string);

      return;
   }

   SomeoneLogon(what = $)
   {
      local rName;

      rName = Send(what,@GetTrueName);

      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_ADD, 4,what, 4,rName, STRING_RESOURCE,rName,
                   4,Send(what,@GetObjectFlags),
                   1,Send(what,@GetDrawingEffects) & ~DRAWFX_INVISIBLE,
                   4,0, // minimapflags, don't need the value here.
                   4,Send(what,@GetPlayerNameColor),
                   1,Send(what,@GetClientObjectType),
                   1,0); // MoveOn type, don't need it here.
         SendPacket(poSession);

         if IsClass(self,&Admin) AND IsClass(what,&Admin)
         {
            Send(self,@MsgSendUser,#message_rsc=user_someone_logon,#parm1=rName);
         }

         if what <> self AND poGuild <> $ AND poGuild = Send(what,@GetGuild)
         {
            Send(self,@MsgSendUser,#message_rsc=user_guildmate_logon,
                 #parm1=rName);
         }
      }

      return;
   }

   SomeoneLogoff(what = $)
   {
      local rName;

      rName = Send(what,@GetTrueName);

      if pbLogged_on
      {
         if IsClass(self,&Admin) AND IsClass(what,&Admin)
         {
            Send(self,@MsgSendUser,#message_rsc=user_someone_logoff,
                 #parm1=rName);
         }

         if what <> self AND poGuild <> $ AND poGuild = Send(what,@GetGuild)
         {
            Send(self,@MsgSendUser,#message_rsc=user_guildmate_logoff,
                 #parm1=rName);
         }

         AddPacket(1,BP_PLAYER_REMOVE,4,what);
         SendPacket(poSession);
      }

      return;
   }

   DisconnectSession()
   {
      Send(self,@UserLogoff);

      return;
   }

   SetFloodCount(iNum=0)
   {
      piFloodCount = iNum;

      return;
   }

   ReceiveClient(client_msg = $,number_stuff = $,type = $)
   "Sent by the server when the client has a message.  The client_msg "
   "is the permanent list created by AllocateCommCli in the server, "
   "so we can't store list fragments!  Also, number_stuff has number "
   "parameters for any of the client_msg things that are number objects.  "
   "It is dynamically allocated each time (wasting list nodes)."
   {
      local liClient_cmd, oWhat, oRoom, iRow, iCol, lUsers, iAngle, sBody,
            iSpeed, i, sStr_said, bCancel;

      // This checks to see if the user is trying to Send too many packets
      //  per second.  If they are, then we mark them as a spammer and
      //  don't process the message
      if piLastPacketTime <> GetTime()
      {
         piLastPacketTime = GetTime();
         piPacketsPerSecond = 1;
      }
      else
      {
         if ++piPacketsPerSecond > INCOMING_PACKET_THROTTLE
            AND NOT Send(self,@PlayerIsImmortal)
         {
            piFloodCount++;

            // Have to let this message through in case they're logging off.
            if ((type = $ OR type = 0)
               AND First(client_msg) = BP_REQ_QUIT)
            {
               Send(self,@UserLogoff);
            }

            // Option to print debug info on what packet this is.
            // Cap at 15 entries per second.
            if ((piFlags & PFLAG_LOG)
               AND piPacketsPerSecond <= INCOMING_PACKET_THROTTLE + 15)
            {
               Debug(vrName," flooding packet ",type,First(client_msg),
                  "PPS: ",piPacketsPerSecond," Flood count: ",piFloodCount);
            }
            // Don't go on if marked as spammer
            return;
         }
      }

      if type = 1
      {
         Send(self,@UserCommand,#client_msg=client_msg,
              #number_stuff=number_stuff);

         return;
      }

      liClient_cmd = First(client_msg);

      // NOTE: Should arrange in decreasing order of frequency

      if liClient_cmd = BP_REQ_MOVE
      {
         // Fix: speed, row, col, room
         iRow = Nth(client_msg,2);
         iCol = Nth(client_msg,3);
         iSpeed = Nth(client_msg,4);
         oRoom = Nth(client_msg,5);
         iAngle = Nth(client_msg,6);

         // Check if it's an outdated message, from a person going off side of
         //  room multiple times before they got their new room.
         if oRoom <> poOwner
         {
            return;
         }

         Send(self,@UserMove,#new_row=iRow/FINENESS,#new_col=iCol/FINENESS,
              #fine_row=(iRow % FINENESS),#fine_col=(iCol % FINENESS),
              #speed=iSpeed);

         Send(self,@UserTurn,#what=self,#new_angle=iAngle);

         return;
      }

      if liClient_cmd = BP_REQ_TURN
      {
         oWhat = Nth(client_msg,2);
         iAngle = Nth(client_msg,3);
         Send(self,@UserTurn,#what=oWhat,#new_angle=iAngle);

         return;
      }

      if liClient_cmd = BP_SEND_PLAYER
      {
         Send(self,@ToCliPlayer);

         return;
      }

      if liClient_cmd = BP_SEND_PLAYERS
      {
         Send(self,@ToCliPlayers);

         return;
      }

      if liClient_cmd = BP_SEND_ROOM_CONTENTS
      {
         Send(self,@ToCliRoomContents);

         return;
      }

      if liClient_cmd = BP_REQ_INVENTORY
      {
         Send(self,@ToCliInventory);
         Send(self,@ToCliUseList);

         return;
      }

      if liClient_cmd = BP_REQ_QUIT
      {
         Send(self,@UserLogoff);

         return;
      }

      if liClient_cmd = BP_REQ_GET
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Item)
         {
            Send(self,@UserGet,#what=oWhat);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=user_not_item);
         }

         return;
      }

      if liClient_cmd = BP_REQ_DROP
      {
         Send(self,@UserDrop,#what=Nth(client_msg,2),#number=number_stuff);

         return;
      }

      if liClient_cmd = BP_REQ_INVENTORY_MOVE
      {
         Send(self,@UserMoveInventoryItem,#what=Nth(client_msg,2),
               #where=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_REQ_PUT
      {
         Send(self,@UserPut,#what=Nth(client_msg,2),#where=Nth(client_msg,3),
               #number=number_stuff);

         return;
      }

      if liClient_cmd = BP_SEND_OBJECT_CONTENTS
      {
         Send(self,@UserObjectContents,#what=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_SAY_TO
      {
         sStr_said = Nth(client_msg,3);

         // don't send oversized chat strings
         if (StringLength(sStr_said) > MAX_CHAT_LEN)
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self," tried to "
               "send an overly large chat message.");
            return;
         }

         Send(self,@UserSay,#type=Nth(client_msg,2),#string=sStr_said);

         return;
      }

      if liClient_cmd = BP_SAY_GROUP
      {
         sStr_said = Nth(client_msg,3);

         // don't send oversized chat strings
         if (StringLength(sStr_said) > MAX_CHAT_LEN)
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self," tried to "
               "send an overly large chat message.");
            return;
         }

         Send(self,@UserSayGroup,#users=Nth(client_msg,2),#string=sStr_said);

         return;
      }

      if liClient_cmd = BP_REQ_LOOK
      {
         Send(self,@UserLook,#what=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_SEND_MAIL
      {
         Send(self,@UserMail,#dest_list=Nth(client_msg,2),
               #string=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_REQ_GET_MAIL
      {
         Send(self,@UserGetNewMail);

         return;
      }

      if liClient_cmd = BP_DELETE_MAIL
      {
         Send(self,@UserDeleteMail,#index=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_DELETE_NEWS
      {
         Send(self,@UserDeleteNews,#nid=Nth(client_msg,2),
               #index=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_REQ_USE
      {
         Send(self,@UserUseItem,#what=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_REQ_UNUSE
      {
         Send(self,@UserUnuseItem,#what=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_REQ_ATTACK
      {
         Send(self,@UserAttack,#type=Nth(client_msg,2),#what=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_SEND_STATS
      {
         Send(self,@ToCliStats,#group=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_REQ_OFFER
      {
         Send(self,@UserOffer,#what=Nth(client_msg,2),
               #item_list=Nth(client_msg,3),#number_list=number_stuff);

         return;
      }

      if liClient_cmd = BP_CANCEL_OFFER
      {
         Send(self,@UserCancelOffer);

         return;
      }

      if liClient_cmd = BP_REQ_COUNTEROFFER
      {
         Send(self,@UserCounterOffer,#item_list=Nth(client_msg,2),
              #number_list=number_stuff);

         return;
      }

      if liClient_cmd = BP_ACCEPT_OFFER
      {
         Send(self,@UserAcceptOffer);

         return;
      }

      // The <space> key doubles as room enter and cancel cast hotkey.
      if liClient_cmd = BP_REQ_GO
      {
         bCancel = FALSE;

         // This is purely for cancelling currently channeled spells.
         // Maintained spells are unaffected.
         if Send(self,@GetTranceAbility) <> $
         {
            oWhat = Send(SYS,@FindSpellByNum,#num=SID_TRANCE);

            // Send this directly to &Trance, not self. We don't want
            // any other trance effects to be affected.
            Send(oWhat,@BreakTrance,#event=EVENT_CANCEL,#who=self,
               #state=Send(self,@GetEnchantedState,#what=oWhat));

            bCancel = TRUE;
         }

         Send(self,@UserGo,#bCancel=bCancel);

         return;
      }

      if liClient_cmd = BP_REQ_BUY
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserBuy,#what=oWhat);
         }

         return;
      }

      if liClient_cmd = BP_REQ_TRIGGER_QUEST
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserRequestTriggerQuest,#what=oWhat,
                  #oQT=Nth(client_msg,3));
         }

         return;
      }

      if liClient_cmd = BP_REQ_NPC_QUESTS
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserRequestNPCQuests,#what=oWhat);
         }

         return;
      }

      if liClient_cmd = BP_REQ_BUY_ITEMS
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserBuyItems,#what=oWhat,#item_list=Nth(client_msg,3),
                  #number_list=number_stuff);
         }

         return;
      }

      if liClient_cmd = BP_REQ_WITHDRAWAL
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserWithdrawal,#what=oWhat);
         }

         return;
      }

      if liClient_cmd = BP_REQ_WITHDRAWAL_ITEMS
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserWithdrawalItems,#what=oWhat,
                  #item_list=Nth(client_msg,3),#number_list=number_stuff);
         }

         return;
      }

      if liClient_cmd = BP_REQ_DEPOSIT
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserDeposit,#what=oWhat,#item_list=Nth(client_msg,3),
               #number_list=number_stuff);
         }

         return;
      }

      if liClient_cmd = BP_REQ_APPLY
      {
         Send(self,@UserApply,#what=Nth(client_msg,2),
               #apply_on=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_SEND_SPELLS
      {
         Send(self,@ToCliSpells);

         return;
      }

      if liClient_cmd = BP_SEND_SKILLS
      {
         Send(self,@ToCliSkills);

         return;
      }

      if liClient_cmd = BP_REQ_CAST
      {
         Send(self,@UserCast,#oSpell=Nth(client_msg,2),
               #lTargets=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_REQ_PERFORM
      {
         Send(self,@UserPerform,#oSkill=Nth(client_msg,2),
               #lTargets=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_POST_ARTICLE
      {
         Send(self,@UserPost,#nid=Nth(client_msg,2),#title=Nth(client_msg,3),
               #body=Nth(client_msg,4));

         return;
      }

      if liClient_cmd = BP_REQ_ARTICLES
      {
         Send(self,@UserGetNewsTitles,#nid=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_REQ_ARTICLE
      {
         Send(self,@UserGetNewsArticle,#nid=Nth(client_msg,2),
               #num=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_ACTION
      {
         Send(self,@UserAction,#action=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_SEND_STAT_GROUPS
      {
         Send(self,@ToCliStatGroups);

         return;
      }

      if liClient_cmd = BP_SAY_BLOCKED
      {
         Send(self,@UserBlockedSend,#what=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_REQ_LOOKUP_NAMES
      {
         Send(self,@UserLookupNames,#amount=Nth(client_msg,2),
              #string=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_CHANGE_DESCRIPTION
      {
         // oWhat = who's editing.
         oWhat = Nth(client_msg,2);
         sBody = Nth(client_msg,3);

         if oWhat = $
         {
            Debug("Tried setting description of nil object.");

            return;
         }

         // Editing our own description.
         // Or, an admin editing a player's description.
         if oWhat = self
            OR (IsClass(oWhat,&Player) AND IsClass(self,&Admin))
         {
            sBody = Send(SYS,@CleanseString,#string=sBody);
            Send(oWhat,@UserChangeDescription,#string=sBody);

            return;
         }

         oRoom = Send(oWhat,@GetOwner);
         if Send(oWhat,@CanEditInscription)
            AND ((oRoom = self) or (oRoom = poOwner))
         {
            sBody = Send(SYS,@CleanseString,#string=sBody);
            Send(oWhat,@SetInscription,#string=sBody);

            return;
         }

         Debug("Tried setting description of ",oWhat);

         return;
      }

      if liClient_cmd = BP_REQ_ACTIVATE
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserTryActivate,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_SEND_ENCHANTMENTS
      {
         if Nth(client_msg,2) <> ENCHANTMENT_PLAYER
         {
            return;
         }

         Send(self,@SendEnchantmentIcons);

         return;
      }

      if liClient_cmd = BP_CHANGED_STATS
      {
      
         if Length(client_msg) <> 14
         {
            return;
         }

         foreach i in client_msg
         {
            if i = $
            {
               return;
            }
         }

         Send(self,@UserChangedStats, #might=Nth(client_msg,2),
                                       #intellect=Nth(client_msg,3),
                                       #stamina=Nth(client_msg,4),
                                       #agility=Nth(client_msg,5),
                                       #mysticism=Nth(client_msg,6),
                                       #aim=Nth(client_msg,7),
                                       #shallile_lvl=Nth(client_msg,8),
                                       #qor_lvl=Nth(client_msg,9),
                                       #kraanan_lvl=Nth(client_msg,10),
                                       #faren_lvl=Nth(client_msg,11),
                                       #riija_lvl=Nth(client_msg,12),
                                       #jala_lvl=Nth(client_msg,13),
                                       #weaponcraft_lvl=Nth(client_msg,14));
         return;
      }

      Debug(Send(self,@GetTrueName),
            self,"sent unknown command from client",liClient_cmd);

      return;
   }

   PerformGuildDisband()
   "Admin supported.\n"
   "UserCommand() will check to stop a player from disbanding when not "
   "appropriate.  This function will force a disband and clean up anything, "
   "ignoring game rules."
   {
      if poGuild <> $
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         Send(self,@UserGuildCommand,#command_num=GCID_DISBAND);
         return Send(SYS,@GetSuccessRsc);
      }
      
      return Send(SYS,@GetFailureRsc);
   }

   PerformSuicide()
   "Admin supported.\n"
   "UserCommand() will check to stop a player from suiciding when not "
   "appropriate. This function will force a suicide and clean up anything, "
   "ignoring game rules."
   {
      local oObj, sName;

      Send(self,@CancelIfOffer);

      if poGuild <> $
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         // guild master must disband guild if forced to suicide
         Send(self,@PerformGuildDisband);
      }

      oObj = Send(SYS,@GetCaramo);
      if (Send(oObj,@GetJusticar) = self)
      {
         // Justicar must give up office.
         Send(oObj,@SetJusticar,#who=$);
      }

      piLast_Restart_time = GetTime();
      piLastLoginTime = 0;
      psUrl = $;
      plHonor = $;
      piLogoffPenaltyCount = -1;
      piXP_total = 0;
      piTraining_points = 0;

      RecordStat(STAT_PLAYERSUICIDE, poSession, Send(self,@GetTrueName));

      // Change the name to a unique placeholder one.
      ClearTempString();
      AppendTempString("Suicide");
      AppendTempString(GetTime());
      AppendTempString(GetTickCount() % 1000);
      sName = SetString($,GetTempString());
      Debug("Character",Send(self,@GetTrueName),self,"was suicided.");
      Send(SYS,@ChangeUserName,#oUser=self,#sName=sName);

      Send(self,@ResetCharacter);

      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND,1,UC_SEND_QUIT);
         SendPacket(poSession);
      }

      return Send(SYS,@GetSuccessRsc);
   }

   UserCommandSuicide()
   {
      if poGuild <> $
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide);

         return;
      }

      if IsClass(poOwner,&OutOfGrace)
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_OOG);

         return;
      }

      if Send(Send(SYS,@GetCaramo),@GetJusticar) = self
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_justicar);

         return;
      }

      if GetTime() < piLast_restart_time + SUICIDE_REPEAT_TIME
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_yet);

         return;
      }

      if Send(self,@FindHolding,#class=&Token)
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_token);

         return;
      }

      if Send(SETTINGS_OBJECT,@GetMaxSuicideHP) <= piBase_Max_health
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_hp);

         return;
      }

      // Successful SUICIDE.
      Send(self,@PerformSuicide);

      return;
   }

   UserCommandSetSafety(value = 0)
   {
      Send(self,@SetPlayerPreference,#flag=CF_SAFETY_OFF,#value=value);
      if value
      {
         if Send(SYS,@IsPKAllowed)
         {
            Send(self,@MsgSendUser,#message_rsc=user_safety_off);
            Send(self,@WaveSendUser,#what=self,
                  #wave_rsc=user_safety_off_wav_rsc);
         }
      }
      else
      {
         if Send(SYS,@IsPKAllowed)
         {
            Send(self,@MsgSendUser,#message_rsc=user_safety_on);
            Send(self,@WaveSendUser,#what=self,
                  #wave_rsc=user_safety_on_wav_rsc);
         }

      }

      return;
   }

   UserCommandSetTempSafe(value = 0)
   {
      if piBase_max_health > 99
         OR (piFlags & PFLAG_MURDERER)
         OR (piFlags & PFLAG_OUTLAW)
         OR Send(self,@FindUsing,#class=&SoldierShield) <> $
      {
         if value
         {
            piPreferences |= CF_TEMPSAFE;
         }
         else
         {
            piPreferences &= ~CF_TEMPSAFE;
         }
         Send(self,@MsgSendUser,#message_rsc=user_temp_safe_invalid);

         return;
      }

      if value
      {
         piPreferences |= CF_TEMPSAFE;
         Send(self,@MsgSendUser,#message_rsc=user_temp_safe_on);
      }
      else
      {
         piPreferences &= ~CF_TEMPSAFE;
         Send(self,@MsgSendUser,#message_rsc=user_temp_safe_off);
      }

      return;
   }

   UserCommandSetGrouping(value = 0)
   {
      if value
      {
         piPreferences |= CF_GROUPING;
         Send(self,@MsgSendUser,#message_rsc=user_grouping_on);
      }
      else
      {
         piPreferences &= ~CF_GROUPING;
         Send(self,@MsgSendUser,#message_rsc=user_grouping_off);
      }

      return;
   }

   UserCommandSetAutoLoot(value = 0)
   {
      if value
      {
         piPreferences |= CF_AUTOLOOT;
         Send(self,@MsgSendUser,#message_rsc=user_autoloot_on);
      }
      else
      {
         piPreferences &= ~CF_AUTOLOOT;
         Send(self,@MsgSendUser,#message_rsc=user_autoloot_off);
      }

      return;
   }

   UserCommandSetAutoCombine(value = 0)
   {
      if value
      {
         piPreferences |= CF_AUTOCOMBINE;
         Send(self,@MsgSendUser,#message_rsc=user_autocombine_on);
      }
      else
      {
         piPreferences &= ~CF_AUTOCOMBINE;
         Send(self,@MsgSendUser,#message_rsc=user_autocombine_off);
      }

      return;
   }

   UserCommandSetReagentBag(value = 0)
   {
      if value
      {
         piPreferences |= CF_REAGENTBAG;
         Send(self,@MsgSendUser,#message_rsc=user_reagentbag_on);
      }
      else
      {
         piPreferences &= ~CF_REAGENTBAG;
         Send(self,@MsgSendUser,#message_rsc=user_reagentbag_off);
      }

      return;
   }

   UserCommandSetSpellpowerDisplay(value = 0)
   {
      if value
      {
         piPreferences |= CF_SPELLPOWER;
         Send(self,@MsgSendUser,#message_rsc=user_spellpower_on);
      }
      else
      {
         piPreferences &= ~CF_SPELLPOWER;
         Send(self,@MsgSendUser,#message_rsc=user_spellpower_off);
      }

      return;
   }

   UserCommandSetPreferences(value = 0)
   {
      // Check each possible preference, improvement over sending 7 messages
      // from client to server with each preference.
      if (value & CF_SAFETY_OFF) <> (piPreferences & CF_SAFETY_OFF)
      {
         Send(self,@UserCommandSetSafety,#value=value & CF_SAFETY_OFF);
      }

      if (value & CF_TEMPSAFE) <> (piPreferences & CF_TEMPSAFE)
      {
         Send(self,@UserCommandSetTempSafe,#value=value & CF_TEMPSAFE);
      }

      if (value & CF_GROUPING) <> (piPreferences & CF_GROUPING)
      {
         Send(self,@UserCommandSetGrouping,#value=value & CF_GROUPING);
      }

      if (value & CF_AUTOLOOT) <> (piPreferences & CF_AUTOLOOT)
      {
         Send(self,@UserCommandSetAutoLoot,#value=value & CF_AUTOLOOT);
      }

      if (value & CF_REAGENTBAG) <> (piPreferences & CF_REAGENTBAG)
      {
         Send(self,@UserCommandSetReagentBag,#value=value & CF_REAGENTBAG);
      }

      if (value & CF_AUTOCOMBINE) <> (piPreferences & CF_AUTOCOMBINE)
      {
         Send(self,@UserCommandSetAutoCombine,#value=value & CF_AUTOCOMBINE);
      }

      if (value & CF_SPELLPOWER) <> (piPreferences & CF_SPELLPOWER)
      {
         Send(self,@UserCommandSetSpellpowerDisplay,#value=value & CF_SPELLPOWER);
      }

      // Send the preferences back to client, in case a flag couldn't be set.
      Send(self,@UserSendPreferences);

      return;
   }

   UserSendPreferences()
   "Sends the player's stored preferences to the client."
   {
      AddPacket(1,BP_USERCOMMAND, 1,UC_RECEIVE_PREFERENCES, 4,piPreferences);
      SendPacket(poSession);

      return;
   }

   UserCommand(client_msg=$, number_stuff=$)
   {
      local iClient_cmd, oWhat;

      iClient_cmd = First(client_msg);

      // Arranged in decreasing order of frequency.
      switch(iClient_cmd)
      {
         case UC_REST:
            Send(self,@StartResting);
            return;
         case UC_STAND:
            Send(self,@StopResting);
            return;
         case UC_SEND_PREFERENCES:
            Send(self,@UserCommandSetPreferences,#value=Nth(client_msg,2));
            return;
         case UC_REQ_PREFERENCES:
            Send(self,@UserSendPreferences);
            return;
         case UC_REQ_GUILDINFO:
            Send(self,@UserGuildSendInfo);
            return;
         case UC_SUICIDE:
            Send(self,@UserCommandSuicide);
            return;
         case UC_INVITE:
            Send(self,@UserGuildCommand,#command_num=GCID_INVITE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_RENOUNCE:
            Send(self,@UserGuildCommand,#command_num=GCID_RENOUNCE);
            return;
         case UC_EXILE:
            Send(self,@UserGuildCommand,#command_num=GCID_EXILE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_ABDICATE:
            Send(self,@UserGuildCommand,#command_num=GCID_ABDICATE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_VOTE:
            Send(self,@UserGuildCommand,#command_num=GCID_VOTE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_SET_RANK:
            Send(self,@UserGuildCommand,#command_num=GCID_SET_RANK,
                  #oTarget=Nth(client_msg,2),#data=Nth(client_msg,3));
            return;
         case UC_GUILD_CREATE:
            Send(self,@UserCommandCreateGuild,#client_msg=client_msg);
            return;
         case UC_DISBAND:
            Send(self,@UserGuildCommand,#command_num=GCID_DISBAND);
            return;
         case UC_MAKE_ALLIANCE:
            Send(self,@UserGuildCommand,#command_num=GCID_FORGE_ALLIANCE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_END_ALLIANCE:
            Send(self,@UserGuildCommand,#command_num=GCID_END_ALLIANCE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_MAKE_ENEMY:
            Send(self,@UserGuildCommand,#command_num=GCID_DECLARE_ENEMY,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_END_ENEMY:
            Send(self,@UserGuildCommand,#command_num=GCID_PEACE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_REQ_GUILD_LIST:
            Send(self,@UserGuildSendList);
            return;
         case UC_GUILD_SHIELDS:
            Send(self,@UserGuildSendShieldSamples);
            return;
         case UC_GUILD_SHIELD:
            Send(self,@UserGuildSendShieldInfo,#oGuild=poGuild);
            return;
         case UC_CLAIM_SHIELD:
            Send(self,@UserCommandClaimShield,#client_msg=client_msg);
            return;
         case UC_GUILD_RENT:
            Send(self,@UserCommandGuildRent,#oHall=Nth(client_msg,2),
                  #sPassword=Nth(client_msg,3));
            return;
         case UC_ABANDON_GUILD_HALL:
            Send(self,@UserGuildCommand,#command_num=GCID_ABANDON_HALL);
            return;
         case UC_GUILD_SET_PASSWORD:
            Send(self,@UserGuildCommand,#command_num=GCID_SET_PASSWORD,
                  #data=Nth(client_msg,2));
            return;
         case UC_CHANGE_URL:
            oWhat = Nth(client_msg,2);

            if oWhat <> self
               AND NOT IsClass(oWhat,&Admin)
            {
               Debug(self,"tried to change url of",Nth(client_msg,2));

               return;
            }
            Send(self,@UserChangeURL,#string=Nth(client_msg,3));

            return;
         case UC_DEPOSIT:
            if NOT Send(poOwner,@SomeoneTryUserCommand,#who=self,
                        #command=UC_DEPOSIT,#data=Nth(client_msg,2))
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_deposit);
            }

            return;
         case UC_WITHDRAW:
            if NOT Send(poOwner,@SomeoneTryUserCommand,#who=self,
                        #command=UC_WITHDRAW,#data=Nth(client_msg,2))
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_withdraw);
            }

            return;
         case UC_BALANCE:
            if NOT Send(poOwner,@SomeoneTryUserCommand,#who=self,
                        #command=UC_BALANCE)
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_balance);
            }

            return;
         case UC_APPEAL:
            Send(self,@UserAppeal,#string=Nth(client_msg,2));
            return;
         case UC_REQ_RESCUE:
            if poOwner <> $
               AND Send(poOwner,@GetRoomNum) = Send(self,@GetHomeroom)
            {
               AddPacket(1,BP_USERCOMMAND,1,UC_SEND_QUIT);
               SendPacket(poSession);

               return;
            }

            Send(self,@AdminGotoSafety);
            Debug(self,"was just sent to safety because their client had a "
                  "broken room",poOwner);

            return;
         case UC_MINIGAME_STATE:
            Send(Nth(client_msg,2),@GotNewState,#who=self,
                 #state=Nth(client_msg,3));
            return;
         case UC_MINIGAME_RESET_PLAYERS:
            Send(Nth(client_msg,2),@ResetPlayers,#who=self);
            return;
         case UC_REQ_TIME:
               ClearTempString();
               Send(SYS,@AppendOrdinalToTempString,#number=Send(SYS,@GetDay));
               Send(self,@MsgSendUser,
                  #message_rsc=user_time_string,
                  #parm1=Send(SYS,@GetHour),
                  #parm2=GetTempString(),
                  #parm3=Send(SYS,@GetYear)
                  );
         return;

         default:
            Debug("User.kod got unknown UserCommand command from client",
               iClient_cmd);
            return;
      }

      return;
   }

   UserCommandGuildRent(oHall = $, sPassword = $)
   {
      local iCost, oMoney;

      if poGuild = $
         OR oHall = $
         OR sPassword = $
      {
         return;
      }

      iCost = Send(oHall,@GetPurchaseValue,#who=self);
      oMoney = Send(self,@GetMoneyObject);

      if oMoney = $ OR Send(oMoney,@GetNumber) < iCost
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guildhall_broke);
         
         return FALSE;
      }

      if Send(oHall,@ClaimGuildHall,#oGuild=poGuild,#rep=self,
               #password=sPassword)
      {
          Send(oMoney,@SubtractNumber,#number=iCost);
      }

      return;
   }

   UserCommandClaimShield(client_msg = $)
   {
      local oGuild;

      if client_msg = $
      {
         return;
      }

      // Check if they have a guild.
      if poGuild = $
      {
         return;
      }

      // Find the guild from the color info.
      oGuild = Send(SYS,@FindGuildByShield,#color1=Nth(client_msg,2),
                     #color2=Nth(client_msg,3),#shape=Nth(client_msg,4));

      if oGuild = $
         AND Nth(client_msg,5) <> FALSE
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         if (NOT Send(poGuild,@SetGuildColors,#who=self,#color1=Nth(client_msg,2),
                     #color2=Nth(client_msg,3),#shape=Nth(client_msg,4)))
         {
            // Don't need to update shield if this fails.
            return;
         }
         // Set our guild as the owner of the shield.
         oGuild = poGuild;
      }

      Send(self,@UserGuildSendShieldInfo,#oguild=oGuild,
            #color1=Nth(client_msg,2),#color2=Nth(client_msg,3),
            #shape=Nth(client_msg,4));

      return;
   }

   UserGuildSendShieldError(iTime = 0)
   {
      local rTime;

      if (iTime <= 0)
      {
         // Send a resource saying shields can't be changed.
         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_SHIELD_ERROR,
                   4,user_guild_shield_error_disabled);
      }
      else
      {
         if (iTime > DAY * 2)
         {
            rTime = user_time_days;
            iTime /= DAY;
         }
         else if (iTime > HOUR * 2)
         {
            rTime = user_time_hours;
            iTime /= HOUR;
         }
         else if (iTime > MINUTE * 2)
         {
            rTime = user_time_minutes;
            iTime /= MINUTE;
         }
         else if (iTime = 1)
         {
            rTime = user_time_second;
         }
         else
         {
            rTime = user_time_seconds;
         }

         // Send a resource with the time string.
         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_SHIELD_ERROR,
                   4,user_guild_shield_error_time, 4,iTime, 4,rTime);
      }

      SendPacket(poSession);

      return;
   }

   UserCommandCreateGuild(client_msg = $)
   {
      local i, oMoney, iCost;

      if client_msg = $
      {
         return;
      }

      oMoney = Send(self,@GetMoneyObject);

      // Secret guild?
      if Nth(client_msg,13)
      {
         iCost = Send(SYS,@GetGuildSecretPrice);
      }
      else
      {
         iCost = Send(SYS,@GetGuildPrice);
      }

      if oMoney = $
         OR Send(oMoney,@GetNumber) < iCost
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild_broke);

         return FALSE;
      }

      if Send(SYS,@FindGuildByString,#string=Nth(client_msg,2)) <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_duplicate_guildname);

         return FALSE;
      }

      // Check if equal to a user name.
      if Send(SYS,@FindUserByString,#string=Nth(client_msg,2)) <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_duplicate_guild_username);

         return FALSE;
      }

      // Validate string lengths
      if StringLength(Nth(client_msg, 2)) < 1
      {
         Debug(self, "had guild name too short");

         return FALSE;
      }
      if StringLength(Nth(client_msg, 2)) > MAX_GUILD_NAME_LEN
      {
         Debug(self, "had guild name too long");

         return FALSE;
      }
      i = 3;
      while (i <= 12)
      {
         if StringLength(Nth(client_msg, i)) > MAX_GUILD_RANK_LEN
         {
            Debug(self, "had guild rank too long");

            return FALSE;
         }
         ++i;
      }

      Create(&Guild,#master=self,#guildname=Nth(client_msg,2),
                    #secret=Nth(client_msg,13),
                    #rApprentice_male=Nth(client_msg,3),
                    #rApprentice_female=Nth(client_msg,4),
                    #rSir=Nth(client_msg,5),#rMadame=Nth(client_msg,6),
                    #rLord=Nth(client_msg,7),#rLady=Nth(client_msg,8),
                    #rLieutenant_male=Nth(client_msg,9),
                    #rLieutenant_female=Nth(client_msg,10),
                    #rMaster=Nth(client_msg,11),
                    #rMistress=Nth(client_msg,12));

      Send(oMoney,@SubtractNumber,#number=iCost);

      return;
   }

   UserGuildSendInfo()
   {
      local i,lRank_names,lMembers,lHall;

      if poGuild = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild);
         return;
      }

      AddPacket(1,BP_USERCOMMAND, 1,UC_GUILDINFO, 6,Send(poGuild,@GetName));
      lHall = Send(poGuild,@GetGuildHall);
      if lHall <> $ AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         AddPacket(1,1, 6,Send(poGuild,@GetPassword));
      }
      else
      {
         AddPacket(1,0);
      }

      AddPacket(4,piGuild_commands, 4,poGuild);

      lRank_names = Send(poGuild,@GetRankNames);
      foreach i in lRank_names
      {
         AddPacket(STRING_RESOURCE,i);
      }

      // member list is list of lists--first item of sublist is object id
      lMembers = Send(poGuild,@GetMemberList);

      // Need to find ourself in here to get our vote
      foreach i in lMembers
      {
         if First(i) = self
         {
            if Nth(i,3) = $
            {
               // not supporting anyone
               AddPacket(4,0);
            }
            else
            {
               AddPacket(4,Nth(i,3));
            }
         }
      }

      AddPacket(2,Length(lMembers));
      foreach i in lMembers
      {
         AddPacket(4,First(i), STRING_RESOURCE,Send(First(i),@GetTrueName),
                   1,Nth(i,2), 1,Send(First(i),@GetGender));
      }

      SendPacket(poSession);

      return;
   }

   UserGuildSendList()
   {
      local lGuilds, i;

      // Must be guilded to receive guild list.
      if poGuild = $
      {
         return;
      }

      if pbLogged_on
      {
         lGuilds = Send(SYS,@GetGuilds);
         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_LIST, 2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i,6,Send(i,@GetName));
         }

         lGuilds = Send(poGuild,@GetAllyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         lGuilds = Send(poGuild,@GetEnemyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         lGuilds = Send(poGuild,@GetDeclaredAllyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         lGuilds = Send(poGuild,@GetDeclaredEnemyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         SendPacket(poSession);
      }

      return;
   }

   UserGuildSendShieldSamples()
   {
      local lSamples,i;

      // Only do this if the user is guilded.
      if poGuild <> $
      {
         if pbLogged_on
         {
            lSamples = Send(SYS,@GetGuildShieldSamples);
            AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_SHIELDS, 2,Length(lSamples));
            foreach i in lSamples
            {
               AddPacket(4,i);
            }

            SendPacket(poSession);
         }
      }

      return;
   }

   UserGuildSendShieldInfo(oguild=$,color1=$,color2=$,shape=$)
   {
      local owner;

      owner = oguild;

      // If the user isn't guilded, don't show them this info.
      if poGuild = $
      {
         return;
      }

      if (oGuild = $) or (not IsClass(oGuild,&Guild))
      {
         oGuild = poGuild;
      }

      if color1 = $
      {
         color1 = Send(oguild,@GetPrimaryGuildColor);
         color2 = Send(oguild,@GetSecondaryGuildColor);
         shape = Send(oguild,@GetShieldShape);
      }

      // Note this is Sending THIS user some info about ANY guild's shield.
      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND,1,UC_GUILD_SHIELD);
         if owner <> $
         {
            AddPacket(4,owner, 6,Send(oGuild,@GetName));
         }
         else
         {
            // Unclaimed guild Sends 0 for guild id but MY guild's name to
            // fulfil protocol
            AddPacket(4,0, 6,Send(oGuild,@GetName));
         }

         AddPacket(1,color1,1,color2,1,shape);

         SendPacket(poSession);
      }

      return;
   }

   GarbageCollecting()
   {
      Send(self,@CancelIfOffer);

      Send(self,@SysMsgSendUser,#message_rsc=user_garbage_collecting);
      //Send(self,@WaveSendUser,#what=self,#wave_rsc=user_saving_wav_rsc);

      AddPacket(1,BP_WAIT);
      SendPacket(poSession);

      return;
   }

   InvalidateData()
   "Admin supported.\n"
   "Sends the client a BP_INVALIDATE_DATA, so they reacquire player & room "
   "info."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_INVALIDATE_DATA);
         SendPacket(poSession);
      }

      return Send(SYS,@GetSuccessRsc);
   }

   GarbageCollectingDone()
   {
      Send(self,@InvalidateData);

      Send(self,@SysMsgSendUser,#message_rsc=user_garbage_collecting_done);

      // Let the user know whether safety is on or off.
      if piPreferences & CF_SAFETY_OFF
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_off);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_on);
      }

      AddPacket(1,BP_UNWAIT);
      SendPacket(poSession);

      Send(self,@SendUserAllWindowOverlays);

      return;
   }

   UserLogonSetPosition()
   {
      local i, oNew_room, iQflags, iRflags, iHeightF, iHeightFWD, iHeightC,
            iServerID;

      if piSave_room <> $
      {
         oNew_room = Send(SYS,@FindRoomByNum,#num=piSave_room);
         if oNew_room <> $
         {
            Send(oNew_room,@NewHold,#what=self,
                  #new_row=piSave_row,#new_col=piSave_col,
                  #fine_row=piSave_fine_row,
                  #fine_col=piSave_fine_col,
                  #new_angle=piSave_angle);

            // query height at current location from ROO
            iQflags = LIQ_GET_SECTORINFO;

            if (NOT GetLocationInfoBSP(Send(oNew_room,@GetRoomData), iQflags,
               piSave_row,piSave_col, piSave_fine_row, piSave_fine_col,
               *iRflags, *iHeightF, *iHeightFWD, *iHeightC, *iServerID))
            {
               Debug("Failed to get location info in ",
                     Send(oNew_room,@GetRoomData));
            }

            // save floor and ceiling heights and sector id
            piHeightFWD = iHeightFWD;
            piHeightC   = iHeightC;
            piSectorID  = iServerID;
            piHeight = piHeightFWD;

            return;
         }
      }

      if piSave_room <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_couldnt_replace);
      }

      Send(self,@AdminGoToSafety);

      return;
   }

   UserLogonHook()
   {
      local i;

      foreach i in Send(SYS,@GetBackgroundObjects)
      {
         Send(i,@AddBackgroundObject,#who=self);
      }

      Send(self,@LoadMailNews);

      // Count right now as the last time we moved.
      piLastMoveUpdateTime = GetTickCount();

      propagate;
   }

   LoadMailNews()
   {
      Send(self,@UserLoadModule,#module=user_mailnews_module);

      return;
   }

   UserLoadModule(module = $)
   {
      AddPacket(1,BP_LOAD_MODULE,4,module);
      SendPacket(poSession);

      return;
   }

   UserUnloadModule(module = $)
   {
      if NOT pbLogged_on
      {
         return;
      }

      AddPacket(1,BP_UNLOAD_MODULE,4,module);
      SendPacket(poSession);

      return;
   }

   UserGameStart(game = $, player_num = 1)
   {
      AddPacket(1,BP_USERCOMMAND, 1,UC_MINIGAME_START, 4,game,1,player_num);
      SendPacket(poSession);

      return;
   }

   UserGotoDeadRoom()
   {
      local oNew_room;

      if pbLogged_On
      {
         oNew_room = Send(SYS,@FindRoomByNum,#num=RID_UNDERWORLD);
         if NOT Send(SYS,@UtilGoNearSquare,#what=self,#where=oNew_room,
                     #new_row=24,#new_col=10,
                     #fine_row=38,#fine_col=54,#new_angle=3072)
         {
            Debug("UserGotoDeadRoom unable to Send user to dead room",
                  self,vrName);
            return Send(SYS,@GetFailureRsc);
         }
      }
      else
      {
         Debug("Player died while offline: ",Send(self,@GetTrueName));
         piSave_Room = RID_UNDERWORLD;
         piSave_Row = 24;
         piSave_Col = 10;
         piSave_Fine_Row = 38;
         piSave_Fine_Col = 54;
         piSave_Angle = 3072;
      }

      Send(self,@WipeUnboundEnergy);

      return Send(SYS,@GetSuccessRsc);
   }

   ToCliFlags(what=$,parm1=$)
   "Sends just the ObjectFlags (OF, DF, MM, NC, OT, MT) for 'what'."
   "parm1 is optional parameter if more information is required to resolve "
   "flag status."
   {
      local iFlags, iEnemyKarma, iSelfKarma, iMinimapFlags, iDrawingFlags;

      iDrawingFlags = Send(what,@GetDrawingEffects);
      iFlags = Send(what,@GetObjectFlags,#what=self);
      // If we can see the invisible object, remove its invis drawing flag
      // and set it to flash instead (in object flags).
      if (piFlags2 & PFLAG2_DETECT_INVIS)
         AND (iDrawingFlags & DRAWFX_MASK) = DRAWFX_INVISIBLE
      {
         iDrawingFlags &= (~DRAWFX_MASK);
         iFlags &= (~OF_FLICKERING);
         iFlags |= OF_FLASHING;
      }

      if IsClass(what,&Battler)
      {
         iEnemyKarma = Send(what,@GetKarma,#detect=TRUE);
         iSelfKarma = Send(self,@GetKarma);

         if (piFlags2 & PFLAG2_DETECT_EVIL)
            AND iSelfKarma > 0
            AND iEnemyKarma < -10
         {
            iFlags &= (~OF_FLICKERING);
            iFlags |= OF_FLASHING;
         }

         if (piFlags2 & PFLAG2_DETECT_GOOD)
            AND iSelfKarma < 0
            AND iEnemyKarma > 10
         {
            iFlags &= (~OF_FLICKERING);
            iFlags |= OF_FLASHING;
         }
      }

      iMinimapFlags = Send(self,@BuildMinimapDotFlag,#what=what);
      if iMinimapFlags = $
      {
         Debug("Got $ minimapflags for self ",self,Send(self,@GetTrueName),
            " for object ",what,Send(what,@GetTrueName));
         iMinimapFlags = 0;
      }

      AddPacket(4,iFlags, 1,iDrawingFlags, 4,iMinimapFlags,
                4,Send(what,@GetPlayerNameColor),
                1,Send(what,@GetClientObjectType,#who=self,#parm1=parm1),
                1,Send(what,@GetMoveOnType));

      return;
   }

   ToCliObject(what=$,show_type=SHOW_NORMAL,bShow_all=FALSE,parm1=$)
   "show_type is used to get the look or inventory animation and overlays "
   "instead of the normal animation and overlays. parm1 is optional parameter "
   "passed on to ToCliFlags."
   {
      // Send given object's id number, name, icon, and animation info
      if Send(what,@IsStackable)
      {
         AddPacket(NUMBER_OBJECT,what, 4,Send(what,@GetNumber),
                   4,Send(what,@GetIcon));
      }
      else
      {
         AddPacket(4, what, 4,Send(what,@GetIcon));
      }

      // Used for the reveal spell.  Do we show the true name, or the apparent
      // name?
      if bShow_All
      {
         AddPacket(4,Send(what,@GetTrueName));
      }
      else
      {
         AddPacket(4,Send(what,@GetApparentName));
      }

      Send(self,@ToCliFlags,#what=what,#parm1=parm1);

      // Send the lighting information.
      Send(what,@SendLightingInformation);

      if show_type = SHOW_LOOK
      {
         Send(what,@SendLookAnimation);
         Send(what,@SendLookOverlays);
      }
      else if show_type = SHOW_INVENTORY
      {
         Send(what,@SendInventoryAnimation);
         Send(what,@SendInventoryOverlays);
      }
      else if show_type = SHOW_NORMAL
      {
         Send(what,@SendAnimation);
         Send(what,@SendOverlays);
      }
      else if show_type = SHOW_ENCHANTMENT
      {
         Send(what,@SendEnchantmentAnimation);
         Send(what,@SendEnchantmentOverlays);
      }

      return;
   }

   BuildMinimapDotFlag(what=$)
   "This message builds the minimap dot flags for each object we can see, "
   "which is then sent to our client for drawing objects on the map/minimap."
   {
      local iBehavior, iFlags, oIllusion, oOtherGuild, oTarget, oMaster;

      if what = $
         OR poOwner <> Send(what,@GetOwner)
      {
         return MM_NONE;
      }

      // Choose our own line color on minimap.
      if (what = self)
      {
         if (piFlags & PFLAG_TEMPSAFE)
         {
            return MM_TEMPSAFE;
         }
         else if (piFlags & PFLAG_PERMA_NO_PVP)
         {
            return MM_NO_PVP;
         }

         return MM_NONE;
      }

      if IsClass(what,&Reflection)
         OR IsClass(what,&EvilTwin)
      {
         if (Send(what,@GetBehavior) & AI_NPC)
         {
            return MM_NPC;
         }

         what = Send(what,@GetMaster);
         if what = $
            OR what = self
         {
            return MM_PLAYER;
         }
      }

      iFlags = MM_NONE;

      if IsClass(what,&User)
      {
         if Send(what,@IsInCannotInteractMode)
         {
            return MM_NONE;
         }

         oIllusion = Send(what,@GetIllusionForm);

         if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
            OR oIllusion = $
            OR NOT IsClass(oIllusion,&Monster)
         {
            if Send(Send(SYS,@GetWarEvent),@IsActive)
            {
               if Send(Send(SYS,@GetWarEvent),@IsSameSide,#player1=self,#player2=what)
               {
                  return MM_PLAYER | MM_PLAYER_IS_FRIEND;
               }

               return MM_PLAYER | MM_PLAYER_IS_ENEMY;
            }

            // Player dot color.
            if Send(what,@CheckPlayerFlag,#flag=PFLAG_TEMPSAFE)
            {
               // Light blue dot.
               iFlags |= MM_TEMPSAFE;
            }
            else if Send(what,@CheckPlayerFlag,#flag=PFLAG_PERMA_NO_PVP)
            {
               // White dot.
               iFlags |= MM_NO_PVP;
            }
            else
            {
               // Standard blue dot.
               iFlags |= MM_PLAYER;
            }

            oOtherGuild = Send(what,@GetGuild);
            if poGuild <> $ AND oOtherGuild <> $
            {
               if poGuild = oOtherGuild
               {
                  iFlags |= MM_PLAYER_IS_GUILDMATE;
               }

               if Send(poGuild,@IsAlly,#otherguild=oOtherGuild)
                  AND Send(oOtherGuild,@IsAlly,#otherguild=poGuild)
               {
                  iFlags |= MM_PLAYER_IS_FRIEND;
               }

               if Send(poGuild,@IsMutualEnemy,#otherguild=oOtherGuild)
               {
                  // Only flag enemy guild if attackable.
                  if (iFlags & MM_PLAYER)
                  {
                     iFlags |= MM_PLAYER_IS_ENEMY;
                  }
               }
            }

            // Draw a red halo for any attackable player.
            if NOT IsClass(self,&DM)
               AND Send(self,@AllowBattlerAttack,#victim=what,
                        #report=FALSE,#actual=FALSE)
            {
               iFlags |= MM_PLAYER_IS_ENEMY;
            }

            // Add builder group halo.
            if Send(poOwner,@AreGroupedHere,#who=self,#what=what)
            {
               iFlags |= MM_BUILDER_GROUP;
            }
         }
         else
         {
            iFlags |= MM_MONSTER;

            oTarget = Send(what,@GetTarget);

            if (oTarget <> $)
            {
               if (oTarget = self)
               {
                  iFlags |= MM_AGGRO_SELF;
               }
               else
               {
                  iFlags |= MM_AGGRO_OTHER;
               }
            }
         }
      }

      if IsClass(what,&Monster)
      {
         if Send(what,@GetBehavior) & AI_NPC
         {
            // Highlight quest-related NPCs.
            // NPCs that are part of active quests
            // override NPCs that have potential quests.
            if (Send(self,@UserDisplayNPCQuestActive,#what=what))
            {
               return MM_NPC | MM_NPCCURRENTQUEST;
            }
            if (Send(what,@HasQuestsForUser,#who=self))
            {
               return MM_NPC | MM_NPCHASQUEST;
            }

            // Draw plain dots for non-quest NPCs.
            return MM_NPC;
         }
         else if (Send(self,@UserDisplayMobQuestActive,#what=what))
         {
            iFlags |= MM_MOBKILLQUEST;
         }

         oTarget = Send(what,@GetTarget);

         if (oTarget <> $)
         {
            if (oTarget = self)
            {
               iFlags |= MM_AGGRO_SELF;
            }
            else
            {
               iFlags |= MM_AGGRO_OTHER;
            }
         }

         oMaster = Send(what,@GetMaster);

         if oMaster <> $
         {
            if (oMaster = self)
            {
               iFlags |= MM_MINION_SELF;
            }
            else if IsClass(oMaster,&Player)
            {
               iFlags |= MM_MINION_OTHER;
            }
         }

         if Send(what,@GetLeader) = self
         {
            iFlags |= MM_MERCENARY;
         }
         else if IsClass(what,&Follower)
         {
            // For anyone but the leader, followers are simply NPCs.
            return MM_NPC;
         }

         if IsClass(poOwner,&SurvivalRoom)
         {
            // Survival room specific dots.
            if Send(poOwner,@IsMiniBoss,#what=what)
            {
               iFlags |= MM_MINIBOSS;
            }
            if Send(poOwner,@IsBoss,#what=what)
            {
               iFlags |= MM_BOSS;
            }
         }

         iFlags |= MM_MONSTER;

         return iFlags;
      }

      // Not a monster or a player. Ask the object what flags it has.
      iFlags |= Send(what,@GetMinimapDotFlags);

      return iFlags;
   }

   ToCliPlayer()
   {
      local rMusic, iLight, rBackground;

      AddPacket(1,BP_PLAYER, 4,self, 4,vrIcon, 4,vrName, 4,poOwner,
                4,Send(poOwner,@GetRoomResource), 4,Send(poOwner,@GetName),
                4,Send(poOwner,@GetRoomSecurity), 1,Send(poOwner,@GetRoomLight),
                1,Bound(piLight,0,255));

      rBackground = Send(poOwner,@GetRoomBackground);
      if rBackground <> $
      {
         AddPacket(4,rBackground);
      }
      else
      {
         AddPacket(4,0);
      }

      Send(poOwner,@SendExtraRoomInfo);

      SendPacket(poSession);

      Send(poOwner,@SendLoopingSounds,#who=self);

      Send(self,@ToCliShading);
      Send(poOwner,@SendSectorChanges,#who=self);
      Send(poOwner,@SendSectorFlagChanges,#who=self);
      Send(poOwner,@SendSectorLightChanges,#who=self);
      Send(poOwner,@SendWallChanges,#who=self);
      Send(poOwner,@SendTextureChanges,#who=self);
      Send(self,@SendUserAllWindowOverlays);
      // Check weather here also.
      Send(self,@WeatherChanged);
      Send(self,@MovementSpeedSendUser);

      return;
   }

   ToCliShading()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_LIGHT_SHADING,
                   1,Send(poOwner,@GetDirectionalLightIntensity),
                   2,Send(poOwner,@GetDirectionalLightAngle),
                   2,Bound(Send(poOwner,@GetDirectionalLightHeight),0,$));
         SendPacket(poSession);
      }

      return;
   }

   ToCliPlayers()
   "Sends client a list of all users logged on, including object id, "
   "resource id, and actual string of the resource (since it's a dynarsc)."
   "Admin class has an override as all players are visible."
   {
      local i, lUsers, rName;

      foreach i in Send(SYS,@GetUsersLoggedOn)
      {
         // Skip hidden DMs.
         if (IsClass(i,&DM) AND Send(i,@IsHidden))
         {
            continue;
         }

         lUsers = Cons(i,lUsers);
      }

      AddPacket(1,BP_PLAYERS,2,Length(lUsers));
      foreach i in lUsers
      {
         rName = Send(i,@GetTrueName);

         AddPacket(4,i, 4,rName, STRING_RESOURCE,rName,
                   4,Send(i,@GetObjectFlags),
                   1,Send(i,@GetDrawingEffects) & ~DRAWFX_INVISIBLE,
                   4,0, // minimapflags, don't need the value here.
                   4,Send(i,@GetPlayerNameColor),
                   1,Send(i,@GetClientObjectType),
                   1,0); // MoveOn type, don't need it here.
      }

      SendPacket(poSession);

      return;
   }

   ToCliGoodKarma()
   {
      local i, iEnemyKarma, iSelfKarma, each_obj, objs;

      if (NOT pbLogged_on)
      {
         return;
      }

      objs = 0;

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&Battler)
         {
            iEnemyKarma = Send(each_obj,@GetKarma,#detect=TRUE);
            iSelfKarma = Send(self,@GetKarma);

            if iSelfKarma < 0
               AND iEnemyKarma > 10
            {
               ++objs;
            }
         }
      }

      AddPacket(1,BP_ROOM_CONTENTS_FLAGS, 4,poOwner, 2,objs);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&Battler)
         {
            iEnemyKarma = Send(each_obj,@GetKarma,#detect=TRUE);
            iSelfKarma = Send(self,@GetKarma);

            if iSelfKarma < 0
               AND iEnemyKarma > 10
            {
               AddPacket(4,each_obj);
               Send(self,@ToCliFlags,#what=each_obj);
            }
         }
      }

      return;
   }

   ToCliEvilKarma()
   {
      local i, iEnemyKarma, iSelfKarma, each_obj, objs;

      if (NOT pbLogged_on)
      {
         return;
      }

      objs = 0;

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&Battler)
         {
            iEnemyKarma = Send(each_obj,@GetKarma,#detect=TRUE);
            iSelfKarma = Send(self,@GetKarma);

            if iSelfKarma > 0
               AND iEnemyKarma < -10
            {
               ++objs;
            }
         }
      }

      AddPacket(1,BP_ROOM_CONTENTS_FLAGS, 4,poOwner, 2,objs);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&Battler)
         {
            iEnemyKarma = Send(each_obj,@GetKarma,#detect=TRUE);
            iSelfKarma = Send(self,@GetKarma);

            if iSelfKarma > 0
               AND iEnemyKarma < -10
            {
               AddPacket(4,each_obj);
               Send(self,@ToCliFlags,#what=each_obj);
            }
         }
      }

      return;
   }

   ToCliInvisible()
   "Send BP_ROOM_CONTENTS_FLAGS and the flags of each invisible room object.  "
   "Called when DI is cast on us or when it wears off.  Faster than sending "
   "a lot of unnecessary data."
   {
      local i, each_obj, objs;

      if (NOT pbLogged_on)
      {
         return;
      }

      objs = 0;

      foreach i in Send(poOwner,@GetHolderPassive)
      {
         each_obj = First(i);
         if (Send(each_obj,@GetDrawingEffects) = DRAWFX_INVISIBLE)
         {
            ++objs;
         }
      }
      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);

         // Don't do stealthed DMs, only do invisible players.
         if IsClass(each_obj,&DM)
            AND Send(each_obj,@IsDMStealthed)
            AND each_obj <> self
         {
            continue;
         }

         if (Send(each_obj,@GetDrawingEffects) = DRAWFX_INVISIBLE)
         {
            ++objs;
         }
      }

      AddPacket(1,BP_ROOM_CONTENTS_FLAGS, 4,poOwner, 2,objs);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);

         // Don't do stealthed DMs.
         if IsClass(each_obj,&DM)
            AND Send(each_obj,@IsDMStealthed)
            AND each_obj <> self
         {
            continue;
         }
         if (Send(each_obj,@GetDrawingEffects) = DRAWFX_INVISIBLE)
         {
            AddPacket(4,each_obj);
            Send(self,@ToCliFlags,#what=each_obj);
         }
      }

      foreach i in Send(poOwner,@GetHolderPassive)
      {
         each_obj = First(i);
         if (Send(each_obj,@GetDrawingEffects) = DRAWFX_INVISIBLE)
         {
            AddPacket(4,each_obj);
            Send(self,@ToCliFlags,#what=each_obj);
         }
      }

      SendPacket(poSession);

      return;
   }

   ToCliRoomContentsFlags()
   "Sends BP_ROOM_CONTENTS_FLAGS for all objects in the room.  "
   "Like ToCliRoomContents, but just for ObjectFlags."
   {
      local i, objs, oThing;

      if NOT pbLogged_On
      {
         return;
      }

      objs = Length(Send(poOwner,@GetHolderPassive));

      // We might not include all active.
      foreach i in Send(poOwner,@GetHolderActive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);

         // Don't do stealthed DMs.
         if IsClass(oThing,&DM)
            AND Send(oThing,@IsDMStealthed)
            AND oThing <> self
         {
            continue;
         }

         ++objs;
      }

      AddPacket(1,BP_ROOM_CONTENTS_FLAGS, 4,poOwner, 2,objs);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);

         // Don't do stealthed DMs.
         if IsClass(oThing,&DM)
            AND Send(oThing,@IsDMStealthed)
            AND oThing <> self
         {
            continue;
         }

         AddPacket(4,oThing);
         Send(self,@ToCliFlags,#what=oThing);
      }

      foreach i in Send(poOwner,@GetHolderPassive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);
         AddPacket(4,oThing);
         Send(self,@ToCliFlags,#what=oThing);
      }

      SendPacket(poSession);

      return;
   }

   ToCliRoomContents()
   {
      local i, objs, oThing;

      if NOT pbLogged_On
      {
         return;
      }

      objs = Length(Send(poOwner,@GetHolderPassive));

      // We might not include all passive.
      foreach i in Send(poOwner,@GetHolderActive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);

         // Don't do stealthed DMs.
         if IsClass(oThing,&DM)
            AND Send(oThing,@IsDMStealthed)
            AND oThing <> self
         {
            continue;
         }

         ++objs;
      }

      AddPacket(1,BP_ROOM_CONTENTS, 4,poOwner, 2,objs);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);

         // Don't do stealthed DMs.
         if IsClass(oThing,&DM)
            AND Send(oThing,@IsDMStealthed)
            AND oThing <> self
         {
            continue;
         }

         Send(self,@ToCliObject,#what=oThing);
         AddPacket(2,Nth(i,3)*FINENESS+Nth(i,5), 2,Nth(i,4)*FINENESS+Nth(i,6),
                   2,Send(oThing,@GetAngle));
         Send(oThing,@SendMoveAnimation);
         Send(oThing,@SendMoveOverlays);
      }

      foreach i in Send(poOwner,@GetHolderPassive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);
         Send(self,@ToCliObject,#what=oThing);
         AddPacket(2,Nth(i,3)*FINENESS+Nth(i,5), 2,Nth(i,4)*FINENESS+Nth(i,6),
                   2,Send(oThing,@GetAngle));
         Send(oThing,@SendMoveAnimation);
         Send(oThing,@SendMoveOverlays);
      }

      SendPacket(poSession);

      // the client resets room icons when it gets BP_ROOM_CONTENTS, so
      // add them back here

      Send(poOwner,@SendEnchantmentIcons,#what=self);

      return;
   }

   ToCliInventory()
   {
      local i,each_obj;

      AddPacket(1,BP_INVENTORY, 2,Length(plActive)+Length(plPassive));

      foreach i in plActive
      {
        Send(self,@ToCliObject,#what=i,#show_type=SHOW_INVENTORY);
      }

      i = Length(plPassive);
      while i > 0
      {
         each_obj = Nth(plPassive,i);
         Send(self,@ToCliObject,#what=each_obj,#show_type=SHOW_INVENTORY);
         --i;
      }

      SendPacket(poSession);

      return;
   }

   ToCliUseList()
   {
      local i;

      AddPacket(1,BP_USE_LIST, 2,Length(plUsing));

      foreach i in plUsing
      {
         AddPacket(4,i);
      }

      SendPacket(poSession);

      return;
   }

   ToCliStats(group = $)
   {
      local i, oSpell, oSkill, iCount, lResists, iQLength, iFailedQLength;

      if NOT pbLogged_on
      {
         return;
      }

      if group = STAT_GROUP_MAIN
      {
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,4);
         Send(self,@SendStatHealth);
         Send(self,@SendStatMana);
         Send(self,@SendStatVigor);
         Send(self,@SendStatXP);
         SendPacket(poSession);

         return;
      }

      if group = STAT_GROUP_STATS
      {
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,27);

         Send(self,@SendStatMight);
         Send(self,@SendStatIntellect);
         Send(self,@SendStatStamina);
         Send(self,@SendStatAgility);
         Send(self,@SendStatMysticism);
         Send(self,@SendStatAim);
         Send(self,@SendStatKarma);
         Send(self,@SendStatTraining);
         Send(self,@SendStatBulk);
         Send(self,@SendStatCapacity);
         Send(self,@SendStatOffense);
         Send(self,@SendStatDefense);
         Send(self,@SendStatArmor);

         lResists = Send(self,@GetCurrentResistances);

         for (i = 1; i < 14; ++i)
         {
            Send(self,@SendStatResistances,#num=i,#lCurrentResistances=lResists);
         }

         Send(self,@SendStatUnboundEnergy);

         SendPacket(poSession);

         return;
      }

      if group = STAT_GROUP_SPELLS
      {
         AddPacket(1,BP_STAT_GROUP, 1,group,1, Length(plSpells));
         iCount = 1;
         foreach i in plSpells
         {
            Send(self,@SendStatSpell,#index=iCount);
            ++iCount;
         }

         SendPacket(poSession);

         return;
      }

      if group = STAT_GROUP_SKILLS
      {
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,Length(plSkills));
         iCount = 1;
         foreach i in plSkills
         {
            Send(self,@SendStatSkill,#index=iCount);
            ++iCount;
         }

         SendPacket(poSession);

         return;
      }

      if group = STAT_GROUP_QUESTS
      {
         // Need to know how many completed + failed quests in quest history.
         iQLength = Send(self,@GetCompletedQuestLength);
         iFailedQLength = Send(self,@GetFailedQuestLength);
         if (iFailedQLength > 0)
         {
            // Add 4 at the end - 3 for headers, 1 for mana node quest.
            iCount = iQLength + iFailedQLength + Length(plActiveQuests) + 4;
         }
         else
         {
            // Add 3 at the end - 2 for headers, 1 for mana node quest.
            iCount = iQLength + iFailedQLength + Length(plActiveQuests) + 3;
         }

         AddPacket(1,BP_STAT_GROUP, 1,group, 1,iCount);

         // Reset, used for determining index in displayed quests.
         iCount = 1;

         // Send active quests.
         if plActiveQuests <> $
            OR piNodeList < NODE_ALL
         {
            // Send the "Active Quests" header.
            AddPacket(1,0, 4,user_active_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
            // Followed by all the active quests.
            iCount = Send(self,@SendActiveQuestData,#iCount=iCount);
         }
         else
         {
            // Send the "No Active Quests" header.
            AddPacket(1,0, 4,user_no_active_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
         }

         // Increment count past any active quests.
         ++iCount;
         // Send completed quests.
         if plQuestHistory <> $
            OR piNodeList >= NODE_ALL
         {
            // Send the "Completed Quests" header.
            AddPacket(1,iCount, 4,user_completed_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
            // Followed by completed quests.
            iCount = Send(self,@SendCompletedQuestData,#iCount=iCount);
         }
         else
         {
            // Send the "No Completed Quests" header.
            AddPacket(1,iCount, 4,user_no_completed_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
         }

         // Send failed quests if necessary.
         if (iFailedQLength > 0)
         {
            // Increment count past any completed quests.
            ++iCount;
            // Send the "Failed Quests" header.
            AddPacket(1,iCount, 4,user_failed_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
            // Followed by failed quests.
            iCount = Send(self,@SendFailedQuestData,#iCount=iCount);
         }

         SendPacket(poSession);

         return;
      }

      Debug("Invalid stat group number",group,"sent by client");

      return;
   }

   UserDisplayNPCQuestActive(what = $)
   {
      local i, oQN;

      if (what = $
         OR plActiveQuests = $)
      {
         return FALSE;
      }

      foreach i in plActiveQuests
      {
         oQN = Nth(i,2);
         if (Send(oQN,@QuestNodeDisplayNPCActive,#who=self,#what=what))
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   UserDisplayMobQuestActive(what = $)
   {
      local i, oQN;

      if (what = $
         OR plActiveQuests = $)
      {
         return FALSE;
      }

      foreach i in plActiveQuests
      {
         oQN = Nth(i,2);
         if (Send(oQN,@QuestNodeDisplayMobActive,#who=self,#what=what))
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   UserUpdateQuestMobs(what=$)
   "Trigger a flag update for any mobs that match the given quest mob."
   {
      local i, each_obj, cClass;

      if (what = $
         OR NOT pbLogged_on)
      {
         return;
      }

      cClass = GetClass(what);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if (IsClass(each_obj,&Monster)
            AND (GetClass(each_obj) = cClass
               OR Send(each_obj,@IsMonsterQuestEquivalent,#what=what)))
         {
            Send(self,@SomethingChangedFlags,#what=each_obj);
         }
      }

      return;
   }

   GetCompletedQuestLength()
   {
      local i, iCount, iQTemplate, oQObj, oQE;

      iCount = 0;

      oQE = Send(SYS,@GetQuestEngine);
      foreach i in plQuestHistory
      {
         if First(i) & QUEST_HISTORY_SUCCESS
         {
            iQTemplate = (First(i) & QUEST_HISTORY_MASK);
            oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

            if oQObj = $
            {
               continue;
            }

            if Send(oQObj,@ShowCompletedQuest,#who=self,#lHistory=i)
            {
               ++iCount;
            }
         }
      }

      return iCount;
   }

   GetFailedQuestLength()
   {
      local i, iCount, iQTemplate, oQObj, oQE;

      iCount = 0;

      oQE = Send(SYS,@GetQuestEngine);
      foreach i in plQuestHistory
      {
         if First(i) & QUEST_HISTORY_FAILURE
         {
            iQTemplate = (First(i) & QUEST_HISTORY_MASK);
            oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

            if oQObj = $
            {
               continue;
            }

            if Send(oQObj,@ShowFailedQuest,#who=self,#lHistory=i)
            {
               ++iCount;
            }
         }
      }

      return iCount;
   }

   SendActiveQuestData(iCount=1)
   "Returns the current index count."
   {
      local i, iQTemplate, oQE, oQObj, rQuestName;

      oQE = Send(SYS,@GetQuestEngine);

      foreach i in plActiveQuests
      {
         iQTemplate = First(i);
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

         if oQObj = $
         {
            Debug("User ",Send(self,@GetTrueName),"couldn't get quest object for ",
                  "quest template ",iQTemplate," quest is active.");

            continue;
         }

         rQuestName = Send(oQObj,@GetName);

         // List index, quest name, statistic type, quest object, value (//), icon.
         AddPacket(1,iCount, 4,rQuestName, 1,STAT_LIST,
                   4,oQObj, 4,iQTemplate, 4,Send(oQObj,@GetIcon));
         ++iCount;
      }

      // Mana node quest if player doesn't have all.
      if (piNodeList < NODE_ALL)
      {
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=QST_ID_MANA_NODE);
         AddPacket(1,iCount, 4,Send(oQObj,@GetName), 1,STAT_LIST,
                   4,oQObj, 4,QST_ID_MANA_NODE, 4,Send(oQObj,@GetIcon));
         ++iCount;
      }

      // Need to return the current count.
      return iCount;
   }

   SendCompletedQuestData(iCount=1)
   "Returns the current index count."
   {
      local i, iQTemplate, oQE, oQObj, rQuestName;

      oQE = Send(SYS,@GetQuestEngine);

      // Mana node quest first, if they have all nodes.
      if (piNodeList >= NODE_ALL)
      {
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=QST_ID_MANA_NODE);
         AddPacket(1,iCount, 4,Send(oQObj,@GetName), 1,STAT_LIST,
                   4,oQObj, 4,QST_ID_MANA_NODE, 4,Send(oQObj,@GetIcon));
         ++iCount;
      }

      foreach i in plQuestHistory
      {
         // Only send successfully completed quests for now.
         if NOT (First(i) & QUEST_HISTORY_SUCCESS)
         {
            continue;
         }

         iQTemplate = (First(i) & QUEST_HISTORY_MASK);
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

         if oQObj = $
         {
            Debug("User ",Send(self,@GetTrueName),"couldn't get quest object for ",
                  "quest template ",iQTemplate," quest is completed.");

            continue;
         }

         if NOT Send(oQObj,@ShowCompletedQuest,#who=self,#lHistory=i)
         {
            continue;
         }

         rQuestName = Send(oQObj,@GetName);

         // List index, quest name, stat type, quest object, quest index, icon.
         AddPacket(1,iCount, 4,rQuestName, 1,STAT_LIST,
                   4,oQObj, 4,iQTemplate, 4,Send(oQObj,@GetIcon));
         ++iCount;
      }

      // Return so we can correctly place failed quests.
      return iCount;
   }

   SendFailedQuestData(iCount=1)
   "Returns the current index count."
   {
      local i, iQTemplate, oQE, oQObj, rQuestName;

      oQE = Send(SYS,@GetQuestEngine);

      foreach i in plQuestHistory
      {
         // Must have failed it.
         if NOT (First(i) & QUEST_HISTORY_FAILURE)
         {
            continue;
         }

         iQTemplate = (First(i) & QUEST_HISTORY_MASK);
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

         if oQObj = $
         {
            Debug("User ",Send(self,@GetTrueName),"couldn't get quest object for ",
                  "quest template ",iQTemplate," quest is failed.");

            continue;
         }

         // ShowFailedQuest checks recency.
         if NOT Send(oQObj,@ShowFailedQuest,#who=self,#lHistory=i)
         {
            continue;
         }

         rQuestName = Send(oQObj,@GetName);

         // List index, quest name, stat type, quest object, quest index, icon.
         AddPacket(1,iCount, 4,rQuestName, 1,STAT_LIST,
                   4,oQObj, 4,iQTemplate, 4,Send(oQObj,@GetIcon));
         ++iCount;
      }

      // Don't currently use the returned count, but we might one day.
      return iCount;
   }

   ToCliStatGroups()
   {
      // 5 stat groups
      AddPacket(1,BP_STAT_GROUPS, 1,5, 4,user_group_condition, 4,user_group_stats,
                4,user_group_spells, 4,user_group_skills, 4,user_group_quests);
      SendPacket(poSession);

      return;
   }

   ToCliSpellSchools()
   {
      local num_schools;

      num_schools = 6;
      if viDM
      {
         ++num_schools;
      }

      AddPacket(1,BP_USERCOMMAND, 1,UC_SPELL_SCHOOLS, 1,num_schools,
                4,user_school_shallile, 4,user_school_qor,
                4,user_school_kraanan, 4,user_school_faren,
                4,user_school_riija, 4,user_school_jala);

      if viDM
      {
         AddPacket(4,user_school_dm);
      }

      SendPacket(poSession);

      return;
   }

   ToCliSpells()
   {
      local i, oSpell;

      if pbLogged_on
      {
         AddPacket(1,BP_SPELLS, 2,Length(plSpells));

         foreach i in plSpells
         {
            oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                        #compound=i));
            Send(self,@ToCliObject,#what=oSpell);
            AddPacket(1,Send(oSpell,@GetNumSpellTargets),
                      1,Send(oSpell,@GetSchool));
         }

         SendPacket(poSession);
         Send(self,@ToCliStats,#group=STAT_GROUP_SPELLS);
      }

      return;
   }

   ToCliSkills()
   {
      local i, oSkill;

      if pbLogged_on
      {
         AddPacket(1, BP_SKILLS,2,Length(plSkills));
         foreach i in plSkills
         {
            oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                        #compound=i));
            Send(self,@ToCliObject,#what=oSkill);
            AddPacket(1,Send(oSkill,@GetNumSkillTargets),
                      1,Send(oSkill,@GetSchool),
                      1,Send(oSkill,@IsActiveSkill));
         }

         SendPacket(poSession);
         Send(self,@ToCliStats,#group=STAT_GROUP_SKILLS);
      }

      return;
   }

   ToCliAddSpell(oSpell = $, iSID = 0, iNum = 0)
   {
      local i, bFound;

      if pbLogged_on
      {
         // Caller should send a valid iNum, but if they don't we can try
         // get it here (probably unnecessary safety measure).
         if (iNum = 0)
         {
            bFound = FALSE;
            foreach i in plSpells
            {
               iNum++;
               if (iSID = Send(self,@DecodeSpellNum,#compound=i))
               {
                  bFound = TRUE;

                  break;
               }
            }
            if (NOT bFound)
            {
               Debug(vrName, " had ToCliAddSpell called with missing spell ",
                     Send(oSpell,@GetName));

               return;
            }
         }

         AddPacket(1, BP_SPELL_ADD);

         Send(self,@ToCliObject,#what=oSpell);
         AddPacket(1,Send(oSpell,@GetNumSpellTargets),
                   1,Send(oSpell,@GetSchool));
         SendPacket(poSession);

         Send(self,@DrawStatSpell,#index=iNum);
      }

      return;
   }

   ToCliRemoveSpell(oSpell = $)
   {
      if pbLogged_on
      {
         AddPacket(1, BP_SPELL_REMOVE, 4, oSpell);
         SendPacket(poSession);
      }

      return;
   }

   ToCliAddSkill(oSkill = $, iSKID = 0, iNum = 0)
   {
      local i, bFound;

      if pbLogged_on
      {
         // Caller should send a valid iNum, but if they don't we can try
         // get it here (probably unnecessary safety measure).
         if (iNum = 0)
         {
            bFound = FALSE;
            foreach i in plSkills
            {
               iNum++;
               if (iSKID = Send(self,@DecodeSkillNum,#compound=i))
               {
                  bFound = TRUE;

                  break;
               }
            }
            if (NOT bFound)
            {
               Debug(vrName, " had ToCliAddSkill called with missing skill ",
                     Send(oSkill,@GetName));

               return;
            }
         }

         AddPacket(1, BP_SKILL_ADD);

         Send(self,@ToCliObject,#what=oSkill);
         AddPacket(1,Send(oSkill,@GetNumSkillTargets),
                   1,Send(oSkill,@GetSchool),
                   1,Send(oSkill,@IsActiveSkill));
         SendPacket(poSession);

         Send(self,@DrawStatSkill,#index=iNum);
      }

      return;
   }

   ToCliRemoveSkill(oSkill = $)
   {
      if pbLogged_on
      {
         AddPacket(1, BP_SKILL_REMOVE, 4, oSkill);
         SendPacket(poSession);
      }

      return;
   }

   ToCliAddBackgroundOverlay(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_ADD_BG_OVERLAY);
         Send(self,@ToCliBackgroundOverlay,#what=what);
      }

      return;
   }

   ToCliChangeBackgroundOverlay(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE_BG_OVERLAY);
         Send(self,@ToCliBackgroundOverlay,#what=what);
      }

      return;
   }

   ToCliBackgroundOverlay(what = $)
   {
      AddPacket(4,what, 4,Send(what,@GetIcon), 4,Send(what,@GetName));
      Send(what,@SendAnimation);
      AddPacket(2,Send(what,@GetBackgroundOverlayAngle),
                2,Send(what,@GetBackgroundOverlayHeight));
      SendPacket(poSession);

      return;
   }

   GetSpeedMax()
   "Returns the maximum possible move speed according to the current situation of the user"
   "and its active limitations like PFLAG_NO_MOVE, low vigor, deep water or others."
   {
      local iSpeed, iDepthType;

      // can not move at all ...
      if (piFlags & PFLAG_NO_MOVE)
      {
         return 0;
      }

      // case 1) WALKING on low vigor
      if piVigor < VIGOR_RUN_THRESHOLD
      {
         iSpeed = USER_WALKING_SPEED;
      }
      // case 2) e.g. SPEEDBOOST
      // case 3) ...
      // default) RUNNING
      else
      {
         iSpeed = USER_RUNNING_SPEED;
      }

      // Any movement speed modifiers?
      iSpeed = iSpeed * Send(self,@GetMovementSpeedPercent) / 100;

      // if location flags available, possibly reduce based on depthflags
      if (piLocationFlags <> $)
      {
         // get sector depth type at current location
         iDepthType = piLocationFlags & LIR_SECTOR_DEPTHMASK;

         // return reduced value according to depth
         if iDepthType = LIR_SECTOR_DEPTH0
         {
            return iSpeed; // 100%
         }
         else if iDepthType = LIR_SECTOR_DEPTH1
         {
            return Bound(((iSpeed * 3) / 4), 1, iSpeed); // 75%
         }
         else if iDepthType = LIR_SECTOR_DEPTH2
         {
            return Bound((iSpeed / 2), 1, iSpeed); // 50%
         }
         else if iDepthType = LIR_SECTOR_DEPTH3
         {
            return Bound((iSpeed / 4), 1, iSpeed); // 25%
         }
      }

      // no flags available or unknown depth type
      return iSpeed;
   }

   UserMove(new_row = 1, new_col = 1,
            fine_row = FINENESS/2, fine_col = FINENESS/2, speed = 0)
   {
      local iCurrentTime, iDelta, iAngle, iRow, iCol, iFineRow, 
            iFineCol, iRoomNum, iDx, iDy, iMoveLength, iMaxMoveRun, 
            iQflags, iRflags, iHeightF, iHeightFWD, iHeightC, iServerID,
            iSpeedMax, iNewBucket, bBucketMoveAllowed;

      ////////////////////////////////////////////////////////////////////////////////////////
      // 1 - INIT AND SILENT DISCARDS
      ////////////////////////////////////////////////////////////////////////////////////////

      //
      // 1.1 Get current position, angle, tick and delta
      //
      iRow = piRow;
      iCol = piCol;
      iFineRow = piFine_row;
      iFineCol = piFine_col;
      iAngle = Send(self,@GetAngle);
      iCurrentTime = GetTickCount();
      iDelta = Bound(iCurrentTime - piLastMoveUpdateTime,0,2000);

      //
      // 1.2 Silently discard requests directly after server-teleports (incorrect by now)
      //  Also take care of rollover: The last teleport must be in the past, not future
      //
      if iCurrentTime > piLastServerTeleport AND iCurrentTime < piLastServerTeleport + 300
      {
         //Debug("Discarded move after teleport for ",Send(self,@GetTrueName),self);
         return;
      }

      ////////////////////////////////////////////////////////////////////////////////////////
      // 2 - VALIDATIONS CAUSING DENY/RUBBERBANDING/RETURN ON FAIL
      ////////////////////////////////////////////////////////////////////////////////////////

      //
      // 2.1 Do not allow any moves if player is marked as not allowed to move 
      //
      if (piFlags & PFLAG_NO_MOVE)
      {
         // Don't need to log this most of the time, can happen for mundane
         // reasons e.g. a move sent after player getting held due to lag.
         if (piFlags & PFLAG_LOG)
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self," tried to move with",
                  "PFLAG_NO_MOVE in room ",Send(poOwner,@GetName));
         }

         // Reset position
         Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
               #new_row=iRow,
               #new_col=iCol,
               #fine_row=iFineRow,
               #fine_col=iFineCol,
               #new_angle=iAngle);

         return;
      }

      //
      // 2.2 Check the user's claimed speed is within valid range
      //  Don't worry about a temporary different current max. here
      //
      if speed < 1
         OR speed > USER_RUNNING_SPEED * MOVEMENTSPEED_MAX / 100
      {
         // Make a log entry
         if piCheaterLogs < MAX_LOGGED_THRESHOLD
         {
            ++piCheaterLogs;
            Debug("ALERT! ",Send(self,@GetTrueName),self,
                  " transmitted speed ",speed,
                  " smaller 1 or greater max ",USER_RUNNING_SPEED);
         }

         // Reset position
         Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
               #new_row=iRow,
               #new_col=iCol,
               #fine_row=iFineRow,
               #fine_col=iFineCol,
               #new_angle=iAngle);

         return;
      }

      //
      // 2.2 Validate REAL Speed (Speedhack Protection using a Token Bucket concept). 
      //

      // 2.2.1 Get the current legal upper bound for move-speed.
      //  This depends on condition (e.g. low vigor), but also locations (e.g. deep water/depthflags).
      //  Important: This must be the upper bound on the tokens we add to the bucket below.
      //  Continously exceeding the current max. will cause rubberbanding
      iSpeedMax = Send(self, @GetSpeedMax);

      // 2.2.2 Move validity/token use calculated in C due to kod int overflows.
      // Returns the new value for piMovementBucket in iNewBucket.
      bBucketMoveAllowed = CalcUserMovementBucket(piMovementBucket, *iNewBucket,
         Send(SETTINGS_OBJECT,@GetMovementBucketMax),Bound(speed,1,iSpeedMax),
         iDelta, iRow, iCol, iFineRow, iFineCol, new_row, new_col, fine_row, fine_col);

      // 2.2.3 Assign the new bucket value.
      piMovementBucket = iNewBucket;

      // 2.2.4 This move would consume more tokens than we have left -> deny
      // Could also be denied for a data type/value error in C, but this is
      // logged in the admin console/log files from the C side.
      if (NOT bBucketMoveAllowed)
      {
         // Reset position
         Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
               #new_row=iRow,
               #new_col=iCol,
               #fine_row=iFineRow,
               #fine_col=iFineCol,
               #new_angle=iAngle);

         // Make a log entry
         if piCheaterLogs < MAX_LOGGED_THRESHOLD
         {
            ++piCheaterLogs;
            Debug("ALERT!",Send(self,@GetTrueName),self,"was moving too fast");
         }

         return;
      }

      //
      // 2.3 Validate against room geometry and manual move checks
      //  This requires the already validated speed value from above
      //

      // 2.3.1 Validate move against room geometry and (not recently moved) objects
      if NOT CanMoveInRoomBSP(Send(poOwner,@GetRoomData),piRow,piCol,piFine_row,
             piFine_col,piHeight,new_row,new_col,fine_row,fine_col,speed,self,CANMOVE_IS_PLAYER)
      {
         Debug("ALERT! ",Send(self,@GetTrueName),self," illegal move denied in room ",
               Send(poOwner,@GetName), "S: ",piRow,piCol,piFine_row,piFine_col,
               ", E: ",new_row,new_col,fine_row,fine_col);

         // Reset position
         Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
               #new_row=iRow,
               #new_col=iCol,
               #fine_row=iFineRow,
               #fine_col=iFineCol,
               #new_angle=iAngle);

         return;
      }

      // 2.3.2 Manual move checks in some rooms
      iRoomNum = Send(poOwner,@GetRoomNum);
      if iRoomNum = RID_CAVE2
         OR iRoomNum = RID_ICE_CAVE1
         OR (iRoomNum >= RID_GUILDH_MIN
            AND iRoomNum <= RID_GUILDH_MAX)
         OR iRoomNum = RID_I9
      {
         if NOT Send(poOwner,@IsMoveOK,
                  #old_row=iRow,#old_col=iCol,#old_fine_row=iFineRow,
                  #old_fine_col=iFineCol,#new_row=new_row,#new_col=new_col,
                  #new_fine_row=fine_row,#new_fine_col=fine_col,#who=self)
         {
            // Rooms now handle logging, for customized debug messages.
            // Reset position
            Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
                  #new_row=iRow,
                  #new_col=iCol,
                  #fine_row=iFineRow,
                  #fine_col=iFineCol,
                  #new_angle=iAngle);

            return;
         }
      }

      ////////////////////////////////////////////////////////////////////////////////////////
      // 3 - MOVE ACCEPTED FROM HERE ON, PROCESS IT ...
      ////////////////////////////////////////////////////////////////////////////////////////

      // 3.1 Save this move tick for next execution and also speed squared.
      piLastMoveUpdateTime = iCurrentTime;
      piSpeed = speed * speed;

      //
      // 3.2 Break trance or stop dance if user is running
      // 
      if (speed > USER_WALKING_SPEED)
      {
         // Stop dance
         if (piFlags2 & PFLAG2_DANCING)
         {
            Send(self,@StopDancing);
         }
      }

      //
      // 3.3 Drain vigor once per 1000 ms. Handled in battler now.
      //  Check CalculateVigorPerTick(). We do have to alert
      //  NewVigor() though. 
      //
      Send(self,@NewVigor);

      //
      // 3.4 Notify monsters about presence every second.
      //
      if (Abs(iCurrentTime - piLastMoveNotification) > 1000)
      {
         Send(poOwner,@UserMoved,#what=self,#new_row=piRow,#new_col=piCol);
         piLastMoveNotification = iCurrentTime;
      }

      //
      // 3.5 Process the move
      //
      Send(poOwner,@SomethingMoved,#what=self,
            #new_row=new_row,#new_col=new_col,
            #fine_row=fine_row,#fine_col=fine_col,
            #cause=CAUSE_USER_INPUT,#speed=speed);

      //
      // 3.6 Set the flag so that wall elements can affect us.
      //
      Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=TRUE);

      //
      // 3.7 Keep track of the most recent steps to facilitate monster pursuit.
      //
      ++piTrailSteps;
      if piTrailSteps >= Send(poOwner,@GetTrailSteps)
      {
         Send(self,@SetUserTrail,#iRow=new_row,#iCol=new_col,
            #iFineRow=fine_row,#iFineCol=fine_col);

         piTrailSteps = 0;
      }

      return;
   }

   UserTurn(what = $, new_angle = 0)
   {
      if what <> self
      {
         Debug("User tried to turn object other than self: ",what);
         
         return;
      }

      // new angle is equal to current one, nothing to do
      if new_angle = Send(what,@GetAngle)
      {
         return;
      }

      // Do not allow angle changes while we are immobile.
      if (piFlags & PFLAG_NO_MOVE)
         AND ((NOT Send(self,@IsResting))
              OR Send(self,@IsEnchanted,#byClass=&Hold))
      {
         Send(poOwner,@SomethingTurned,#what=self,
              #new_angle=Send(self,@GetAngle));

         return;
      }

      if new_angle < 0 or new_angle > MAX_ANGLE 
      {
         Debug("Invalid turn angle: ",new_angle);

         return;
      }

      Send(poOwner,@SomethingTurned,#what=self,#new_angle=new_angle,
           #cause=CAUSE_USER_INPUT);

      return;
   }

   UserAppeal(string = $, first_time = FALSE)
   {
      local i;

      // Can't send appeals if squelched.
      if (NOT first_time
         AND (piFlags2 & PFLAG2_SQUELCHED_APPEAL))
      {
         Send(self,@MsgSendUser,#message_rsc=user_appeal_squelched);
         return;
      }

      foreach i in Send(SYS,@GetUsersLoggedOn)
      {
         if (first_time)
         {
            if (Send(SETTINGS_OBJECT,@MessageAllForNewUser)
               OR (IsClass(i,&DM) AND Send(i,@IsAppealOn)))
            {
               Send(i,@MsgSendUser,#message_rsc=user_first_time_appeal,
                     #parm1=vrName);
            }
         }
         else if (IsClass(i,&DM) AND Send(i,@IsAppealOn))
         {
            Send(i,@MsgSendUser,#message_rsc=user_appeal,#parm1=vrName,
                  #parm2=string);
         }
      }

      if first_time OR IsClass(self,&DM)
      {
         // Don't tell DMs and Admins that the appeal was heard,
         //  since this is always true.
         return;
      }

      Send(self,@MsgSendUser,#message_rsc=user_did_appeal,#parm1=string);

      return;
   }

   MsgSendUserCallback(what=$, sCallback=$, parm1=$, parm2=$, parm3=$, parm4=$)
   "Adds a BP_MESSAGE packet, calls the message in sCallback, then sends the "
   "packet to the user.  Used so other objects don't need to add the protocol "
   "message, or obtain the user's session.  sCallback is a string containing "
   "the message name to be called, 'what' is the calling object."
   {
      if sCallback <> $
         AND IsString(sCallback)
         AND what <> $
         AND pbLogged_on
      {
         AddPacket(1,BP_MESSAGE);

         // The called message should return TRUE to let us know building the
         // packet was successful, otherwise we clear the packet.
         if Send(what,sCallBack,#parm1=parm1,#parm2=parm2,
                  #parm3=parm3,#parm4=parm4)
         {
            SendPacket(poSession);
         }
         else
         {
            ClearPacket();
         }
      }

      return;
   }

   MsgSendUser(message_rsc = $,
               parm1 = $,parm2 = $,parm3 = $,parm4 = $,
               parm5 = $,parm6 = $,parm7 = $,parm8 = $,
               type1 = STANDARD_RESOURCE,type2 = STANDARD_RESOURCE,
               type3 = STANDARD_RESOURCE,type4 = STANDARD_RESOURCE,
               type5 = STANDARD_RESOURCE,type6 = STANDARD_RESOURCE,
               type7 = STANDARD_RESOURCE,type8 = STANDARD_RESOURCE,
               report = TRUE)
   {
      if pbLogged_on
         AND report
      {
         AddPacket(1,BP_MESSAGE,4,message_rsc);

         if parm1 <> $
         {
            AddPacket(type1,parm1);
         }
         if parm2 <> $
         {
            AddPacket(type2,parm2);
         }
         if parm3 <> $
         {
            AddPacket(type3,parm3);
         }
         if parm4 <> $
         {
            AddPacket(type4,parm4);
         }
         if parm5 <> $
         {
            AddPacket(type5,parm5);
         }
         if parm6 <> $
         {
            AddPacket(type6,parm6);
         }
         if parm7 <> $
         {
            AddPacket(type7,parm7);
         }
         if parm8 <> $
         {
            AddPacket(type8,parm8);
         }

         SendPacket(poSession);
      }

      return;
   }

   SysMsgSendUser(message_rsc = $,parm1 = $,parm2 = $,parm3 = $,parm4 = $,
                  parm5 = $,parm6 = $,parm7 = $,parm8 = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SYS_MESSAGE,4,message_rsc);
         if parm1 <> $
         {
            AddPacket(4,parm1);
         }
         if parm2 <> $
         {
            AddPacket(4,parm2);
         }
         if parm3 <> $
         {
            AddPacket(4,parm3);
         }
         if parm4 <> $
         {
            AddPacket(4,parm4);
         }
         if parm5 <> $
         {
            AddPacket(4,parm4);
         }
         if parm6 <> $
         {
            AddPacket(4,parm4);
         }
         if parm7 <> $
         {
            AddPacket(4,parm4);
         }
         if parm8 <> $
         {
            AddPacket(4,parm4);
         }

         SendPacket(poSession);
      }

      return;
   }

   WaveSendUser(wave_rsc = $, source_obj = 0, flags = 0, row = 0, col = 0,
                cutoff_radius = 0, max_volume = 0)
   //  If source_obj defined, use its location for source of sound
   //  if not, check row & col, and use that location if either or both are
   //  non-zero finally, default to sound originating at user
   //  Valid flags are:
   //   SOUND_LOOP to loop the sound til player leaves room
   //   SOUND_RANDOM_PITCH to choose a random pitch for the sound
   //  For looping sounds, cutoff_radius and max_volume are used set
   //  attenuation parameters
   {
      if (wave_rsc <> $
         AND pbLogged_on)
      {
         AddPacket(1,BP_PLAY_WAVE, 4,wave_rsc, 4,source_obj, 1,flags,
                   4,row, 4,col, 4,cutoff_radius, 4,max_volume);
         SendPacket(poSession);
      }

      return;
   }

   WaveSendUserStop(wave_rsc = $, source_obj = 0)
   // Sends a message to the client to stop playing a wav using the resource ID.
   {
      if (wave_rsc <> $
         AND pbLogged_on)
      {
         AddPacket(1,BP_STOP_WAVE, 4,wave_rsc, 4,source_obj);
         SendPacket(poSession);
      }

      return;
   }

   SendRoomMusic(music_rsc = $)
   {
      if (pbLogged_on)
      {
         if (music_rsc <> $)
         {
            AddPacket(1,BP_PLAY_MUSIC, 4,music_rsc);
         }
         else
         {
            AddPacket(1,BP_PLAY_MUSIC, 4,0);
         }
         SendPacket(poSession);
      }

      return;
   }

   MidiSendUser(midi_rsc = $)
   {
      if (midi_rsc <> $
         AND pbLogged_on)
      {
         AddPacket(1,BP_PLAY_MIDI, 4,midi_rsc);
         SendPacket(poSession);
      }

      return;
   }

   MovementSpeedChanged()
   {
      Send(self,@MovementSpeedSendUser);

      return;
   }

   MovementSpeedSendUser()
   "Sends movement speed % to the user."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_MOVEMENT_SPEED,2,Send(self,@GetMovementSpeedPercent));
         SendPacket(poSession);
      }

      return;
   }

   GoodSpellFlashEffect()
   {
      Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
            #duration=100,#xlat=GOOD_COLOR);

      return;
   }

   BadSpellFlashEffect()
   {
      Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
            #duration=100,#xlat=BAD_COLOR);

      return;
   }

   DamageTypeFlashEffect(stype=0, duration=800)
   {
      if stype & SPL_TYPE_QUAKE
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=65);
      }
      else if stype & SPL_TYPE_HOLY
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=116);
      }
      else if stype & SPL_TYPE_UNHOLY
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=112);
      }
      else if stype & SPL_TYPE_ACID
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=86);
      }
      else if stype & SPL_TYPE_COLD
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=85);
      }
      else if stype & SPL_TYPE_SHOCK
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=82);
      }
      else if stype & SPL_TYPE_FIRE
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=81);
      }

      return;
   }

   SendEffectData()
   {
      return;
   }

   EffectSendUser(what = $,effect = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT,2,effect);
         Send(what,@SendEffectData,#what=self);

         SendPacket(poSession);
      }

      return;
   }

   EffectSendUserXLat(what = $, xlat = 0)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT, 2,EFFECT_XLATOVERRIDE, 4,xlat);

         SendPacket(poSession);
      }

      return;
   }

   EffectSendUserDuration(what = $, effect = $, duration = 1000)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT, 2,effect, 4,duration);
         SendPacket(poSession);
      }

      return;
   }

   EffectSendUserDurationAndXlat(what = $, effect = $, duration = 100,
                                 xlat = 0)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT, 2,effect, 4,duration, 4,xlat);
         SendPacket(poSession);
      }

      return;
   }

   SectorSendUser(animation = $,sector = $,height = $,speed = $)
   "Sent by room when one of its sectors changes."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SECTOR_MOVE,1,animation,2,sector,2,height,1,speed);
         SendPacket(poSession);
      }

      return;
   }

   SectorLightSendUser(sector = $,light_effect = $)
   "Sent by room when one of its sector lights changes."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SECTOR_LIGHT,2,sector,1,light_effect);
         SendPacket(poSession);
      }

      return;
   }

   WallSendUser(wall = $, animation = $, first_group = $, second_group = $,
               end_group = $, speed = $, passable = $)
   "Sent by room when one of its walls changes.  <Passable> = $ means leave "
   "alone."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_WALL_ANIMATE, 2,wall, 1,animation);
         if animation = ANIMATE_NONE
         {
            AddPacket(2,first_group);
         }
         else if animation = ANIMATE_ONCE
         {
            AddPacket(4,speed, 2,first_group, 2,second_group, 2,end_group);
         }
         else if animation = ANIMATE_CYCLE
         {
            AddPacket(4,speed, 2,first_group, 2,second_group);
         }

         if passable = $
         {
            AddPacket(1,0);
         }
         else if passable
         {
            AddPacket(1,1);
         }
         else
         {
            AddPacket(1,2);
         }

         SendPacket(poSession);
      }

      return;
   }

   TextureSendUser(id = $,new_texture = $,flags = 0)
   "Sent by room when one of its textures changes."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE_TEXTURE,2,id,2,new_texture,1,flags);

         SendPacket(poSession);
      }

      return;
   }

   SectorChangeSendUser(sector=$, depth=$, scrollSpeed=$)
   "Sent by room when one of the sector's properties have changed. "
   "This handles scrolling and depth which rarely require changing, "
   "other protocols already handle animation and textures."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SECTOR_CHANGE,2,sector,1,depth,1,scrollSpeed);

         SendPacket(poSession);
      }

      return;
   }

   GameStateSendUser(game = $, state = $)
   "Sends game state to player"
   {
      if pbLogged_on
      {
         AddPacket(1, BP_USERCOMMAND, 1, UC_MINIGAME_MOVE, 4, game);

         // Send default state if the game hasn't started yet
         if (state = $)
         {
            AddPacket(STRING_RESOURCE,Send(game,@GetDefaultState));
         }
         else
         {
            AddPacket(0, state);
         }

         SendPacket(poSession);
      }

      return;
   }

   GamePlayerSendUser(who = $, num = $)
   "Sends game player name to player (for minigames, like chess)"
   {
      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND, 1,UC_MINIGAME_PLAYER, 1,num,
                   STRING_RESOURCE,Send(who,@GetTrueName));

         SendPacket(poSession);
      }

      return;
   }

   UserGet(what = $, report = TRUE)
   {
      local oOldOwner, i, lItem_pos, iRow, iCol, iRow_dist, iCol_dist,
            iCan_hold, oSplit, oCorpse, bFromReagentBag;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,
               #wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      oOldOwner = Send(what,@GetOwner);

      // Make sure we're not trying to get something we've already got!
      if oOldOwner = self
      {
         return 0;
      }

      if oOldOwner <> $
         AND IsClass(oOldOwner,&ReagentBag)
      {
         bFromReagentBag = TRUE;
      }
      else
      {
         bFromReagentBag = FALSE;
      }

      // Make sure object still exists, etc, so we don't cause errors
      if Send(SYS,@UtilGetRoom,#what=what) <> poOwner
         OR IsClass(Send(what,@GetOwner),&User)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_unk,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      lItem_pos = Send(what,@GetPos);
      if lItem_pos = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_unk,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      iRow = First(lItem_pos);
      iCol = Nth(lItem_pos,2);

      iRow_dist = piRow - iRow;
      if iRow_dist < 0
      {
         iRow_dist = -1 * iRow_dist;
      }

      iCol_dist = piCol - iCol;
      if iCol_dist < 0
      {
         iCol_dist = -1 * iCol_dist;
      }

      if (iRow_dist + iCol_dist) > 7
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_dist,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 2;
      }

      // This includes the corpse pointer, which prevents people
      // from looting each other's kills.
      if NOT Send(what,@ReqNewOwnerAttributes,#who=self)
      {
         return 0;
      }

      if oOldOwner <> $
         AND NOT Send(oOldOwner,@ReqTaker,#what=what,#taker=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      if NOT Send(what,@ReqNewOwner,#what=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      if NOT Send(self,@ReqNewHold,#what=what)
      {
         if Send(what,@IsStackable)
         {
            iCan_hold = Send(self,@GetNumberCanHold,#what=what);
            if iCan_hold > 0
            {
               oSplit = Send(what,@Split,#number=iCan_hold);
               if Send(what,@ReqNewOwner,#what=oSplit)
               {
                  Send(self,@MsgSendUser,#message_rsc=user_got_some,#report=report,
                       #parm1=Send(what,@GetName));
                  Send(self,@NewHold,#what=oSplit,#bFromReagentBag=bFromReagentBag);

                  return 3;
               }
               else
               {
                  Send(what,@AddNumber,#number=iCan_hold);
                  Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
                       #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
                  Send(self,@WaveSendUser,#what=self,
                       #wave_rsc=user_cant_pickup_item_wav_rsc);

                  return 4;
               }
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
               Send(self,@WaveSendUser,#what=self,
                    #wave_rsc=user_cant_pickup_item_wav_rsc);

               return 4;
            }
         }
         else
         {
            //  KLUDGE!!  -Asif
            if NOT IsClass(what,&HunterSword)
            {
               Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
                     #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
               Send(self,@WaveSendUser,#what=self,
                     #wave_rsc=user_cant_pickup_item_wav_rsc);
            }

            return 4;
         }
      }

      // shrunken head picked up
      if isClass(what,&ShrunkenHead)
      {
         Send(what,@PickedUp,#by=self);
      }

      Send(self,@NewHold,#what=what,#bFromReagentBag=bFromReagentBag);

      return 1;
   }

   UserBlockedSend(what = $)
   "Sent by client when they're blocking messages from a user, and that "
   "user Sends a message."
   {
      return;
   }

   UserDrop(what = $,number = $)
   {
      local i,Item_pos,oNumber;

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_drop);

         return;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_drop);
         return FALSE;
      }

      if Send(what,@IsStackable)
      {
         if number <= 0
         {
            Send(self,@MsgSendUser,#message_rsc=user_cant_deal_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         oNumber = Send(what,@Split,#number=number);
         if oNumber = $
         {
            Send(self,@MsgSendUser,#message_rsc=user_not_have_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         if Send(oNumber,@ReqNewOwner,#what=poOwner)
            AND Send(poOwner,@ReqNewHold,#what=oNumber,
                     #new_row=piRow,#new_col=piCol)
         {
            Send(poOwner,@NewHold,#what=oNumber,#new_row=piRow,#new_col=piCol,
                 #fine_row=piFine_row,#fine_col=piFine_col);
         }
         else
         {
            Send(what,@Join,#what=oNumber);

            Send(self,@MsgSendUser,#message_rsc=user_disallow_drop, 
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }

         return;
      }

      if Send(what,@ReqNewOwner,#what=poOwner)
         AND Send(poOwner,@ReqNewHold,#what=what,#new_row=piRow,#new_col=piCol)
      {
         Send(poOwner,@NewHold,#what=what,#new_row=piRow,#new_col=piCol,
               #fine_row=piFine_row,#fine_col=piFine_col);

         // Shrunken head dropped by owner
         if IsClass(what, &ShrunkenHead)
         {
            Send(what,@Dropped,#by=self,#where=poOwner);
         }
      }

      return;
   }

   UserMoveInventoryItem(what=$,where=$)
   "User moved an item in their inventory. Assuming everything checks out, "
   "we move it in the plPassive list also."
   {
      local iWhere, lSafeList;

      if what = $
         OR where = $
         OR what = where
         OR plPassive = $
      {
         return;
      }

      if FindListElem(plPassive,what) = 0
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to move ",
               "inventory item ",what,Send(what,@GetName)," they didn't have!");

         return;
      }
      // Get list position for the drop location.
      iWhere = FindListElem(plPassive,where);
      if iWhere = 0
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to move ",
               "inventory item ",what,Send(what,@GetName)," to invalid location of ",
               where,Send(where,@GetName));

         return;
      }

      // MUST reassign this to plPassive, in case we're deleting the first
      // list node. Use a temp list to verify there were no issues.
      lSafeList = DelListElem(plPassive,what);
      if lSafeList <> $
      {
         plPassive = lSafeList;
      }
      else
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to set ",
               "plPassive to $ when deleting a list element! ",plPassive,
               what,Send(what,@GetName));
      }

      // MUST reassign this to plPassive, in case we're creating the first list node.
      lSafeList = InsertListElem(plPassive,iWhere,what);
      if lSafeList <> $
      {
         plPassive = lSafeList;
      }
      else
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to set ",
               "plPassive to $ when adding a list element! ",plPassive,what,iWhere);
      }

      return;
   }

   UserPut(what = $,where = $,number = $)
   {
      local i, lObjects, lItem_pos, oNumber;

      // Detect if someone's using an exploit to put items into another player.
      if IsClass(where,&User)
      {
         Debug("ALERT! ",Send(self,@GetTrueName),self," tried to 'put' items "
               "into player ",Send(where,@GetTrueName),where);

         return;
      }

      if NOT IsClass(where,&Holder)
         AND NOT IsClass(where,&ReagentBag)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_put,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
               #parm3=Send(where,@GetDef),#parm4=Send(where,@GetName),
               #parm5=Send(where,@GetDef),#parm6=Send(where,@GetName));

         return;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_drop);

         return;
      }

      if Send(where,@IsHolding,#what=what)
      {
         Debug("ALERT! ",Send(self,@GetTrueName),self,"tried to put a "
               "duplicate item in a chest.");

         return;
      }

      if Send(what,@IsStackable)
      {
         if number <= 0
         {
            Send(self,@MsgSendUser,#message_rsc=user_cant_deal_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         oNumber = Send(what,@Split,#number=number);
         if oNumber = $
         {
            Send(self,@MsgSendUser,#message_rsc=user_not_have_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         if Send(oNumber,@ReqNewOwner,#what=where)
            AND Send(where,@ReqNewHold,#what=oNumber,#who=self)
         {
            Send(where,@NewHold,#what=oNumber);
         }
         else
         {
            Send(self,@NewHold,#what=oNumber); // rejoin, usually

            Send(self,@MsgSendUser,#message_rsc=user_disallow_drop, 
                 #parm1=Send(oNumber,@GetDef),#parm2=Send(oNumber,@GetName));
         }

         return;
      }

      if Send(what,@ReqNewOwner,#what=where)
         AND Send(where,@ReqNewHold,#what=what,#who=self)
      {
         Send(where,@NewHold,#what=what);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_put,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
              #parm3=Send(where,@GetDef),#parm4=Send(where,@GetName));
      }

      return;
   }

   UserObjectContents(what = $)
   {
      local i, iObjs, oThing, lHolding1, lHolding2;

      if (NOT IsClass(what,&Holder)
         AND NOT IsClass(what,&ReagentBag))
         OR (IsClass(what,&User)
             AND NOT (what = self OR IsClass(self,&Admin)))
         OR IsClass(what,&Monster)
      {
         Debug("ALERT!!  User ",self,Send(self,@GetTrueName),"trying to look ",
               "inside ",what,Send(what,@GetTrueName));

         Send(self,@MsgSendUser,#message_rsc=user_err_get_contents,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return;
      }

      // Make sure object is in the same room as player
      if NOT Send(self,@IsInSameRoom,#what=what)
      {
         Debug("User ",self,vrName," tried to look at object ",
               Send(what,@GetTrueName)," in another room");

         return;
      }

      if IsClass(what,&StorageBox)
      {
         if NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         {
            Debug("ALERT: ",self,vrName," tried to look at storebox out of LOS!");

            return;
         }

         if Send(self,@SquaredFineDistanceTo3D,#what=what) > CHEST_ACCESS_DIST
         {
            Debug("ALERT: ",self,vrName," tried to access chest from too far away!");
            Send(self,@MsgSendUser,#message_rsc=user_chest_too_far,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

            return;
         }
      }

      if IsClass(what,&User)
      {
         lHolding1 = Send(what,@GetPlayerUsing);
         lHolding2 = $;
      }
      else if IsClass(what,&ReagentBag)
      {
         lHolding1 = Send(what,@GetReagentBagContents);
         lHolding2 = $;
      }
      else
      {
         lHolding1 = Send(what,@GetHolderActive);
         lHolding2 = Send(what,@GetHolderPassive);
      }

      iObjs = Length(lHolding1) + Length(lHolding2);
      AddPacket(1,BP_OBJECT_CONTENTS,4,what,2,iObjs);

      foreach i in lHolding1
      {
         oThing = Send(what,@HolderExtractObject,#data=i);
         Send(self,@ToCliObject,#what=oThing);
      }

      // passive are in lholding2
      foreach i in lHolding2
      {
         oThing = Send(what,@HolderExtractObject,#data=i);
         Send(self,@ToCliObject,#what=oThing);
      }

      SendPacket(poSession);

      return;
   }

   UserSay(type=$,string=$)
   {
      local i, oSpell, lEnchantData, bTranceBlocksSay;

      // A room can completely block a piece of communication if it chooses.
      // An excellent example is Out Of Grace, which blocks all tells to 
      // non-DMs, as well as Guild Tells and Broadcasts

      if type = SAY_NORMAL
      {
         if StringContain(string,user_say_survival)
            AND Send(poOwner,@GetRoomNum) <> RID_OUTOFGRACE
         {
            // If UserSaySurvival handles the string, don't keep checking.
            if Send(self,@UserSaySurvival,#string=string)
            {
               return;
            }
         }

         if StringContain(string,user_say_inventory)
         {
            // If UserSayInventory handles the string, don't keep checking.
            if Send(self,@UserSayInventory,#string=string)
            {
               return;
            }
         }

         // Run additional checks if user drank a beta potion
         if Send(self,@CheckPlayerFlag,#flag=PFLAG2_BETA_POTION,#flagset=2)
         {
            // If UserSayBetaPotion handles the string, don't keep checking.
            if Send(self,@UserSayBetaPotion,#string=string)
            {
               return;
            }
         }
      }

      if NOT Send(poOwner,@RoomReqCommunication,#type=type,#string=string,
                  #who=self)
      {
         return;
      }

      if type = SAY_GUILD
      {
         if StringContain(string,user_say_guild_motd)
         {
            // If UserSayGuildMOTD handles the string, don't keep checking.
            if Send(self,@UserSayGuildMOTD,#string=string)
            {
               return;
            }
         }

         // If the user has tells squelched, block guild sends too.
         if NOT Send(self,@TrySayGroup)
         {
            return;
         }

         Send(self,@UserSayGuild,#string=string);

         return;
      }

      if type = SAY_NORMAL
         OR type = SAY_EMOTE
         OR type = SAY_DM
      {
         if (piFlags & PFLAG_TRANCE)
         {
            // See if the trance spell does anything special 
            //  with says.  Note that the 'say' will still go off.

            bTranceBlocksSay = FALSE;
            
            foreach i in plEnchantments
            {
               if IsClass(nth(i,2),&Trance)
               {
                  lEnchantData = nth(i,3);
                  oSpell = first(lEnchantData);
                  Post(oSpell,@SomethingSaidDuringTrance,
                       #who=self,#string=string,#lTargets=Nth(lEnchantData,3));
                  
                  if Send(oSpell,@TranceBlocksSay)
                  {
                     bTranceBlocksSay = TRUE;
                  }
               }

               if bTranceBlocksSay
               {
                  return;
               }
            }
         }

         // If the user has says squelched, don't let them speak.
         if Send(self,@TrySay)
         {
            Send(poOwner,@SomeoneSaidRoom,#what=self,#type=type,#string=string);
         }

         return;
      }

      if type = SAY_MESSAGE
      {
         if IsClass(self,&DM)
         {
            Send(poOwner,@SomeoneSaidRoom,#what=self,#type=type,
                 #string=user_echo_str,#parm1=string);
         }

         return;
      }

      if type = SAY_YELL
      {
         // Send to adjacent rooms
         // If the user has says squelched, don't let them speak.
         if Send(self,@TrySay)
         {
            Send(poOwner,@SomeoneSaidRoom,#what=self,#type=type,#string=string);
         }

         return;
      }

      if type = SAY_EVERYONE
      {
         if stringContain(string,"~r~B~g~r")
         {
            if ++piCheaterLogs < 10
            {
               if StringContain(string,"More than 20 bad bio characters.")
               {
                  Debug("ALERT! ",Send(self,@GetTrueName),self," used more "
                        "than 20 bad chars in their bio.");
               }
               else
               {
                  ++piCheaterLogs;
                  Debug("ALERT! ",Send(self,@GetTrueName),self," used more "
                        "than 50 bad chars in their bio.");
               }
            }

            return;
         }

         // Send to everyone, if not squelched.
         if Send(self,@TryBroadcast)
         {
            Send(SYS,@SystemBroadcast,#what=self,#type=type,#string=string);
         }

         return;
      }

      Debug("Got unknown user say type",type);

      return;
   }

   UserSayGuildMOTD(string = $)
   {
      if poGuild = $
      {
         return FALSE;
      }

      if StringContain(string,guild_motd_command)
         AND (Send(poGuild,@GetRank,#who=self) = RANK_MASTER
            OR Send(poGuild,@GetRank,#who=self) = RANK_LIEUTENANT)
      {
         Send(poGuild,@SetGuildMOTD,#who=self,#string=string);

         return TRUE;
      }

      if StringContain(string,guild_clear_motd_command)
         AND Send(poGuild,@GetGuildMaster) = self
         AND (Send(poGuild,@GetRank,#who=self) = RANK_MASTER
            OR Send(poGuild,@GetRank,#who=self) = RANK_LIEUTENANT)
      {
         Send(poGuild,@SetGuildMOTD,#who=self,#string=$);

         return TRUE;
      }

      return FALSE;
   }

   UserSayBetaPotion(string = $)
   {
      local iSchool, iLevel, iLearnPoints, iMaxLearnPoints;

      if string <> $
      {
         iSchool = 0;
         iLevel = 0;
         iLearnPoints = 0;

         iSchool = Send(Send(SYS,@GetLore),@CheckSchoolString,#string=string);
         iLevel = Send(Send(SYS,@GetLore),@CheckLevelString,#string=string);

         if iSchool <> 0 AND iLevel <> 0
         {
            if iSchool = SKS_WEAPONCRAFT
            {
               Send(self,@GivePlayerAllSkills,#school=iSchool,#level=iLevel,
                     #iAbility=99,#upto=TRUE);
            }
            else if iSchool = SS_SHALILLE
               AND Send(self,@GetNumSpellsInSchool,#school=SS_QOR)
            {
               // Can't add Shal'ille when already has Qor.
               return FALSE;
            }
            else if iSchool = SS_QOR
               AND Send(self,@GetNumSpellsInSchool,#school=SS_SHALILLE)
            {
               // Can't add Qor when already has Shal'ille.
               return FALSE;
            }
            else
            {
               Send(self,@GivePlayerAllSpells,#school=iSchool,#level=iLevel,
                     #iAbility=99,#upto=TRUE);
            }

            iMaxLearnPoints = Send(SETTINGS_OBJECT,@GetMaxLearnPoints)
                                 + (Send(self,@GetRawIntellect) * 2) / 5;
            iLearnPoints = Send(self,@GetTotalLearnPoints,#except=0);
            Post(self,@MsgSendUser,#message_rsc=player_Debug_learnpoints,
                  #parm1=iLearnPoints,#parm2=iMaxLearnPoints);

            // iLearnPoints should always equal iMaxLearnPoints, 
            // only time it can go over if it is a DM using the potion
            if iLearnPoints >= iMaxLearnPoints
            {
               Send(self,@SetPlayerFlag,#flag=PFLAG2_BETA_POTION,
                     #value=FALSE,#flagset=2);

               return TRUE;
            }
         }
      }

      return;
   }

   UserSayInventory(string = $)
   {
      local i, lSortInfo, oTemplateItem, n, bFound;

      if StringEqual(string,user_say_inv_sort_clear)
      {
         plClassOrderPreferences = $;
         Send(self,@MsgSendUser,#message_rsc=inventory_sort_cleared);

         return TRUE;
      }

      if StringEqual(string,user_say_inv_sort_report)
      {
         Send(self,@MsgSendUser,#message_rsc=inventory_sort_report_header);

         lSortInfo = Send(SYS,@GetSortInfo);

         foreach i in plClassOrderPreferences
         {
            bFound = FALSE;
            foreach n in lSortInfo
            {
               if Nth(n,2) = i
               {
                  Send(self,@MsgSendUser,#message_rsc=inventory_sort_report,
                        #parm1=Nth(n,1));
                  bFound = TRUE;

                  break;
               }
            }

            if bFound
            {
               continue;
            }

            oTemplateItem = Send(SYS,@FindTemplateItemByClass,#cClass=i);

            if oTemplateItem <> $
            {
               Send(self,@MsgSendUser,#message_rsc=inventory_sort_report,
                     #parm1=Send(oTemplateItem,@GetName));
            }
         }

         return TRUE;
      }

      if StringContain(string,user_say_inv_sort_add)
      {
         StringSubstitute(string,user_say_inv_sort_add,"");

         lSortInfo = Send(SYS,@GetSortInfo);

         foreach i in lSortInfo
         {
            if StringEqual(string,First(i))
            {
               if plClassOrderPreferences <> $
                  AND FindListElem(plClassOrderPreferences,Nth(i,2)) <> 0
               {
                  Send(self,@MsgSendUser,#message_rsc=inventory_already_in_list);

                  return TRUE;
               }

               plClassOrderPreferences =
                       AppendListElem(Nth(i,2),plClassOrderPreferences);

               Send(self,@MsgSendUser,#message_rsc=inventory_class_added,
                     #parm1=First(i));

               return TRUE;
            }
         }

         oTemplateItem = Send(SYS,@FindTemplateItemByName,#string=string);

         if oTemplateItem <> $
         {
            plClassOrderPreferences = AppendListElem(GetClass(oTemplateItem),
                                             plClassOrderPreferences);
            Send(self,@MsgSendUser,#message_rsc=inventory_class_added,
                  #parm1=Send(oTemplateItem,@GetName));

            return TRUE;
         }

         Send(self,@MsgSendUser,#message_rsc=inventory_sort_no_item);

         return TRUE;
      }

      if StringEqual(string,user_say_inv_sort_help)
      {
         Send(self,@MsgSendUser,#message_rsc=inventory_sort_help);

         return TRUE;
      }

      if StringEqual(string,user_say_inv_sort)
      {
         plPassive = Send(SYS,@SortItemsByType,#lItems=plPassive,
                           #lClassOrder=plClassOrderPreferences);
         Send(self,@ToCliInventory);
         Send(self,@ToCliUseList);

         return TRUE;
      }

      return FALSE;
   }

   UserSaySurvival(string = $)
   {
      local lSurvivalOptions, oForceBaseRoom;

      if IsClass(poOwner,&SurvivalRoom)
      {
         // Can't start an arena from an existing one.
         return FALSE;
      }

      if StringContain(string,user_say_start_solo_survival)
      {
         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         Send(Send(SYS,@GetSurvivalRoomMaintenance),@CreateRoom,
               #who=self,#sString=string);

         return TRUE;
      }

      if StringEqual(string,user_say_join_pub_survival)
      {
         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindPublicRoom) = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_no_public_rooms);

            return TRUE;
         }

         if Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindPublicRoom),@GetAllowJoins)
         {
            Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindPublicRoom),@Teleport,#what=self);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=public_survival_too_late);
         }

         return TRUE;
      }

      if StringContain(string,user_say_start_pub_survival)
      {
         lSurvivalOptions = $;
         if (NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1)
            AND NOT IsClass(self,&Admin)
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         oForceBaseRoom = $;
         if IsClass(self,&DM)
         {
            if StringContain(string,user_say_survival_opt_pvpon)
            {
               lSurvivalOptions = Cons(OPT_PVP_ON,lSurvivalOptions);
            }
            if StringContain(string,user_say_survival_opt_starthere)
            {
               oForceBaseRoom = poOwner;
            }
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindPublicRoom) = $
         {
            Send(Send(SYS,@GetSurvivalRoomMaintenance),@CreateRoom,
                  #who=self,#iPublic=TRUE,#sString=string,
                  #lSurvivalOptions=lSurvivalOptions,
                  #oForceBaseRoom=oForceBaseRoom);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_already_public);
         }

         return TRUE;
      }

      if StringEqual(string,user_say_join_guild_survival)
      {
         if poGuild = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_no_guild);

            return TRUE;
         }

         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindRoomByGuild,
                  #oGuild=poGuild) = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_no_guild_rooms);

            return TRUE;
         }

         if Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindRoomByGuild,#oGuild=poGuild),@GetAllowJoins)
         {
            Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindRoomByGuild,#oGuild=poGuild),@Teleport,#what=self);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=guild_survival_too_late);
         }

         return TRUE;
      }

      if StringContain(string,user_say_start_guild_survival)
      {
         lSurvivalOptions = $;
         if poGuild = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_no_guild);

            return TRUE;
         }

         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindRoomByGuild,
                  #oGuild=poGuild) = $
         {
            Send(Send(SYS,@GetSurvivalRoomMaintenance),@CreateRoom,
                  #who=self,#sString=string,#guild_survival=TRUE);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_already_guild);
         }

         return TRUE;
      }

      return FALSE;
   }

   UserSayGuild(string = $)
   {
      local i,lUsers,each_obj;

      if poGuild = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_say_guild);

         return;
      }

      lUsers = $;
      foreach i in Send(poGuild,@GetMemberList)
      {
         each_obj = First(i);
         if each_obj <> self and Send(each_obj,@IsLoggedOn)
         {
            lUsers = Cons(each_obj,lUsers);
         }
      }

      if Length(lUsers) = 0
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild_logged_on);

         return;
      }

      Send(self,@UserSayGroup,#users=lUsers,#string=string,#no_tell=TRUE);

      return;
   }

   UserSayGroup(users = $,string = $,no_tell=FALSE)
   "<no_tell> = TRUE means always Send the 'Sends' message, not 'tells'"
   {
      local i,type;

      // A bit hackish, no_tell is currently only used for guild Sends.  Don't
      //  do TrySayGroup on guild Sends to eliminate mana costs.
      if no_tell OR Send(self,@TrySayGroup,#users=users)
      {
         AddPacket(1,BP_SAID,4,self,4,vrName,1,SAY_GROUP);
         if Length(users) = 1 AND NOT no_tell
         {
            AddPacket(4,user_send_single_echo_str,
                      4,Send(First(users),@GetTrueName), 0,string);
         }
         else
         {
            AddPacket(4,user_send_echo_str, 0,string);
         }
         
         SendPacket(poSession);
         
         if IsClass(self,&DM)
            AND Send(self,@IsHidden)
            AND NOT IsClass(First(users),&Admin)
         {
            // The admin is hidden, warn them about that.
            Send(self,@MsgSendUser,#message_rsc=user_no_respond);
         }

         type = SAY_GROUP;
         if Length(users) = 1 AND NOT no_tell
         {
            type = SAY_GROUP_ONE;
         }

         if NOT Send(poOwner,@RoomReqCommunication,#type=type,#string=string,
                     #who=self,#users=users)
         {
            return;
         }

         foreach i in users
         {
            Send(i,@SomeoneSaid,#what=self,#type=type,#string=string);
         }
      }

      return;
   }

   UserLook(what = $)
   {
      Send(what,@TryLook,#what=self);
//      Send(self,@SetPlayerView,#what=what,
//         #iFlags =   REMOTE_VIEW_CONTROL | REMOTE_VIEW_TURN  
//                   | REMOTE_VIEW_TILT | REMOTE_VIEW_MID
//                   | REMOTE_VIEW_VALID_LIGHT,
//         #iLight = LIGHT_MAX);
      return;
   }

   SendLook(what = $, bShow_All = FALSE)
   {
      local byInscription, oOwner, bAbility;

      if pbLogged_on
      {
         if what <> $
            AND NOT IsObject(what)
         {
            // Log a debug message for this
            Debug("User ",self," tried to look at non-object ",
                  what);

            return;
         }

         if IsClass(what,&ReagentBag)
            AND Send(what,@GetReagentBagContents) <> $
         {
            Send(self,@UserObjectContents,#what=what);
            return;
         }

         // Show special description for non-DM spells that
         // players can learn.
         if (IsClass(what,&Spell)
            AND NOT (Send(what,@GetSchool) = SS_DM_COMMAND)
            AND Send(what,@CanBeLearned))
         {
            bAbility = TRUE;
            AddPacket(1,BP_LOOK_SPELL);
         }
         else if (IsClass(what,&Skill))
         {
            bAbility = TRUE;
            AddPacket(1,BP_LOOK_SKILL);
         }
         else
         {
            bAbility = FALSE;
            AddPacket(1,BP_LOOK);
         }

         Send(self,@ToCliObject,#what=what,#show_type=SHOW_LOOK,
               #bShow_All=bShow_All);

         if (bAbility)
         {
            // Must add School, level, mana, vigor costs first.
            Send(what,@ShowDesc,#bShowAll = bShow_All,#who=self);
         }
         else
         {
            byInscription = 0x00;
            oOwner = Send(what,@GetOwner);
            if Send(what,@HasInscription)
            {
               byInscription |= 0x02;
            }

            if Send(what,@CanEditInscription)
               AND (oOwner = self OR oOwner = poOwner)
            {
               byInscription |= 0x01;
            }

            AddPacket(1, byInscription);
            Send(what,@ShowDesc,#bShowAll = bShow_All,#who=self);

            if (byInscription)
            {
               Send(what,@ShowInscription);
            }
         }

         SendPacket(poSession);
      }

      return;
   }

   SendLookNews(what = $)
   {
      if pbLogged_on
         AND (Send(what,@GetNewsPermission,#what=self) & NEWS_PERMISSION_READ)
      {
         if NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         {
            Send(self,@MsgSendUser,#message_rsc=user_news_los);

            return FALSE;
         }

         AddPacket(1,BP_LOOK_NEWSGROUP, 2,Send(what,@GetNewsNum),
                   1,Send(what,@GetNewsPermission,#what=self));

         Send(self,@ToCliObject,#what=what);
         Send(what,@ShowDesc);

         SendPacket(poSession);
      }

      return;
   }

   SendLookPlayerIllusion(what = $)
   {
      local iIllusion_type,oIllusion,oSpell;

      oSpell = Send(SYS,@findspellbynum,#num=SID_MORPH);
      if Send(what,@IsEnchanted,#what=oSpell)
      {
         iIllusion_type = First(Send(what,@GetEnchantedState,#what=oSpell));
         if iIllusion_type = $
         {
            return;
         }

         oIllusion = Nth(Send(SYS,@GetMonsterTemplates),iIllusion_type);
      }

      else
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_FEIGN_DEATH);
         if Send(what,@IsEnchanted,#what=oSpell)
         {
            // The illusion is the first element of the list.
            oIllusion = first(Send(what,@GetEnchantedState,#what=oSpell));
         }
      }

      Send(self,@SendLook,#what=oIllusion);

      return;
   }

   SendLookPlayer(what = $)
   {
      if pbLogged_on
      {
         if Send(what,@checkplayerflag,#flag=PFLAG_MORPHED)
            OR Send(what,@IsEnchanted,
                    #what=Send(SYS,@FindSpellByNum,#Num=SID_FEIGN_DEATH))
         {
            Send(self,@SendLookPlayerIllusion,#what=what);

            return;
         }

         AddPacket(1,BP_USERCOMMAND,1,UC_LOOK_PLAYER);

         Send(self,@ToCliObject,#what=what,#show_type=SHOW_LOOK);

         // Can viewer edit description and web page?  Send 1 or 0.
         if what = self
            OR IsClass(self,&Admin)
         {
            AddPacket(1,1);
         }
         else
         {
            AddPacket(1,0);
         }

         Send(what,@ShowDesc);
         Send(what,@ShowExtraInfo);

         if Send(what,@GetURL) = $
         {
            AddPacket(STRING_RESOURCE,user_default_url);
         }
         else
         {
            AddPacket(0,Send(what,@GetURL));
         }

         SendPacket(poSession);
      }

      return;
   }

   TryLook(what = $)
   {
      if (piFlags & PFLAG_INVISIBLE)
         AND what <> self
         AND NOT Send(self,@PlayerIsImmortal)
      {
         return;
      }

      if NOT Send(self, @IsInSameRoom, #what = what)
      {
         Debug("User ", self, "tried to look at object in another room");
         return;
      }

      Send(what,@SendLookPlayer,#what=self);

      return;
   }

   UserLookupNames(amount = $,string = $)
   "Sent by client to resolve a string of mail destination into object IDs."
   {
      AddPacket(1,BP_LOOKUP_NAMES, 2,amount);

      ParseString(string,",",@UserLookupEachName);
      SendPacket(poSession);

      return;
   }

   UserLookupEachName(string = $)
   "Used to find names for mail."
   {
      local oUser, lNames, oMailingList;

      if StringEqual(string,system_guild_rsc)
         AND poGuild <> $
      {
         AddPacket(4,poGuild);
      }
      else
      {
         // TODO: enable guild officer mailing lists.
         if FALSE AND StringEqual(string,user_guildofficer_rsc)
            AND poGuild <> $
         {
            lNames = Send(poGuild,@GetOfficers);
            oMailingList = Create(&MailingList,#thePerson=lNames);
            AddPacket(4,oMailingList);
         }
         else
         {
            oUser = Send(SYS,@FindUserByString,#string=string);

            if oUser = $
            {
               AddPacket(4,0);
            }
            else
            {
               AddPacket(4,oUser);
            }
         }
      }

      return;
   }

   UserChangeDescription(string = $)
   {
      local iCount;

      if string = $
      {
         string = psPlayerDescription;
      }

      if StringContain(psPlayerDescription,"¶")
      {
         iCount = 0;
         while StringContain(psPlayerDescription,"¶")
         {
            StringSubstitute(psPlayerDescription,"¶","");
            if ++iCount > 10
            {
               // At this point, it's malicious.
               Debug("ALERT! ",Send(self,@GetTrueName)," is trying to crash "
                     "the server via bad bio characters.");
               string = CreateString();

               break;
            }
         }
      }

      psPlayerDescription = string;

      return;
   }

   GetURL()
   {
      return psURL;
   }

   UserChangeURL(string = $)
   {
      if StringLength(string) > MAX_URL_LEN
      {
         Debug(self,Send(self,@GetTrueName),
               "tried to set URL larger than MAX_URL_LEN");

         return;
      }

      psURL = string;

      return;
   }

   UserTryActivate(what = $)
   {
      if IsClass(what,&Sun) OR IsClass(what,&Moon)
      {
         // No message for background overlays.
         return;
      }

      if Send(what,@GetOwner) <> poOwner
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_activate_unk,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
              
         return;
      }

      if NOT Send(what,@TryActivate,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_activate_failed,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return;
      }

      return;
   }

   UserMail(dest_list = $,string = $)
   {
      local i;

      // Can't send mail if squelched.
      if piFlags2 & PFLAG2_SQUELCHED_MAIL
      {
         Send(self,@MsgSendUser,#message_rsc=user_mail_squelched);

         return;
      }

      if StringLength(string) > MAIL_MESSAGE_MAX_LENGTH
      {
         Send(self,@MsgSendUser,#message_rsc=user_mail_toobig);

         return;
      }

      Send(self,@MsgSendUser,#message_rsc=user_mail_to);

      foreach i in dest_list
      {
         if (FindListElem(plForcedIgnore, i))
         {
            Send(self,@MsgSendUser,#message_rsc=user_mail_forcedignore,
                  #parm1=Send(i,@GetTrueName),#type1=STRING_RESOURCE);

            continue;
         }

         Send(i,@ReceiveMail,#from=Send(self,@GetTrueName),
              #dest_list=dest_list,#perm_string=string);
      }

      return;
   }

   UserGetNewMail()
   {
      local i, j, lNew_mail, iNum, iIndex, lMail_strings;

      if plNew_mail = $
      {
         AddPacket(1,BP_MAIL,4,0,4,0,2,0,4,0);
         SendPacket(poSession);

         return;
      }

      // Send one BP_MAIL message for each new mail message
      iNum = Length(plNew_mail);

      for (i = 0; i < iNum; ++i)
      {
         // take new mail from the end of the list,
         // so they are in order of arrival
         iIndex = Length(plNew_Mail) - i;

         // This is a list of [ from, time, list of to ]
         lNew_mail = Nth(plNew_mail, iIndex);

         AddPacket(1,BP_MAIL, 4,iIndex, STRING_RESOURCE,First(lNew_mail),
                   STRING_AS_INTEGER,Nth(lNew_mail,MAIL_LONG_TIME),
                   2,Length(Nth(lNew_mail,MAIL_RECEIVERS)));
         foreach j in Nth(lNew_mail,MAIL_RECEIVERS)
         {
            AddPacket(STRING_RESOURCE,Send(j,@GetTrueName));
         }

         lMail_strings = Nth(lNew_mail,MAIL_TEXT);
         if Length(lMail_strings) = 1
         {
            // standard string as mail
            AddPacket(4,user_show_mail, 0,First(lMail_strings));
         }
         else
         {
            // nested // things as mail
            AddPacket(4,user_show_nested_mail);
            j = 1;
            while j <= Length(lMail_strings)
            {
               AddPacket(Nth(lMail_strings,j),Nth(lMail_strings,j+1));
               j += 2;
            }
         }

         SendPacket(poSession);
      }

      return;
   }

   UserDeleteMail(index = $)
   {
      local lNew_Mail;

      if index <> $
         AND plNew_mail <> $
      {
         if Length(plNew_mail) < index
         {
            Debug(self,"Delete mail got invalid index",index);

            return;
         }

         lNew_mail = Nth(plNew_mail, index);
         plNew_mail = DelListElem(plNew_mail, lNew_mail);
      }

      return;
   }

   UserDeleteNews(nid = $, index = $)
   {
      local oNews;

      if (index = $
         OR nid = $)
      {
         Debug("UserDeleteNews got $ parameter! Index is ",index,
               " NID is ",nid);

         return;
      }

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if (oNews = $)
      {
         Debug("UserDeleteNews couldn't find news globe ",nid);

         return;
      }

      if (Send(oNews,@RemovePost,#who=self,#index=index))
      {
         GodLog(Send(self,@GetTrueName)," deleted post ",index,
               " from newsglobe ",Send(oNews,@GetName));
      }
      else if (IsClass(self,&DM))
      {
         Debug("Failed to remove post index ",index," from newsglobe ",
               Send(oNews,@GetName));
      }

      return;
   }

   UserUseItem(what = $)
   {
      // check if valid, if item, if holding

      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_USE);
      }

      if NOT IsClass(what,&Item)
      {
         return;
      }

      Send(self,@TryUseItem,#what=what);

      return;
   }

   UserUnuseItem(what = $)
   {
      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_USE);
      }

      if NOT IsClass(what,&Item)
      {
         return;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         return;
      }

      Send(self,@TryUnuseItem,#what=what);

      return;
   }

   UserAttack(type=STROKE_NORMAL,what=$)
   {
      local i, use_weapon, stroke_id, stroke_obj, is_spell;

      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_ATTACK);
      }

      if (piFlags & PFLAG_NO_FIGHT)
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_fight);

         return FALSE;
      }

      // Get use_weapon
      use_weapon = Send(self,@GetWeapon);

      // Convert type over to a stroke here.
      if type = STROKE_NORMAL
      {
         // Kludgeish (at least sloppy code): If we have a spell-weapon,
         //  we just use punch to pass the checks below.
         if (use_weapon = $) OR IsClass(use_weapon,&Spell)
         {
            stroke_id = SKID_PUNCH;
         }
         else
         {
            stroke_id = Send(use_weapon,@GetDefaultStrokeNumber);
         }
      }
      else
      {
         Debug("Non-normal stroke received.");

         return FALSE;
      }

      // except for punch and slash, a player cannot use an attack type he
      // doesn't have.  This in to prevent hacking.
      if stroke_id <> SKID_PUNCH
         AND stroke_ID <> SKID_SLASH
         AND stroke_ID <> SKID_FIRE 
      {
         if NOT Send(self,@HasSkill,#num=stroke_id)
         {
            stroke_obj = Send(SYS,@FindSkillByNum,#num=stroke_ID);
            Send(self,@MsgSendUser,#message_rsc=user_doesnt_know_stroke,
                 #parm1=Send(stroke_obj,@GetName));

            return FALSE;
         }
      }

      // Get what's possible
      if NOT IsClass(what,&Battler)
      {
         // tell 'em
         Send(self,@MsgSendUser,#message_rsc=user_cant_attack_non_battler,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return FALSE;
      }

      // kludgish: If morphed, use punch as our stroke object, we use the
      //  monster's stats for combat.
      if Send(self,@IsEnchanted,#byClass=&Morph)
      {
         stroke_id = SKID_PUNCH;
         use_weapon = $;
      }

      if use_weapon = $ OR NOT IsClass(use_weapon,&Spell)
      {
         stroke_obj = Send(SYS,@FindSkillByNum,#num=stroke_id);
      }
      else
      {
         // Use the "weapon" (spell) as the stroke object.
         stroke_obj = use_weapon;
      }

      // Set flag so that wall elements can affect us.
      Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=TRUE);

      return Send(self,@TryAttack,#what=what,#use_weapon=use_weapon,
                  #stroke_obj=stroke_obj);
   }

   UserCast(oSpell=$,lTargets=$)
   {
      local i, bFound, iSpell, iSpellNum, iSpellPower, lFinalTargets, iCost,
            bSuccess, bFreeCast;

      // Check for valid spell first. This is mainly an issue during
      // system saves where a user might cast something with the wrong
      // object ID.
      if oSpell = $
         OR NOT IsClass(oSpell,&Spell)
      {
         return;
      }

      // PFLAG_TRANCE can stem from...
      // 1) ...&Trance when a spell with cast time is being cast
      // such as fire wall, or a steered spell like elusion.
      // 2) ...any kind of maintained spell that can be disrupted,
      // such as mana focus or a song.
      if piFlags & PFLAG_TRANCE
      {
         // GetTranceAbility returns the spell that &Trance is preparing
         // to cast. If we are already preparing to cast the same spell,
         // don't interrupt our cast.
         if Send(self,@GetTranceAbility) = oSpell
         {
            return;
         }
         // We are trying to cast a different spell or not casting at all.
         // Either way, our cast may disrupt &Trance or a maintained spell.
         else
         {
            Send(self,@BreakTrance,#event=EVENT_CAST,#what=oSpell);
         }
      }

      if ((piFlags & PFLAG_NO_MAGIC)
         OR Send(self,@IsInCannotInteractMode))
         AND NOT IsClass(oSpell,&Phase)
         AND NOT IsClass(oSpell,&Spectate)
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_cast);

         return;
      }

      iSpellNum = Send(oSpell,@GetSpellNum);

      bFound = FALSE;
      foreach i in plSpells
      {
         iSpell = Send(self,@DecodeSpellNum,#compound=i);
         if iSpellNum = iSpell
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         // We don't know the spell.  Bail out.
         return;
      }

      // Do we need a specific set of targets?
      lFinalTargets = Send(oSpell,@GetTargets,#who=self,#lTargets=lTargets);

      if NOT Send(poOwner,@ReqSpellCast,#who=self,#oSpell=oSpell,
                  #lItems=lFinalTargets)
      {
         // A spell cannot be cast in this room.
         return;
      }

      iCost = Send(oSpell,@GetMeditateRatio);

      // Get the spell power
      iSpellPower = Send(oSpell,@GetSpellPower,#who=self);

      // Check if it's a free cast.
      if (iCost <= Send(self,@GetUnboundEnergy)
         AND iCost > 0
         AND Send(oSpell,@IsFreeCastable))
      {
         bFreeCast = TRUE;
         // Free casts get a spellpower bonus.
         iSpellPower = Bound(iSpellPower + 20,SPELLPOWER_MINIMUM,SPELLPOWER_MAXIMUM);
      }
      else
      {
         bFreeCast = FALSE;
      }

      // First make sure user has enough magic points, reagents, etc.
      if NOT Send(oSpell,@CanPayCosts,#who=self,#lTargets=lFinalTargets,
                  #iSpellpower=iSpellpower,#bFreeCast=bFreeCast)
      {
         // Player failed some sort of internal check
         return;
      }

      bSuccess = bFreeCast OR Send(oSpell,@SuccessChance,#who=self,
               #iSpellpower=iSpellpower,#lTargets=lFinalTargets);

      if Send(oSpell,@PayCosts,#who=self,#iSpellPower=iSpellPower,
               #lTargets=lFinalTargets,#bFreeCast=bFreeCast,
               #bSuccess=bSuccess)
      {
         // If we had a free cast, deduct points from our unbound energy.
         if bFreeCast
         {
            Send(self,@AddUnboundEnergy,#iAmount=-iCost);
         }

         // Set flag so that wall elements can affect us.
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=TRUE);

         // Alright, cast that spell already.
         Send(oSpell,@BeginCastingTrance,#who=self,#lTargets=lFinalTargets,
               #iSpellPower=iSpellPower,#bFreeCast=bFreeCast,
               #bSuccess=bSuccess);
      }

      return;
   }

   UserPerform(oSkill=$,lTargets=$)
   {
      local i, bFound, iSkill, iSkillNum, iSpellPower, lFinalTargets, iCost,
            iTime, bSuccess;

      // Check for valid skill first. This is mainly an issue during
      // system saves where a user might perform something with the wrong
      // object ID.
      if oSkill = $
         OR NOT IsClass(oSkill,&ActiveSkill)
      {
         return;
      }

      if piFlags & PFLAG_TRANCE
      {
         if Send(self,@GetTranceAbility) = oSkill
         {
            return;
         }
         else
         {
            Send(self,@BreakTrance,#event=EVENT_ATTACK,#what=oSkill);
         }
      }

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_perform);

         return;
      }

      iSkillNum = Send(oSkill,@GetSkillNum);

      bFound = FALSE;
      foreach i in plSkills
      {
         iSkill = Send(self,@DecodeSkillNum,#compound=i);
         if iSkillNum = iSkill
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         // We don't know the skill.  Bail out.
         return;
      }

      // Do we need a specific set of targets?
      lFinalTargets = Send(oSkill,@GetTargets,#who=self,#lTargets=lTargets);

      // First make sure user has enough magic points, reagents, etc.
      if NOT Send(oSkill,@CanPayCosts,#who=self,#lTargets=lFinalTargets)
      {
         // Player failed some sort of internal check
         return;
      }

      bSuccess = Send(oSkill,@SuccessChance,#who=self,#lTargets=lFinalTargets);

      if Send(oSkill,@PayCosts,#who=self,#lTargets=lFinalTargets,#bSuccess=bSuccess)
      {
         // Set flag so that wall elements can affect us.
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=TRUE);

         // Alright, perform that skill already.
         Send(oSkill,@BeginPerformPreparation,#who=self,#lTargets=lFinalTargets,
            #bSuccess=bSuccess);
      }

      return;
   }

   UserGuildCommand(Command_num = $, oTarget = $, data = $)
   "Used to perform a guild command - may need to be modified by Andrew to"
   "fit better with the needed client stuff."
   "Data varies with the command - currently used for setrank."
   {
      local oCommand;

      if poGuild = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild);

         return;
      }

      oCommand = Send(SYS,@FindGuildCommandByNum,#num=Command_num);

      // If a player is in a trance, break it
      if piFlags & PFLAG_TRANCE
         AND (Command_num = GCID_RENOUNCE
            OR Command_num = GCID_DISBAND)
      {
         Send(self,@BreakTrance,#event=EVENT_CAST,#what=oCommand);
      }

      // Be sure player has guild command.
      if Send(self,@HasGuildCommand,#command_num=Command_num)
      {
         Send(oCommand,@DoCommand,#who=self,#oTarget=oTarget,#data=data);
      }

      return;
   }

   UserAction(action = $)
   {
      // Make this count as an attack.  This prevents action spamming.
      // IsOkayAttackTime defaults to 1 second
      if NOT Send(self,@IsOkayAttackTime)
      {
         return;
      }

      if action = UA_WAVE
      {
         Send(self,@DoWave);

         if poMercenary <> $ 
            AND NOT IsTimer(poMercenary)
            AND (Send(poMercenary,@GetOwner) = poOwner)
         {
            Send(poMercenary,@DoWave);
         }

         return;
      }

      if action = UA_POINT
      {
         Send(self,@DoPoint);

         if poMercenary <> $ 
            AND NOT IsTimer(poMercenary)
            AND (Send(poMercenary,@GetOwner) = poOwner)
         {
            Send(poMercenary,@DoPoint);
         }

         return;
      }

      if action = UA_DANCE
      {
         Send(self,@DoDance);

         if poMercenary <> $ 
            AND NOT IsTimer(poMercenary)
            AND (Send(poMercenary,@GetOwner) = poOwner)
         {
            Send(poMercenary,@DoDance);
         }

         return;
      }

      // All other actions above UA_WRY have been checked above.
      if action > UA_WRY
      {
         return;
      }

      piAction = action;

      if piAction < 1
      {
         piAction = 1;
      }

      Send(poOwner,@SomethingDidAction,#what=self,#action=action);

      return;
   }

   UserOffer(what = $,item_list = $,number_list = $)
   {
      local i, lObjects, lNumbers, oOffer_num;

      if Send(self,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      // Must be holding things you're offering, and have no dupes.
      lObjects = $;
      foreach i in item_list
      {
         if lObjects <> $
            AND FindListElem(lObjects,i) <> 0
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self,"tried to offer a "
                  "duplicate item to",Send(what,@GetTrueName),what,".");

            return FALSE;
         }

         if Send(i,@GetOwner) <> self
         {
            return FALSE;
         }

         lObjects = Cons(i,lObjects);
      }

      // Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad offer quantity", i, "from user", self);

            return FALSE;
         }
      }

      if poOffer_who <> $
         OR NOT Send(what,@CanAcceptOffer,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_offer,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
              
         return FALSE;
      }

      if Send(poOwner,@IsArena)
         AND NOT Send(poOwner,@CanOffer,#who=self,#target=what)
      {
         return FALSE;
      }

      poOffer_who = what;
      plOffer_items = $;

      lNumbers = number_list;
      foreach i in item_list
      {
         if Send(i,@IsStackable)
         {
            oOffer_num = Create(GetClass(i),#model=i,
                           #number=Bound(First(lNumbers),0,Send(i,@GetNumber)));
            plOffer_items = Cons(oOffer_num,plOffer_items);
            lNumbers = Rest(lNumbers);
         }
         else
         {
            plOffer_items = Cons(i,plOffer_items);
         }
      }

      if NOT Send(what,@ReqOffer,#what=self,#item_list=plOffer_items)
      {
         Send(self,@CleanupCancelOffer);

         return;
      }

      AddPacket(1,BP_OFFERED,2,Length(plOffer_items));
      foreach i in plOffer_items
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      Send(what,@Offer,#what=self,#item_list=plOffer_items);

      return;
   }

   UserDeposit(what = $,item_list = $,number_list = $)
   {
      local i, lNumbers, oOffer_num, iNumber;

      // Only deposit to NPCs.
      if NOT IsClass(what,&Monster)
      {
         return FALSE;
      }

      // Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad deposit quantity", i, "from user", self);

            return FALSE;
         }
      }

      // must be holding things you're offering
      foreach i in item_list
      {
         if Send(i,@GetOwner) <> self
         {
            return;
         }
      }

      if poOffer_who <> $
         OR NOT (Send(what,@MobIsVaultman,#who=self)
                 OR (Send(what,@MobIsBanker,#who=self)
                     AND Length(item_list)=1
                     AND IsClass(First(item_list),&Money)) )
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_deposit_items);

         return FALSE;
      }

      poOffer_who = what;
      plOffer_items = $;

      lNumbers = number_list;
      foreach i in item_list
      {
         if Send(i,@IsStackable)
         {
            iNumber = Bound(First(lNumbers),0,Send(i,@GetNumber));
            oOffer_num = Create(GetClass(i),#number=iNumber,#model=i);
            plOffer_items = Cons(oOffer_num,plOffer_items);
            lNumbers = Rest(lNumbers);
         }
         else
         {
            plOffer_items = Cons(i,plOffer_items);
         }
      }

      if NOT Send(what,@ReqOffer,#what=self,#item_list=plOffer_items)
      {
         Send(self,@CleanupCancelOffer);

         return;
      }

      AddPacket(1,BP_OFFERED,2,Length(plOffer_items));
      foreach i in plOffer_items
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      Send(what,@Offer,#what=self,#item_list=plOffer_items);

      return;
   }

   RemoveNumberItemFromPossession(ToBeRemoved=$)
   "This is used with the offer setup, to remove number objects if you"
   "use number items as quest objects with ReqOffer."
   {
      local i, how_many;

      how_many = Send(ToBeRemoved,@GetNumber);
      foreach i in plPassive
      {
         if GetClass(i) = GetClass(ToBeRemoved)
         {
            if how_many > Send(i,@GetNumber)
            {
               Debug("Not enough of those numberitems!");

               return FALSE;
            }
            else
            {
               Send(i,@SubtractNumber,#number=how_many);

               return TRUE;
            }
         }
      }

      Debug("player has none of this class!");

      return FALSE;
    }

   CanAcceptOffer(who=$)
   "Returns true, since all players can accept offers."
   {
      if poOffer_who <> $
      {
         Send(who,@MsgSendUser,#message_rsc=user_offer_busy,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));

         return FALSE;
      }

      return TRUE;
   }

   ReqOffer(what = $,item_list = $)
   {
      local i, whatOwner;

      whatOwner = Send(what,@GetOwner);
      if whatOwner = $
      {
         return FALSE;
      }

      // If we're offline now, or in the process of going offline,
      // let the offering player know.
      if poOwner = $
         OR NOT pbLogged_on
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_not_online,
               #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));

         return FALSE;
      }

      // Different screens, let the offering player know.
      if whatOwner <> poOwner
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_not_here,
               #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
               #parm3=Send(self,@GetHeShe));

         // Perhaps we've just left the room as the offer is being made, in
         // which case this is a spurious log. The RIDs will determine whether
         // this is adjacent screens or an impossible offer.
         Debug("ALERT! ",Send(what,@GetTrueName),what," in RID ",
               Send(poOwner,@GetRoomNum)," offered items to ",
               Send(self,@GetTrueName),self," in distant RID ",
               Send(Send(what,@GetOwner),@GetRoomNum));

         return FALSE;
      }

      // Only one offer at a time.
      if poOffer_who <> $
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_busy,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));

         return FALSE;
      }

      // Check if we can receive the items.
      foreach i in item_list
      {
         if NOT Send(i,@ReqNewOwnerAttributes,#who=self,#type=1)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   Offer(what = $, item_list = $)
   {
      local i;

      if poOffer_who <> $
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_busy,
               #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         Send(what,@OfferCanceled);

         return;
      }

      poOffer_who = what;

      Send(self,@SysMsgSendUser,#message_rsc=user_got_offer,
           #parm1=Send(poOffer_who,@GetDef),#parm2=Send(poOffer_who,@GetName));

      AddPacket(1,BP_OFFER);
      Send(self,@ToCliObject,#what=what);
      AddPacket(2,Length(item_list));

      foreach i in item_list
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      return;
   }

   UserCancelOffer()
   {
      if poOffer_who = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_cancel_offer);

         return;
      }

      Send(poOffer_who,@OfferCanceled);

      Send(self,@CleanupCancelOffer);

      return;
   }

   CleanupCancelOffer()
   {
      local i;

      poOffer_who = $;
      foreach i in plOffer_items
      {
         if Send(i,@IsStackable)
         {
            Send(i,@Delete);
         }
      }

      plOffer_items = $;

      return;
   }

   OfferCanceled()
   {
      if poOffer_who <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_canceled_offer, 
              #parm1=Send(poOffer_who,@GetCapDef),
              #parm2=Send(poOffer_who,@GetName));
      }

      Send(self,@CleanupCancelOffer);

      if pbLogged_on
      {
         AddPacket(1,BP_OFFER_CANCELED);
         SendPacket(poSession);
      }

      return;
   }

   CancelIfOffer()
   {
      if poOffer_who <> $
      {
         AddPacket(1,BP_OFFER_CANCELED);
         SendPacket(poSession);

         Send(poOffer_who,@OfferCanceled);

         Send(self,@CleanupCancelOffer);
      }

      return;
   }

   UserCounterOffer(item_list = $,number_list = $)
   {
      local i, lNumbers, lObjects, oOffer_num;

      if poOffer_who = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_counteroffer);

         return;
      }

      // Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad counteroffer quantity", i, "from user", self);

            return FALSE;
         }
      }

      plOffer_items = $;
      lNumbers = number_list;

      foreach i in item_list
      {
         if lObjects <> $
            AND FindListElem(lObjects,i) <> 0
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self,"tried to "
                  "counter-offer a duplicate item to",
                  Send(poOffer_who,@GetTrueName),poOffer_who,".");
            Send(self,@CancelIfOffer);

            return FALSE;
         }

         if Send(i,@GetOwner) <> self
         {
            return FALSE;
         }

         if Send(i,@IsStackable)
         {
            if First(lNumbers) <= 0 OR First(lNumbers) > Send(i,@GetNumber)
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_deal_number, 
                    #parm1=First(lNumbers));
               Send(self,@CancelIfOffer);

               return;
            }

            oOffer_num = Create(GetClass(i),#number=First(lNumbers),#model=i);
            plOffer_items = Cons(oOffer_num,plOffer_items);
            lNumbers = Rest(lNumbers);
         }
         else
         {
            plOffer_items = Cons(i,plOffer_items);
         }

         lObjects = Cons(i,lObjects);
      }

      AddPacket(1,BP_COUNTEROFFERED, 2,Length(plOffer_items));
      foreach i in plOffer_items
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);
      if NOT Send(poOffer_who,@CounterOffer,#item_list=plOffer_items)
      {
         Send(self,@CleanupCancelOffer);

         AddPacket(1,BP_OFFER_CANCELED);
         SendPacket(poSession);

         // Send something here?
      }

      return;
   }

   CounterOffer(item_list = $)
   {
      local i;

      if poOffer_who = $
      {
         return FALSE;
      }

      AddPacket(1,BP_COUNTEROFFER,2,Length(item_list));
      foreach i in item_list
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      piFlags2 |= PFLAG2_OFFER_OTHER_ACPT;

      return TRUE;
   }

   CheckOfferStuff()
   {
      local i, j, bFound, iWeight, iBulk;

      iWeight = 0;
      iBulk = 0;

      foreach i in plOffer_items
      {
         if NOT Send(i,@ReqNewOwner,#what=poOffer_who)
         {
            Send(self,@MsgSendUser,#message_rsc=user_cant_drop_offer, 
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));
            Send(poOffer_who,@MsgSendUser,#message_rsc=user_didnt_drop_offer, 
                 #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
                 #parm3=Send(i,@GetIndef),#parm4=Send(i,@GetName));
            Send(self,@CancelIfOffer);

            return FALSE;
         }

         if NOT Send(i,@ReqNewOwnerAttributes,#who=poOffer_who,#type=1)
         {
            Send(self,@CancelIfOffer);

            return FALSE;
         }

         if Send(i,@IsStackable)
         {
            bFound = FALSE;
            foreach j in plPassive
            {
               if GetClass(j) = GetClass(i)
               {
                  if Send(j,@GetNumber) < Send(i,@GetNumber)
                  {
                     Send(self,@MsgSendUser,
                          #message_rsc=user_dont_have_number_offer);
                     Send(poOffer_who,@MsgSendUser,
                          #message_rsc=user_didnt_have_offer, 
                          #parm1=Send(self,@GetDef),
                          #parm2=Send(self,@GetName));
                     Send(self,@CancelIfOffer);

                     return FALSE;
                  }

                  bFound = TRUE;

                  break;
               }
            }

            if NOT bFound
            {
               Send(self,@MsgSendUser,#message_rsc=user_dont_have_offer);
               Send(poOffer_who,@MsgSendUser,
                    #message_rsc=user_didnt_have_offer, 
                    #parm1=vrName);
               Send(self,@CancelIfOffer);

               return FALSE;
            }
         }
         else
         {
            if NOT Send(self,@IsHolding,#what=i)
            {
               Send(self,@MsgSendUser,#message_rsc=user_dont_have_offer);
               Send(poOffer_who,@MsgSendUser,
                    #message_rsc=user_didnt_have_offer, 
                    #parm1=vrName);
               Send(self,@CancelIfOffer);
               
               return FALSE;
            }
         }

         iWeight += Send(i,@GetWeight);
         iBulk += Send(i,@GetBulk);
      }

      // Can they carry the items?
      if NOT Send(poOffer_who,@CanHoldWeightAndBulk,#weight=iWeight,
                  #bulk=iBulk)
      {
         Send(self,@MsgSendUser,#message_rsc=user_couldnt_carry_offer,
              #parm1=Send(poOffer_who,@GetDef),
              #parm2=Send(poOffer_who,@GetName));
         Send(poOffer_who,@MsgSendUser,#message_rsc=user_cant_carry_offer,
              #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName));
         Send(self,@CancelIfOffer);

         return FALSE;
      }

      return TRUE;
   }

   OfferSubtractNumberItems()
   {
      local i,j,bFound;

      foreach i in plOffer_items
      {
         if Send(i,@IsStackable)
         {
            foreach j in plPassive
            {
               if GetClass(j) = GetClass(i)
               {
                  Send(j,@SubtractNumber,#number=Send(i,@GetNumber));
               }
            }
         }
      }

      return;
   }

   UserAcceptOffer()
   {
      local i,oHolder,iLists,lTake_items;
      
      if poOffer_who = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_acceptoffer);

         return;
      }

      if NOT (piFlags2 & PFLAG2_OFFER_OTHER_ACPT)
      {
         Debug("ALERT!  Player ",Send(self,@GetTrueName),self," tried "
               "complete an offer without the other person accepting.");
         Send(self,@CancelIfOffer);

         return FALSE;
      }
      else
      {
         piFlags2 &= ~PFLAG2_OFFER_OTHER_ACPT;
      }

      if NOT Send(self,@CheckOfferStuff)
      {
         return;
      }

      if IsClass(poOffer_who,&User)
         AND NOT Send(poOffer_who,@CheckOfferStuff)
      {
         return;
      }

      Send(self,@OfferSubtractNumberItems);
      Send(poOffer_who,@OfferSubtractNumberItems);

      oHolder = Send(SYS,@GetSystemHolder1);
      foreach i in plOffer_items
      {
         Send(oHolder,@NewHold,#what=i);
      }

      Send(poOffer_who,@AcceptOffer);

      // take his stuff
      oHolder = Send(SYS,@GetSystemHolder2);
      iLists = 1;
      while iLists <= 2
      {
         if iLists = 1
         {
            lTake_items = Send(oHolder,@GetHolderActive);
         }
         if iLists = 2
         {
            lTake_items = Send(oHolder,@GetHolderPassive);
         }

         foreach i in lTake_items
         {
            if Send(self,@ReqNewHold,#what=i)
            {
               Send(self,@NewHold,#what=i);
            }
            else
            {
               if Send(poOwner,@ReqNewHold,#what=i,#new_row=piRow,
                       #new_col=piCol)
               {
                  // Send self warning
                  Send(poOwner,@NewHold,#what=i,#new_row=piRow,#new_col=piCol,
                       #fine_row=piFine_row,#fine_col=piFine_col);
               }
            }
         }

         ++iLists;
      }

      poOffer_who = $;
      plOffer_items = $;

      return;
   }

   AcceptOffer()
   {
      local i,oHolder,iLists,lTake_items;

      // drop the stuff

      oHolder = Send(SYS,@GetSystemHolder2);
      foreach i in plOffer_items
      {
         Send(oHolder,@NewHold,#what=i);
      }

      // take his stuff

      oHolder = Send(SYS,@GetSystemHolder1);
      iLists = 1;
      while iLists <= 2
      {
         if iLists = 1
         {
            lTake_items = Send(oHolder,@GetHolderActive);
         }

         if iLists = 2
         {
            lTake_items = Send(oHolder,@GetHolderPassive);
         }

         foreach i in lTake_items
         {
            if Send(self,@ReqNewHold,#what=i)
            {
               Send(self,@NewHold,#what=i);
            }
            else
            {
               if Send(poOwner,@ReqNewHold,#what=i,
                       #new_row=piRow,#new_col=piCol,
                       #fine_row=piFine_row,#fine_col=piFine_col)
               {
                  Send(self,@MsgSendUser,#message_rsc=user_cant_offer_get, 
                       #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));
                  Send(poOwner,@NewHold,#what=i,#new_row=piRow,#new_col=piCol,
                       #fine_row=piFine_row,#fine_col=piFine_col);
               }
            }
         }

         ++iLists;
      }

      poOffer_who = $;
      plOffer_items = $;

      // Send a "cancelled" to make dialog go away
      AddPacket(1,BP_OFFER_CANCELED);
      SendPacket(poSession);

      return TRUE;
   }

   UserGo(bCancel=FALSE)
   {
      local bCanGo;

      if NOT ((piFlags & PFLAG_NO_MOVE)
         OR Send(self,@IsEnchanted,#byClass=&Blind))
      {
         bCanGo = Send(poOwner,@SomethingTryGo,#what=self,#row=piRow,
            #col=piCol,#fine_row=piFine_row,#fine_col=piFine_col);

         if bCanGo = $
         {
            Debug("SomethingTryGo not properly set for room ",
               Send(poOwner,@GetTrueName));
         }
         else if bCanGo
         {
            return;
         }
      }

      if NOT bCancel
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_go);
         Send(self, @WaveSendUser, #what = self,
            #wave_rsc = user_cant_go_wav_rsc);
      }

      return;
   }

   UserRequestTriggerQuest(what = $, oQT = $)
   "Client sends NPC and quest template object and wants to trigger that quest "
   "for the given NPC. Need to find the appropriate quest node in that NPC's "
   "quest list and trigger it server-side."
   {
      local i, oQN, iType, oItem, oCargo, sCargo;

      oQN = Send(what,@GetActiveQuestForUser,#who=self,
               #index=Send(oQT,@GetQuestID));
      if (oQN = $)
      {
         Debug("User ",vrName," got $ oQN for index ",Send(oQT,@GetQuestID),
            " from NPC ",Send(what,@GetName));

         return;
      }

      // No point checking here? CheckCompletionCriteria should do this.
      /*if (NOT Send(oQN,@CanPlayerStartQuest,#who=self))
      {
         // TODO: in production, give user a message.
         Debug("User tried to start a quest they weren't qualified for!");

         return;
      }*/

      iType = Send(Send(SYS,@GetQuestEngine),@GetQuestNodeType,
                  #index=Send(oQN,@GetQuestNodeTemplateIndex));

      switch(iType)
      {
      case QN_TYPE_MESSAGE:
      case QN_TYPE_CHESSMOVE:
      case QN_TYPE_USERNAME:
      case QN_TYPE_LOGGEDONNAME:
         // Make user say the message in cargo.
         oCargo = Send(oQN,@GetCargo);
         ClearTempString();
         AppendTempString(oCargo);
         // Echo only to user, not to room/NPC.
         Send(self,@SomeoneSaid,#what=self,#type=SAY_NORMAL,
               #string=GetTempString());
         // Use the cargo directly - this bypasses any puzzle the user needs
         // to figure out to complete the quest, but we'd have to exclude that
         // type of quest from being completed via UI anyway (i.e. add a new
         // quest type for it and not use QN_TYPE_MESSAGE).
         Send(oQN,@CheckCompletionCriteria,#who_tried=self,#message=oCargo);
         break;
      case QN_TYPE_ITEM:
         // Cargo is the same object the user is carrying.
         oCargo = Send(oQN,@GetCargo);
         if (Send(self,@IsHolding,#what=oCargo))
         {
            Send(what,@TryGiveQuestItem,#what=self,#item_list=[oCargo]);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=user_no_quest_item);
         }
         break;
      case QN_TYPE_ITEMCLASS:
      case QN_TYPE_ITEMFINDCLASS:
      case QN_TYPE_MONSTER_ITEMCLASS:
         // Give item to NPC, favor last items in inventory.
         // Cargo is a duplicate of the item to give.
         oCargo = Send(oQN,@GetCargo);
         oItem = Send(self,@FindHoldingAP,#class=GetClass(oCargo),#sequence=1);
         if (oItem <> $)
         {
            Send(what,@TryGiveQuestItem,#what=self,#item_list=[oItem]);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=user_no_quest_item);
         }
         break;
      case QN_TYPE_SHOWUP:
      case QN_TYPE_MONSTER:
      case QN_TYPE_MONSTER_BRING:
         // Just let NPC know we're here
         Send(oQN,@CheckCompletionCriteria,#who_tried=self);
         break;
      }

      return;
   }

   UserRequestNPCQuests(what = $)
   {
      local i, lQuests;

      AddPacket(1,BP_NPC_QUEST_LIST);

      Send(self,@ToCliObject,#what=what);

      lQuests = Send(what,@GetQuestsForUser,#who=self);

      AddPacket(2,Length(lQuests));

      foreach i in lQuests
      {
         Send(self,@ToCliObject,#what=First(i),#parm1=Nth(i,2));
         Send(First(i),@ShowQuestUIDesc,#who=self,#oNPC=what);
      }

      SendPacket(poSession);

      return;
   }

   UserBuy(what = $)
   {
      local i,lSaleItems;

      lSaleItems = Send(what,@GetForSale,#who=self);
      if lSaleItems = $
      {
         return;
      }

      AddPacket(1,BP_BUY_LIST);

      Send(self,@ToCliObject,#what=what);
      AddPacket(2,Length(lSaleItems));

      if Send(what,@MobIsVaultman)
      {
         foreach i in lSaleItems
         {
            Send(self,@ToCliObject,#what=i);
            AddPacket(4,Send(what,@GetVaultRetrievalFee,#what=i,#who=self));
         }
      }
      else
      {
         foreach i in lSaleItems
         {
            Send(self,@ToCliObject,#what=i);
            AddPacket(4,Send(what,@GetPrice,#what=i,#who=self));
         }
      }

      SendPacket(poSession);

      return;
   }

   UserWithdrawal(what = $)
   {
      local i,lSaleItems;

      lSaleItems = Send(what,@GetForSale,#who=self);
      if lSaleItems = $
      {
         return;
      }

      if Send(what,@MobIsVaultman)
      {
         AddPacket(1,BP_WITHDRAWAL_LIST);

         Send(self,@ToCliObject,#what=what);
         AddPacket(2,Length(lSaleItems));
         foreach i in lSaleItems
         {
            Send(self,@ToCliObject,#what=i);
            AddPacket(4,Send(what,@GetVaultRetrievalFee,#what=i,#who=self));
         }
      }

      SendPacket(poSession);

      return;
   }

   SendBuyGuildHall()
   {
      local i,lHalls,iAvailable;

      if pbLogged_on
      {
         lHalls = Send(SYS,@GetGuildHalls);
         iAvailable = 0;
         foreach i in lHalls
         {
            if Send(i,@GetPurchaseValue,#who=self) <> -1
            {
               ++iAvailable;
            }
         }

         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_HALLS, 2,iAvailable);
         foreach i in lHalls
         {
            if Send(i,@GetPurchaseValue,#who=self) <> -1
            {
               AddPacket(4,i, 4,Send(i,@GetName),
                         4,Send(i,@GetPurchaseValue,#who=self),
                         4,24*Send(i,@GetRentValue));
            }
         }

         SendPacket(poSession);
      }

      return;
   }

   SendCreateGuild()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_ASK,
                   4,Send(SYS,@GetGuildPrice),
                   4,Send(SYS,@GetGuildSecretPrice));
         SendPacket(poSession);
      }

      return;
   }

   UserBuyItems(what = $,item_list = $,number_list = $)
   {
      local i;

      // Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad buy quantity", i, "from user", self);
            return;
         }
      }

      Send(what,@Buy,#what=self,#item_list=item_list,#number_list=number_list);

      return;
   }

   UserWithdrawalItems(what = $, item_list = $, number_list = $)
   {
      local i;

      // Check quantities; must be positive
      foreach i in number_list
      {
        if i < 1
        {
           Debug("Bad withdrawl quantity", i, "from user", self);
           return;
        }
      }

      Send(what,@Buy,#what=self,#item_list=item_list,#number_list=number_list);

      return;
   }

   UserApply(what = $,apply_on = $)
   {
      if (piFlags & PFLAG_TRANCE)
      {
         Send(self,@BreakTrance,#event=EVENT_USE);
      }

      if NOT IsClass(what,&Item) 
      {
         return;
      }

      Send(self,@TryApplyItem,#what=what,#apply_on=apply_on);

      return;
   }

   UserPost(nid = $,title = $,body = $)
   {
      local oNews;

      // Can't post if squelched
      if piFlags2 & PFLAG2_SQUELCHED_POSTS
      {
         Send(self,@MsgSendUser,#message_rsc=user_news_squelched);

         return;
      }

      // There has to be SOME kind of length limit.
      if StringLength(body) > NEWS_POSTING_MAX_LENGTH
      {
         Send(self,@MsgSendUser,#message_rsc=user_news_toobig);

         return;
      }

      // Check subject length.
      if StringLength(title) > NEWS_POSTING_MAX_SUBJECT_LENGTH
      {
         Send(self,@MsgSendUser,#message_rsc=user_news_subject_toobig);

         return;
      }

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if oNews = $
      {
         Debug("Can't find newsgroup id",nid);

         return;
      }

      // Need to be in same room as news globe
      if (NOT Send(poOwner,@ContainsNewsID,#nid=Send(oNews,@GetNewsNum)))
      {
         Debug("Client request for posting news from another room, user = ",
               Send(self,@GetName));

         return;
      }

      if (piTimeNewsPosted + NEWS_POSTING_DELAY) > GetTime()
         AND NOT IsClass(self,&DM)
      {
         if piNumberOfNewsPosts >= NEWS_POSTING_LIMIT
         {
            Send(self,@MsgSendUser,#message_rsc=user_wait_for_news_Posting);

            return;
         }

         ++piNumberOfNewsPosts;
      }
      else
      {
         piTimeNewsPosted = GetTime();
         piNumberofNewsPosts = 1;
      }

      if (Send(oNews,@GetNewsPermission,#what=self) & NEWS_PERMISSION_WRITE)
      {
         Send(oNews,@PostNews,#what=self,#title=title,#body=body);
      }

      return;
   }

   UserGetNewsTitles(nid = $)
   {
      local oNews, lMessages, len, part, parts, count, max, article;

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if oNews = $
      {
         Debug("Can't find newsgroup id",nid);

         return;
      }

      // Need to be in same room as news globe
      if (NOT Send(poOwner,@ContainsNewsID,#nid=Send(oNews,@GetNewsNum)))
      {
         Debug("Client request for reading news from another room, user = ",
               Send(self,@GetName));
         return;
      }

      lMessages = Send(oNews,@GetArticleList);
      len = Length(lMessages);
      parts = (len - 1) / MAX_ARTICLES_PER_PART + 1;
      max = MAX_ARTICLES_PER_PART;

      for (part = 1; part <= parts; ++part)
      {
         // Figure out how many articles are in this part of the message
         if part = parts
         {
            max = len - (parts - 1) * MAX_ARTICLES_PER_PART;
         }

         AddPacket(1,BP_ARTICLES, 2,nid, 1,part, 1,parts, 2,max);

         for (count = 0; count < max; ++count)
         {
            // Article is of form: [ message number, time, Poster, title ]
            article = First(lMessages);
            AddPacket(4,First(article),
                      //4,Nth(article,NEWS_ARTICLE_SHORT_TIME), // int
                      STRING_AS_INTEGER,Nth(article,NEWS_ARTICLE_LONG_TIME), // string
                      STRING_RESOURCE,Send(Nth(article,NEWS_ARTICLE_POSTER),@GetTrueName),
                      0,Nth(article,NEWS_ARTICLE_TITLE)); // string
            lMessages = Rest(lMessages);
         }

         SendPacket(poSession);
      }

      return;
   }

   UserGetNewsArticle(nid = $,num = $)
   {
      local oNews,sBody;

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if oNews = $
      {
         Debug("Can't find newsgroup id",nid);

         return;
      }

      // Need to be in same room as news globe
      if (NOT Send(poOwner, @ContainsNewsID, #nid = Send(oNews, @GetNewsNum)))
      {
         Debug("Client request for reading news from another room, user = ",
               Send(self,@GetName));
         return;
      }

      sBody = Send(oNews,@GetNewsBody,#num=num);
      if sBody = $
      {
         Debug("Client request for nonexistent news article",
               Send(oNews,@GetName),num);
         
         return;
      }

      AddPacket(1,BP_ARTICLE, 0,sBody);
      SendPacket(poSession);

      return;
   }

   NewHold(what = $, bFromReagentBag = FALSE, check_combine = TRUE)
   {
      local i, oLastSpellItem;

      if what = $
         OR what = self
      {
         Debug(Send(self,@GetTrueName),self," got newhold of ",what,
               ". Owner is ",Send(poOwner,@GetName));

         return;
      }

      if IsClass(what,&Reagent)
         AND NOT bFromReagentBag
         AND Send(self,@GetReagentBag) <> $
         AND (piPreferences & CF_REAGENTBAG)
      {
         Post(Send(self,@GetReagentBag),@NewHold,#what=what,
               #where=Send(self,@GetReagentBag));

         return;
      }

      if IsClass(what,&SpellItem)
         AND (piPreferences & CF_AUTOCOMBINE)
         AND check_combine
      {
         foreach i in plPassive
         {
            if GetClass(i) = GetClass(what)
               AND i <> what
            {
               oLastSpellItem = i;
            }
         }

         if oLastSpellItem <> $
         {
            Post(oLastSpellItem,@CombineSpellItems,#what=what);
         }
      }

      propagate;
   }

   NewHoldObject(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_INVENTORY_ADD);
         Send(self,@ToCliObject,#what=what,#show_type=SHOW_INVENTORY);
         SendPacket(poSession);

         Post(self,@DrawCapacity);
         Post(self,@DrawBulk);
      }

      propagate;
   }

   LeaveHold(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_INVENTORY_REMOVE,4,what);
         SendPacket(poSession);
         Post(self,@DrawCapacity);
         Post(self,@DrawBulk);
      }

      propagate;
   }

   NewOwner(what = $)
   "A user has a new owner when they enter a new room."
   {
      local i, oOldRoom, iNewRoomNum;

      Send(self,@CancelIfOffer);

      if (what <> $)
      {
         iNewRoomNum = Send(what,@GetRoomNum);
      }

      // Count right now as the last time we moved.
      piLastMoveUpdateTime = GetTickCount();

      // This is here because it has to be done before poOwner is changed.

      // If newbie is entering a kill zone, warn him.  If he is leaving
      // one, then tell him he's safe again.  Ignore during chaos night.

      if NOT Send(SYS,@GetChaosNight)
         AND (NOT (piFlags & PFLAG_PKILL_ENABLE)
            OR piFlags & PFLAG_PERMA_NO_PVP)
      {
         if Send(what,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
         {
            if (poOwner = $
               OR NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_KILL_ZONE))
            {
               Send(self,@MsgSendUser,#message_rsc=user_kill_zone);
            }
         }
         else if (poOwner <> $
            AND Send(poOwner,@CheckRoomFlag,#flag=ROOM_KILL_ZONE))
         {
            Send(self,@MsgSendUser,#message_rsc=user_angel_rejoins);
         }
      }

      // This is stuff that would be executed on propagation, but we gotta
      // execute this stuff before Sending new info to client

      if iNewRoomNum = RID_UNDERWORLD
         AND (piflags & PFLAG_DEATH_RIFTING)
      {
         // Deliverance people who somehow got to the Underworld
         // already protected. Usually it's because they logged off
         // in the Underworld while Death Rifting.
         Post(self,@AdminGoToSafety);
      }

      if poOwner <> $
      {
        oOldRoom = poOwner;
        Send(poOwner,@LeaveHold,#what=self);
      }

      poOwner = what;

      if poOwner <> $
      {
         if oOldRoom <> $
         {
            Send(self,@CheckTokenInNewRoom,#what=oOldRoom);
         }

         // If room is no combat and safe logoff, record it as the
         // player's last safe location
         if Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
         {
            if Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            {
               piLastSafeRoom = iNewRoomNum;

               // Recharge user's rods.
               if (Send(SETTINGS_OBJECT,@CanInnsRechargeRods))
               {
                  Send(self,@RechargeAllRods);
               }
            }

            // If this player has created any evil twins, delete them.
            Send(self,@RemoveAllCreatedEvilTwins);
         }

         piRow = First(Send(poOwner,@GetRoomPos,#what=self));
         piCol = Nth(Send(poOwner,@GetRoomPos,#what=self),2);

         if pbLogged_on
         {
            Send(self,@ToCliPlayer);
            Send(self,@ToCliRoomContents);
         }
      }

      // This is intended to protect players from wall spells stacked on
      // entrances. It will clear out a small space when they enter the zone,
      // so that they don't appear in the middle of a wall spell.
      if oOldRoom <> $
         AND (piFlags & PFLAG_PKILL_ENABLE)
         AND Send(SETTINGS_OBJECT,@ShouldDeleteWallsOnPlayerEntry)
         AND Send(poOwner,@AllowGuildAttack,#what=self)
         AND NOT IsClass(self,&DM)
      {
         Send(poOwner,@DeleteWallsAroundBattler,#who=self);
      }

      // This removes Death Rift's protection when the user enters any
      // non-Underworld room. Does the same for death arena killed flag.
      if iNewRoomNum <> RID_UNDERWORLD
      {
         if (piflags & PFLAG_DEATH_RIFTING)
         {
            Send(self,@SetDeathRiftProtection,#value=FALSE);
            if (NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF))
            {
               piLastSafeRoom = Send(self,@GetHomeRoom);
            }
         }
         else if (piFlags2 & PFLAG2_DARENA_DEATH)
         {
            piFlags2 &= ~PFLAG2_DARENA_DEATH;
            // Closest safe room to Arena.
            if (NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF))
            {
               piLastSafeRoom = RID_TOS_HALL;
            }
         }
      }

      // Draw defense to handle buffs that change
      // based on room (e.g. shadow form).
      Send(self,@DrawDefense);

      propagate;
   }

   SomethingEntered(what = $)
   {
      local lPos;

      lPos = Send(what,@GetPos);

      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         AddPacket(1,BP_CREATE);
         Send(self,@ToCliObject,#what=what);
         AddPacket(2,First(lPos)*FINENESS+Nth(lPos,3),
                   2,Nth(lPos,2)*FINENESS+Nth(lPos,4),
                   2,Send(what,@GetAngle));
         Send(what,@SendMoveAnimation);
         Send(what,@SendMoveOverlays);
         SendPacket(poSession);
      }

      propagate;
   }

   SomethingLeft(what = $)
   {
      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         AddPacket(1,BP_REMOVE,4,what);
         SendPacket(poSession);
      }

      propagate;
   }

   SomethingPhasedOut(what = $, iHealth = 0, iMaxHealth = 0)
   {
      local oToken;

      if (what = self)
      {
         oToken = Send(self,@FindHolding,#class=&Token);

         if (oToken <> $)
         {
            Send(oToken,@UserPhased,#where=poOwner);
         }

         Send(self,@RemoveAllMinions);

         // Evil twin attacking us.
         if (poEvilTwin <> $)
         {
            Send(poEvilTwin,@OriginalPhased);
         }

         // Delete evil twins we created.
         Send(self,@RemoveAllCreatedEvilTwins);

         Send(self,@MsgSendUser,#message_rsc=user_self_phase_out,
               #parm1=(Send(self,@GetRemainingPhaseTime)/1000));
      }
      else if iHealth <= 1
      {
         Send(self,@MsgSendUser,#message_rsc=user_phase_out_onehp,
               #parm1=Send(what,@GetName));
      }
      else if iHealth < iMaxHealth / 3
      {
         Send(self,@MsgSendUser,#message_rsc=user_phase_out_low,
               #parm1=Send(what,@GetName));
      }
      else if iHealth = iMaxHealth
      {
         Send(self,@MsgSendUser,#message_rsc=user_phase_out_high,
               #parm1=Send(what,@GetName));
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_phase_out_med,
               #parm1=Send(what,@GetName));
      }

      propagate;
   }

   SomethingPhasedIn(what = $,bTeleport=FALSE)
   {
      if (what = self)
      {
         // Phase our evil twin back in, if we have one.
         if (poEvilTwin <> $)
         {
            Send(poEvilTwin,@OriginalUnphased,#who=self);
         }

         Send(self,@MsgSendUser,#message_rsc=user_self_phase_in,
               #parm1=(Send(self,@GetRemainingPhaseTime)/1000));
      }
      // Don't send the 'phase in' message if the user teleported.
      // Phase sends a different message in that case.
      else if (NOT bTeleport)
      {
         Send(self,@MsgSendUser,#message_rsc=user_phase_in,
               #parm1=Send(what,@GetName));
      }

      propagate;
   }

   SomethingSpectatedOut(what = $)
   {
      local oToken;

      if (what = self)
      {
         oToken = Send(self,@FindHolding,#class=&Token);

         if (oToken <> $)
         {
            Send(oToken,@UserPhased,#where=poOwner);
         }

         Send(self,@RemoveAllMinions);

         // Evil twin goes to limbo, to await our return.
         if poEvilTwin <> $
         {
            Send(poEvilTwin,@SomethingLeft,#what=self);
         }

         // Delete evil twins we created.
         Send(self,@RemoveAllCreatedEvilTwins);

         Send(self,@MsgSendUser,#message_rsc=user_self_spectate_on);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_spectate_on,
               #parm1=Send(what,@GetTrueName));
      }

      propagate;
   }

   SomethingSpectatedIn(what = $)
   {
      if (what = self)
      {
         // Return our evil twin if we have one.
         if (poEvilTwin <> $)
         {
            Send(poEvilTwin,@PlaceEvilTwin,#who=self);
         }

         Send(self,@MsgSendUser,#message_rsc=user_self_spectate_off);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_spectate_off,
               #parm1=Send(what,@GetTrueName));
      }

      propagate;
   }

   SomethingMoved(what=$, new_row=$, new_col=$, fine_row = $, fine_col = $,
                  cause = $, speed = 0)
   {
      local iRow,iCol,lPos;

      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         if what <> self OR cause <> CAUSE_USER_INPUT
         {
            AddPacket(1,BP_MOVE, 4,what,
                      2,new_row*FINENESS+fine_row, 2,new_col*FINENESS+fine_col,
                      1,speed,2,Send(what, @GetAngle));
            SendPacket(poSession);

            propagate;
         }
      }

      propagate;
   }

   BuildPacketSomethingMoved(what=$,new_row=$,new_col=$,fine_row = $,
                             fine_col = $,cause = $,speed = 0)
   {
      AddPacket(1,BP_MOVE, 4,what,
                2,new_row*FINENESS+fine_row, 2,new_col*FINENESS+fine_col,
                1,speed,2,Send(what, @GetAngle));

      return;
   }

   SomethingTurned(what = $,new_angle = 0,cause = $)
   {
      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         // Need to set new angle of object somewhere
         if (what <> self or cause <> CAUSE_USER_INPUT)
         {
            AddPacket(1,BP_TURN,4,what,2,new_angle);
            SendPacket(poSession);
         }
      }

      propagate;
   }

   BuildPacketSomethingTurned(what = $,new_angle = 0)
   {
      AddPacket(1,BP_TURN,4,what,2,new_angle);

      return;
   }

   SomethingShot(who=$, target=$, projectile=$, flags=PROJ_FLAG_NONE,
                 iLightIntensity=0, iLightColor=0)
   {
      local iValue;

      // This happened in the past.  Ignore this, because Sending nil in a
      //  packet is bad.
      if target = $
      {
         propagate;
      }

      AddPacket(1,BP_SHOOT,4,Send(projectile,@GetProjectileIcon));
      Send(projectile,@SendProjectileAnimation);

      // Send shooter and target.
      AddPacket(4,who, 4,target, 1,Send(projectile,@GetProjectileSpeed),
                2,(flags & 0x000F));

      if (flags & PROJ_FLAG_LIGHT_SOURCE)
      {
         // Lighting flags
         iValue = Send(projectile,@GetProjectileLightFlags);
         // Double-check for sanity
         if iValue <> LIGHT_FLAG_NONE
         {
            // Make sure projectiles are on and have the dynamic flag set.
            iValue = iValue | LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
            // Flags, Intensity, color
            AddPacket(2,iValue, 1,Send(projectile,@GetProjectileLightIntensity),
                      2,Send(projectile,@GetProjectileLightColor));
         }
         else
         {
            // No lighting info
            AddPacket(2,0);
         }
      }
      else
      {
         // No lighting info
         AddPacket(2,0);
      }

      SendPacket(poSession);

      propagate;
   }

   SomethingShotRadius(who=$,projectile=$,flags=PROJ_FLAG_NONE,
                 iLightIntensity=0,iLightColor=0,range=0,number=0,speed=0)
   {
      local iCount, iValue, iAngle;

      AddPacket(1,BP_RADIUS_SHOOT,4,Send(projectile,@GetProjectileIcon));
      Send(projectile,@SendProjectileAnimation);

      // Send shooter.
      AddPacket(4,who,1,speed,2,(flags & 0x000F),1,range,1,number);

      if (flags & PROJ_FLAG_LIGHT_SOURCE)
      {
         // Lighting flags
         iValue = Send(projectile,@GetProjectileLightFlags);
         // Double-check for sanity
         if iValue <> LIGHT_FLAG_NONE
         {
            // Make sure projectiles are on and have the dynamic flag set.
            iValue = iValue | LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
            // Flags, Intensity, color
            AddPacket(2,iValue,1,iLightIntensity,2,iLightColor);
         }
         else
         {
            // No lighting info
            AddPacket(2,0);
         }
      }
      else
      {
         // No lighting info
         AddPacket(2,0);
      }

      SendPacket(poSession);

      propagate;
   }

   SomethingDidAction(what = $, action = $)
   {
      // Someone changed facial expression--Send changed bitmap
      Send(self,@SomethingChanged,#what=what);

      return;
   }

   AddForcedIgnore(what = $, bReciprocal = FALSE)
   "Adds 'what' to this user's forced ignore list. Reciprocally adds this "
   "user to 'what's forced ignore list.  Last resort for players that lose "
   "all sense once they start arguing with each other."
   {
      if (what = $)
      {
         return FALSE;
      }

      if (GetClass(what) <> &User)
      {
         return FALSE;
      }

      if (FindListElem(plForcedIgnore,what))
      {
         return FALSE;
      }

      plForcedIgnore = Cons(what, plForcedIgnore);

      if (NOT bReciprocal)
      {
         Send(what,@AddForcedIgnore,#what=self,#bReciprocal=TRUE);
      }

      return TRUE;
   }

   CheckForcedIgnore(what = $)
   "Returns TRUE if users are ignoring each other, FALSE otherwise."
   {
      return FindListElem(plForcedIgnore,what);
   }

   RemoveForcedIgnore(what = $, bReciprocal = FALSE)
   "Tries to remove 'what' from our list, and us from 'what's list."
   {
      local bRemoved;

      if (FindListElem(plForcedIgnore,what))
      {
         bRemoved = TRUE;
         plForcedIgnore = DelListElem(plForcedIgnore, what);
      }
      else
      {
         bRemoved = FALSE;
      }

      if (NOT bReciprocal)
      {
         Send(what,@RemoveForcedIgnore,#bReciprocal=TRUE);
      }

      return bRemoved;
   }

   ListForcedIgnore()
   "Adds the names of all in the list to the temp string, sets it to a normal "
   "string and returns it. Returns $ for empty, or if the list is over 25 names."
   {
      local sNames, i, iCount;

      if (Length(plForcedIgnore) > 25)
      {
         Debug("Checking forced ignore list for ",vrName," with over 25 names!");

         return;
      }

      ClearTempString();

      iCount = 0;

      foreach i in plForcedIgnore
      {
         if (iCount++)
         {
            AppendTempString(", ");
         }
         AppendTempString(Send(i,@GetTrueName));
      }

      if (iCount > 0)
      {
         return SetString($, GetTempString());
      }

      return;
   }

   ResetForcedIgnore(bReciprocal=FALSE)
   "Clears this user's forced ignore, and tells all users on it to remove us."
   {
      local i;

      foreach i in plForcedIgnore
      {
         Send(i,@RemoveForcedIgnore,#what=self,#bReciprocal=TRUE);
      }

      plForcedIgnore = $;

      return;
   }

   SomeoneSaid(what = $, type = $, string = $, parm1 = $, parm2 = $, parm3 = $,
               parm4= $, parm5 = $, parm6 = $, parm7 = $, parm8 = $)
   {
      local rSay_format,rName;

      if pbLogged_on
      {
         // if it's a say resource, it's from a monster or object probably.
         // otherwise, string is the tempstring.

         // Don't echo DM commands to the users.
         if type = SAY_DM
         {
            return;
         }

         // If we need a name for this say, and they're anonymous or disguised,
         //  don't look stupid.
         if what <> $
         {
            rName = Send(what,@GetName,#cap=TRUE);

            // Block players we are forced to ignore.
            if (IsClass(what,&User)
               AND FindListElem(plForcedIgnore,what))
            {
               return;
            }
         }

         if type = SAY_RESOURCE
         {
            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type,
                      4,user_said_resource_str,
                      4,Send(what,@GetCapDef), 4,rName, 4,string);

            // allow SAY_RESOURCE says to have parameters
            if parm1 <> $
            {
               AddPacket(4,parm1);
            }
            if parm2 <> $
            {
               AddPacket(4,parm2);
            }
            if parm3 <> $
            {
               AddPacket(4,parm3);
            }
            if parm4 <> $
            {
               AddPacket(4,parm4);
            }
            if parm5 <> $
            {
               AddPacket(4,parm5);
            }
            if parm6 <> $
            {
               AddPacket(4,parm6);
            }
            if parm7 <> $
            {
               AddPacket(4,parm7);
            }
            if parm8 <> $
            {
               AddPacket(4,parm8);
            }

            SendPacket(poSession);

            propagate;
         }

         if type = SAY_MESSAGE
         {
            AddPacket(1,BP_MESSAGE,4,string);
            if parm1 <> $
            {
               AddPacket(4,parm1);
            }
            if parm2 <> $
            {
               AddPacket(4,parm2);
            }
            if parm3 <> $
            {
               AddPacket(4,parm3);
            }
            if parm4 <> $
            {
               AddPacket(4,parm4);
            }
            if parm5 <> $
            {
               AddPacket(4,parm5);
            }
            if parm6 <> $
            {
               AddPacket(4,parm6);
            }
            if parm7 <> $
            {
               AddPacket(4,parm7);
            }
            if parm8 <> $
            {
               AddPacket(4,parm8);
            }

            SendPacket(poSession);

            propagate;
         }

         rSay_format = user_said_str;
         if what = self
         {
            rSay_format = user_said_echo_str;
         }

         if type = SAY_YELL
         {
            rSay_format = user_yelled_str;
            if what <> $ AND Send(what,@GetOwner) <> poOwner
            {
               rSay_format = user_yelled_nearby_str;
            }

            if what = self
            {
               rSay_format = user_yelled_echo_str;
            }
         }
         else if type = SAY_EVERYONE
         {
            // If a hidden admin is talking to us, use the GetName() above.
            //  This will give us a valid resource; we won't have the proper
            //  name in our name list.  Other admins are an exception.
            if (IsClass(what,&DM)
                AND NOT Send(what,@IsHidden))
               OR IsClass(self,&Admin)
            {
               rName = Send(what,@GetTrueName);
            }

            if what <> self
            {
               rSay_format = user_broadcast_str;
            }
            else
            {
               rSay_format = user_broadcast_echo_str;
            }
         }
         else if type = SAY_GROUP
         {
            // If a hidden admin is talking to us, use the GetName() above.
            //  This will give us a valid resource; we won't have the proper
            //  name in our name list.  Other admins are an exception.
            if (IsClass(what,&DM)
                AND NOT Send(what,@IsHidden))
               OR IsClass(self,&Admin)
            {
               rName = Send(what,@GetTrueName);
            }

            rSay_format = user_send_str;
         }
         else if type = SAY_GROUP_ONE
         {
            if (IsClass(what,&DM)
                AND NOT Send(what,@IsHidden))
               OR IsClass(self,&Admin)
            {
               rName = Send(what,@GetTrueName);
            }

            rSay_format = user_send_one_str;

            // this is what the client is expecting to hear
            type = SAY_GROUP;
         }
         else if type = SAY_EMOTE
         {
            rSay_format = user_emote_str;
         }

         if Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
            AND (rSay_format = user_said_str
                 OR rSay_format = user_yelled_str
                 OR rSay_format = user_emote_str)
         {
            if rSay_format = user_said_str
            {
               rSay_format = user_said_str_morphed;
            }
            else if rSay_format = user_yelled_str
            {
               rSay_format = user_yelled_str_morphed;
            }
            else if rSay_format = user_emote_str
            {
               rSay_format = user_emote_str_morphed;
            }

            

            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type, 4,rSay_format,
                      4,Send(what,@GetCapIndef), 4,rName, 0,string);

            SendPacket(poSession);

            propagate;
         }

         if what = self AND type <> SAY_EMOTE
            AND type <> SAY_GROUP AND type <> SAY_GROUP_ONE
         {
            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type, 4,rSay_format,
                      0,string);
         }
         else
         {
            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type, 4,rSay_format,
                      4,rName, 0,string);
         }

         SendPacket(poSession);
      }

      propagate;
   }

   SomethingChangedFlags(what = $)
   "Like SomethingChanged(), but only object ID and flags get sent."
   {
      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE_FLAGS, 4,what);

         Send(self,@ToCliFlags,#what=what);

         SendPacket(poSession);
      }

      propagate;
   }

   SomethingChanged(what = $)
   {
      local rName, rIcon;

      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if what = self
         AND (piFlags2 & PFLAG2_DANCING)
      {
         Send(self,@StopDancing);
      }

      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE);
         if Send(what,@GetOwner) = self
         {
            // if in inventory
            Send(self,@ToCliObject,#what=what,#show_type=SHOW_INVENTORY);
            Post(self,@DrawCapacity);
            Post(self,@DrawBulk);
         }
         else
         {
            // in the room
            Send(self,@ToCliObject,#what=what);
         }

         Send(what,@SendMoveAnimation);
         Send(what,@SendMoveOverlays);

         SendPacket(poSession);
      }

      propagate;
   }

   NewUsing(what = $)
   {
      local rName,rIcon;

      if pbLogged_on
      {
         AddPacket(1,BP_USE,4,what);
         SendPacket(poSession);

         if IsClass(what,&Weapon)
         {
            Post(self,@DrawOffense);
         }
      }

      return;
   }

   NewUnusing(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_UNUSE,4,what);
         SendPacket(poSession);

         if IsClass(what,&Weapon)
         {
            Post(self,@DrawOffense);
         }
      }

      return;
   }

   ReceiveMail(from = $,dest_list = $,perm_string = $)
   "<from> is a resource."
   {
      if dest_list = $
      {
         dest_list = [self];
      }

      plNew_mail = Cons([from,GetTime(),GetUnixTimeString(),dest_list,[perm_string]],
                        plNew_mail);

      Send(self,@MsgSendUser,#message_rsc=user_new_mail,#parm1=from);

      return;
   }

   ReceiveNestedMail(from = $,dest_list = $,nest_list = $)
   "<from> is a resource."
   {
      if dest_list = $
      {
         dest_list = [self];
      }

      plNew_mail = Cons([from,GetTime(),GetUnixTimeString(),dest_list,nest_list],
                        plNew_mail);

      Send(self,@MsgSendUser,#message_rsc=user_new_nested_mail);

      return;
   }

   DrawHealth()
   {
      if pbLogged_on
      AND (First(plDraw)/100 - piHealth/100 OR Nth(plDraw,2) - piMax_health)
      {
         AddPacket(1,BP_STAT,1,1);
         Send(self,@SendStatHealth);
         SendPacket(poSession);
         SetFirst(plDraw,piHealth);
         SetNth(plDraw,2,piMax_health);
      }

      return;
   }

   SendStatHealth()
   {
      AddPacket(1,1, 4,user_stat_health, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetHealth), 4,0, 4,100, 4,piMax_health);

      return;
   }

   DrawMana()
   {
      if pbLogged_on
      AND (Nth(plDraw,3)/100 - piMana/100 OR Nth(plDraw,4) - piMax_mana)
      {
         AddPacket(1,BP_STAT,1,1);
         Send(self,@SendStatMana);
         SendPacket(poSession);
         SetNth(plDraw,3,piMana);
         SetNth(plDraw,4,piMax_mana);
      }

      return;
   }

   SendStatMana()
   {
      AddPacket(1,2, 4,user_stat_mana, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetMana), 4,0, 4,100, 4,piMax_mana);

      return;
   }

   DrawVigor()
   {
      if pbLogged_on
      AND (Nth(plDraw,5)/100 - piVigor/100 OR Nth(plDraw,6) - piMax_vigor)
      {
         AddPacket(1,BP_STAT, 1,1);
         Send(self,@SendStatVigor);
         SendPacket(poSession);
         SetNth(plDraw,5,piVigor);
         SetNth(plDraw,6,piMax_vigor);
      }

      return;
   }

   SendStatVigor()
   {
      AddPacket(1,3,4,user_stat_vigor,1,STAT_VALUE,1,STAT_INTEGER,
         4,Send(self,@GetVigor),4,0,4,200,4,Send(self,@GetVigorRestThreshold,#base=FALSE));

      return;
   }

   DrawMight()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatMight);
         SendPacket(poSession);
      }

      return;
   }

   SendStatMight()
   {
      AddPacket(1,1, 4,user_stat_might, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetMight), 4,0, 4,50, 4,Send(self,@GetMight));

      return;
   }

   DrawIntellect()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatIntellect);
         SendPacket(poSession);
      }

      return;
   }

   SendStatIntellect()
   {
      AddPacket(1,2, 4,user_stat_intellect, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetIntellect), 4,0, 4,50,
                4,Send(self,@GetIntellect));

      return;
   }

   DrawAgility()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatAgility);
         SendPacket(poSession);
      }

      return;
   }

   SendStatAgility()
   {
      AddPacket(1,4, 4,user_stat_Agility, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetAgility), 4,0, 4,50, 4,Send(self,@GetAgility));

      return;
   }

   DrawStamina()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatStamina);
         SendPacket(poSession);
      }

      return;
   }

   SendStatStamina()
   {
      AddPacket(1,3,4,user_stat_Stamina,1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetStamina), 4,0, 4,50, 4,Send(self,@GetStamina));

      return;
   }

   DrawMysticism()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatMysticism);
         SendPacket(poSession);
      }

      return;
   }

   SendStatMysticism()
   {
      AddPacket(1,5,4,user_stat_Mysticism,1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetMysticism), 4,0, 4,50,
                4,Send(self,@GetMysticism));

      return;
   }

   DrawAim()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatAim);
         SendPacket(poSession);
      }

      return;
   }

   SendStatAim()
   {
      AddPacket(1,6, 4,user_stat_Aim, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetAim), 4,0, 4,50, 4,Send(self,@GetAim));

      return;
   }

   DrawKarma()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatKarma);
         SendPacket(poSession);
      }

      return;
   }

   SendStatKarma()
   {
      local iKarma_send;

      // internally we have karma in 1/100's of a point, -10000 to 10000.
      // scale to -100 to 100
      iKarma_send = piKarma/100;

      AddPacket(1,7, 4,user_stat_karma, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iKarma_Send, 4,-100, 4,100, 4,iKarma_Send);

      return;
   }

   DrawTraining()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatTraining);
         SendPacket(poSession);
      }

      return;
   }

   SendStatTraining()
   {
      local iTraining_send;

      iTraining_send = Send(self,@GetTrainingPoints);

      AddPacket(1,8, 4,user_stat_training, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iTraining_send, 4,0, 4,1000, 4,iTraining_send);

      return;
   }

   DrawCapacity()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatCapacity);
         SendPacket(poSession);
      }

      return;
   }

   SendStatCapacity()
   {
      local iCapacity_send;

      iCapacity_send = Send(self,@GetWeightHold);

      AddPacket(1,9, 4,user_stat_capacity, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iCapacity_send, 4,0, 4,Send(self,@GetWeightMax),
                4,iCapacity_send);

      return;
   }
   
   DrawBulk()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatBulk);
         SendPacket(poSession);
      }

      return;
   }
   
   SendStatBulk()
   {
      local iBulk;

      iBulk = Send(self,@GetBulkHold);

      AddPacket(1,10, 4,user_stat_bulk, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iBulk, 4,0, 4,Send(self,@GetBulkMax), 4,iBulk);

      return;
   }

   DrawOffense()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatOffense);
         SendPacket(poSession);
      }

      return;
   }

   SendStatOffense()
   {
      local iOffense_send;

      iOffense_send = Send(self,@GetOffense);

      AddPacket(1,11, 4,user_stat_offense, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iOffense_send, 4,0, 4,1000, 4,iOffense_send);

      return;
   }

   DrawDefense()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatDefense);
         SendPacket(poSession);
      }

      return;
   }

   SendStatDefense()
   {
      local iDefense_send;

      iDefense_send = Send(self,@GetDefense);

      AddPacket(1,12, 4,user_stat_defense, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iDefense_send, 4,0, 4,1000, 4,iDefense_send);

      return;
   }
   
   DrawArmor()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatArmor);
         SendPacket(poSession);
      }

      return;
   }

   SendStatArmor()
   {
      local iArmor_send;

      iArmor_send = Send(self,@SumDamageReduction);

      AddPacket(1,13, 4,user_stat_armor, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iArmor_send, 4,0, 4,15, 4,iArmor_send);

      return;
   }

   SendStatResistances(num=1,lCurrentResistances=$)
   {
      local lRes;

      if num = 1
      {
         lRes = GetListNode(lCurrentResistances, 1, ATK_TYPE_ALL);
         if (lRes <> $)
         {
            AddPacket(1,14, 4,user_resist_weapons, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,14, 4,user_resist_weapons, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 2
      {
         lRes = GetListNode(lCurrentResistances, 1, ATK_TYPE_THRUST);
         if (lRes <> $)
         {
            AddPacket(1,15, 4,user_resist_thrust, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,15, 4,user_resist_thrust, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 3
      {
         lRes = GetListNode(lCurrentResistances, 1, ATK_TYPE_BLUDGEON);
         if (lRes <> $)
         {
            AddPacket(1,16, 4,user_resist_bludgeon, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,16, 4,user_resist_bludgeon, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 4
      {
         lRes = GetListNode(lCurrentResistances, 1, ATK_TYPE_SLASH);
         if (lRes <> $)
         {
            AddPacket(1,17, 4,user_resist_slash, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,17, 4,user_resist_slash, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 5
      {
         lRes = GetListNode(lCurrentResistances, 1, ATK_TYPE_PIERCE);
         if (lRes <> $)
         {
            AddPacket(1,18, 4,user_resist_pierce, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,18, 4,user_resist_pierce, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 6
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_ALL);
         if (lRes <> $)
         {
            AddPacket(1,19, 4,user_resist_magic, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,19, 4,user_resist_magic, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 7
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_FIRE);
         if (lRes <> $)
         {
            AddPacket(1,20, 4,user_resist_fire, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,20, 4,user_resist_fire, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 8
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_SHOCK);
         if (lRes <> $)
         {
            AddPacket(1,21, 4,user_resist_shock, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,21, 4,user_resist_shock, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 9
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_COLD);
         if (lRes <> $)
         {
            AddPacket(1,22, 4,user_resist_cold, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,22, 4,user_resist_cold, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 10
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_ACID);
         if (lRes <> $)
         {
            AddPacket(1,23, 4,user_resist_acid, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,23, 4,user_resist_acid, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 11
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_HOLY);
         if (lRes <> $)
         {
            AddPacket(1,24, 4,user_resist_holy, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,24, 4,user_resist_holy, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 12
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_UNHOLY);
         if (lRes <> $)
         {
            AddPacket(1,25, 4,user_resist_unholy, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,25, 4,user_resist_unholy, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 13
      {
         lRes = GetListNode(lCurrentResistances, 1, -SPL_TYPE_QUAKE);
         if (lRes <> $)
         {
            AddPacket(1,26, 4,user_resist_quake, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,Nth(lRes,2), 4,-30, 4,100, 4,0);
         }
         else
         {
            AddPacket(1,26, 4,user_resist_quake, 1,STAT_VALUE,
                      1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }

      return;
   }

   DrawResistances()
   {
      local i, lResists;

      if pbLogged_on
      {
         lResists = Send(self,@GetCurrentResistances);
         for (i = 1; i < 14; ++i)
         {
            AddPacket(1,BP_STAT,1,2);
            Send(self,@SendStatResistances,#num=i,#lCurrentResistances=lResists);
            SendPacket(poSession);
         }
      }

      return;
   }

   SendStatXP()
   {
      local iNextHP, iZero;

      // iZero is the minimum point on the bar
      iZero = Send(SYS,@GetXPForLevel,#iHP=piBase_Max_health);
      // iNextHP is the levelling point (max point on bar)
      iNextHP = Send(SYS,@GetXPForLevel,#iHP=piBase_Max_health + 1);

      // piXP_total is the property listing total xp since char birth
      AddPacket(1,4, 4,user_stat_xp, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,piXP_total - iZero, 4,0, 4,iNextHP - iZero, 4,piXP_total);

      return;
   }

   DrawXP()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT, 1,1);
         Send(self,@SendStatXP);
         SendPacket(poSession);
      }

      return;
   }

   DrawUnboundEnergy()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatUnboundEnergy);
         SendPacket(poSession);
      }

      return;
   }

   SendStatUnboundEnergy()
   {
      local iPoints;

      iPoints = Send(self,@GetUnboundEnergy);

      AddPacket(1,27, 4,user_stat_unbound_energy, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iPoints, 4,0, 4,Send(SETTINGS_OBJECT,@GetUnboundMax), 4,iPoints);

      return;
   }

   DrawStatSpell(index = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,3);
         Send(self,@SendStatSpell,#index=index);
         SendPacket(poSession);
      }

      return;
   }

   SendStatSpell(index = $)
   {
      local compound,oSpell;

      compound = Nth(plSpells,index);

      oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                  #compound=compound));
      AddPacket(1,index, 4,Send(oSpell,@GetName), 1,STAT_LIST, 4,oSpell,
                4,Send(self,@DecodeSpellAbility,#compound=compound),
                4,Send(oSpell,@GetIcon));

      return;
   }

   DrawStatSkill(index = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,4);
         Send(self,@SendStatSkill,#index=index);
         SendPacket(poSession);
      }
      
      return;
   }

   SendStatSkill(index = $)
   {
      local compound,oSkill;

      compound = Nth(plSkills,index);

      oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                  #compound=compound));
      AddPacket(1,index, 4,Send(oSkill,@GetName), 1,STAT_LIST, 4,oSkill,
                4,Send(self,@DecodeSkillAbility,#compound=compound),
                4,Send(oSkill,@GetIcon));

      return;
   }

   Killed(what = $)
   {
      Send(self,@CancelIfOffer);

      if what = self
      {
         propagate;
      }

      if what <> $ AND IsClass(what,&TempleRiija)
      {
         Send(self,@MsgSendUser,#message_rsc=user_was_killed_bridge_faith);
         
         propagate;
      }

      if what <> $ AND IsClass(what,&Battler)
      {
         // Victim learns the real identity of a morphed/anonymous killer here.
         Send(self,@MsgSendUser,#message_rsc=user_was_killed,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetTrueName));

         propagate;
      }

      // any other causes of death get no special messages.

      propagate;
   }

   SourceLightChanged()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_LIGHT_PLAYER,1,Bound(piLight,0,255));
         SendPacket(poSession);
      }

      return;
   }

   AmbientLightChanged()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_LIGHT_AMBIENT, 1,Send(poOwner,@GetRoomLight));
         SendPacket(poSession);
      }

      return;
   }

   BackgroundChanged()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_BACKGROUND, 4,Send(poOwner,@GetRoomBackground));
         SendPacket(poSession);
      }

      return;
   }

   WeatherChanged()
   {
      local oSpell;

      if pbLogged_on
      {
         // First clear whichever effect we have.
         AddPacket(1,BP_EFFECT,2,EFFECT_CLEARWEATHER);
         SendPacket(poSession);

         // If we came from a room with a sandstorm weather effect we
         // clear it here, unless we're affected by the Sandstorm spell.
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_SANDSTORM);
         if (Send(poOwner,@GetEnchantedState,#what=oSpell) = $)
         {
            AddPacket(1,BP_EFFECT,2,EFFECT_CLEARSAND);
            SendPacket(poSession);
         }

         // Then send the needed effect.
         AddPacket(1,BP_EFFECT, 2,Send(poOwner,@GetRoomWeather));
         SendPacket(poSession);
      }

      return;
   }

   ShowAddEnchantment(what = $,type = $)
   {
      if pbLogged_on
      {
         if Send(what,@ShowEnchantmentIcon,#type=type)
         {
            AddPacket(1,BP_ADD_ENCHANTMENT, 1,type);
            Send(self,@ToCliObject,#what=what,#show_type=SHOW_ENCHANTMENT);
            SendPacket(poSession);
         }
      }

      return;
   }

   ShowRemoveEnchantment(what = $,type = $)
   {
      if pbLogged_on
      {
         if Send(what,@ShowEnchantmentIcon,#type=type)
         {
            AddPacket(1,BP_REMOVE_ENCHANTMENT, 1,type, 4,what);
            SendPacket(poSession);
         }
      }

      return;
   }

   SetInitialHomeroom()
   {
      // Get initial Homeroom from system settings.
      piHomeroom = Send(SETTINGS_OBJECT,@GetInitialRoomID);

      return;
   }

   SetRandomHomeroom()
   "This sets one of the many hometowns to be the initial hometown."
   {
      local rand;
      
      rand = Random(1,10);
      
      if rand < 4
      {
         piHomeroom = RID_MAR_INN;
      }
      else if rand > 7
      {
         piHomeroom = RID_JAS_INN;
      }
      else
      {
         piHomeroom = RID_COR_INN;
      }

      return;
   }

   SetHomeroom(RID = 0, lock = FALSE)
   {
      if NOT lock
      {
         piHomeroom = (rid);
      }
      else
      {
         piHomeroom = -(rid);
      }

      return;
   }

   CanChangeHomeroom()
   {
      return (piHomeRoom >= 0);
   }

   UnlockHomeroom()
   "Allows the user to change their homeroom (sets it positive)."
   {
      piHomeRoom = Abs(piHomeRoom);

      return;
   }

   GetHomeRoom()
   {
      // A negative homeroom means you can't change it in the hall of
      //  genealogy.
      if piHomeRoom = $
      {
         return $;
      }

      return Abs(piHomeRoom);
   }

   AdminGoToJail()
   "Admin supported.  "
   "Sends the user to the Barloque Jail, if they're logged in"
   {
      if pbLogged_on
      {
         Send(self,@TeleportTo,#RID=RID_BAR_JAIL);
         Send(self,@MsgSendUser,#message_rsc=user_goto_jail);
         return Send(SYS,@GetSuccessRsc);
      }

      return;
   }

   AdminGoToLastSafeRoom(from_special=FALSE)
   "Admin supported\n"
   "Sends the user to the last safe room they visited, whether they're logged in or not!\n"
   {
      local oCurrentRoom, iCurrentRegion, oLastSafeRoom, iLastSafeRegion, oTargetRoom;

      if piLastSafeRoom <> $
      {
         oLastSafeRoom = Send(SYS,@FindRoomByNum,#num=piLastSafeRoom);
         iLastSafeRegion = Send(oLastSafeRoom,@GetRegion);

         if pbLogged_on
         {
            oCurrentRoom = poOwner;
            iCurrentRegion = Send(oCurrentRoom,@GetRegion);

            if iCurrentRegion = iLastSafeRegion
               OR from_special
            {
               Send(oLastSafeRoom,@Teleport,#what=self);
               Send(self,@MsgSendUser,#message_rsc=user_goto_lastsaferoom);
            }
            else
            {
               // If the user is in a different region from their last
               // safe room, use region default homeroom instead.
               // This can happen if a player goes to a new region but
               // never stops in at a safe room.

               oTargetRoom = Send(SYS,@FindRoomByNum,
                                 #num=Send(oCurrentRoom,@GetCurrentRegionHomeroom));
               Send(oTargetRoom,@Teleport,#what=self);
               Send(self,@MsgSendUser,#message_rsc=user_goto_safety);
            }
         }
         else
         {
            // If the user is logged off, we can't teleport.
            // Instead, we update their saved logoff location.

            oCurrentRoom = Send(SYS,@FindRoomByNum,#num=piSave_Room);
            iCurrentRegion = Send(oCurrentRoom,@GetRegion);
            
            if iCurrentRegion = iLastSafeRegion
               OR from_special
            {
               piSave_room = piLastSafeRoom;
               piSave_row = Send(oLastSafeRoom,@GetTeleportRow);
               piSave_col = Send(oLastSafeRoom,@GetTeleportCol);
               piSave_fine_row = 32;
               piSave_fine_col = 32;
            }
            else
            {
               oTargetRoom = Send(SYS,@FindRoomByNum,#num=Send(oCurrentRoom,@GetCurrentRegionHomeroom));

               piSave_room = Send(oTargetRoom,@GetRoomNum);
               piSave_row = Send(oTargetRoom,@GetTeleportRow);
               piSave_col = Send(oTargetRoom,@GetTeleportCol);
               piSave_fine_row = 32;
               piSave_fine_col = 32;
            }
         }
      }

      return;
   }

   AdminGoToSafety()
   "Admin supported\n"
   "Sends the user to their hometown, whether they're logged in or not!\n"
   "Called by constructor for initial placement as well"
   {
      local oNew_Room, iRow, iCol, oRoom, oSpell;

      if piHomeroom <> $
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=abs(piHomeroom));
      }

      if oRoom = $ OR piHomeroom = $ OR NOT Send(oRoom,@IsHometown)
      {
         Send(self,@SetRandomHomeroom);
         oRoom = Send(SYS,@FindRoomByNum,#num=piHomeroom);
      }

      // Remove damned string if rescuing from OoG.
      if (Send(self,@IsPlayerDamned))
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_DAMN);
         if (oSpell <> $)
         {
            Send(self,@RemoveHonorString,#string=Send(oSpell,@GetDamnedRsc));
         }
      }

      piSave_room = piHomeroom;
      piSave_row = Send(oRoom,@GetTeleportRow);
      piSave_col = Send(oRoom,@GetTeleportCol);
      piSave_fine_row = 32;
      piSave_fine_col = 32;

      if pbLogged_on
      {
         Send(oRoom,@Teleport,#what=self);
         Send(self,@MsgSendUser,#message_rsc=user_goto_safety);
      }

      return Send(SYS,@GetSuccessRsc);
   }

   AdminGoToOOG()
   "Admin Supported\n"
   "Sends the user to OOG, whether they're logged in or not!\n"
   {
      local oRoom,oSaveRoom,i,oGhost;

      if pbLogged_on
      {
         Send(self,@TeleportTo,#RID=RID_OOG);
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=RID_OOG);
         oSaveRoom = Send(SYS,@FindRoomByNum,#num=piSave_Room);
         foreach i in Send(oSaveRoom,@GetHolderActive)
         {
            oGhost = Send(oSaveRoom,@HolderExtractObject,#data=i);
            if IsClass(oGhost,&LogoffGhost)
               AND (Send(oGhost,@GetGhostedPlayer) = self)
            {
               Send(oRoom,@NewHold,#what=oGhost,
                     #new_row=Send(oRoom,@GetTeleportRow),
                     #new_col=Send(oRoom,@GetTeleportCol),
                     #fine_row=0,#fine_col=0,
                     #new_angle=Send(oRoom,@GetTeleportAngle));
            }
         }

         piSave_Room = RID_OOG;
         piSave_row = Send(oRoom,@GetTeleportRow);
         piSave_col = Send(oRoom,@GetTeleportCol);
         piSave_fine_row = 0;
         piSave_fine_col = 0;
         piSave_angle = Send(oRoom,@GetTeleportAngle);
         if piSave_angle = $
         {
            piSave_angle = ANGLE_SOUTH;
         }
      }

      return TRUE;
   }

   IsPlayerDamned()
   {
      if (poOwner <> $)
      {
         return Send(poOwner,@GetRoomNum) = RID_OOG;
      }

      return piSave_Room = RID_OOG;
   }

   TeleportToInitialLocation()
   "Assertion:  you are NOT logged on"
   {
      local iInitialRoomID, oRoom;

      iInitialRoomID = Send(SETTINGS_OBJECT,@GetInitialRoomID);
      oRoom = Send(SYS,@FindRoomByNum,#num=iInitialRoomID);

      if oRoom = $
      {
         Debug("There is no initial room!");

         return;
      }

      // we're NOT logged on

      piSave_room = Send(oRoom,@GetRoomNum);
      piSave_row = Send(oRoom,@GetTeleportRow);
      piSave_col = Send(oRoom,@GetTeleportCol);
      piSave_fine_row = 0;
      piSave_fine_col = 0;
      piSave_angle = Send(oRoom,@GetTeleportAngle);
      if piSave_angle = $
      {
         piSave_angle = ANGLE_SOUTH;
      }

      return;
   }

   TeleportTo(RID = RID_TOS,foyer=TRUE,bAdminPort=TRUE)
   "Admin supported."
   "This will teleport the target person to the target room, by RID."
   {
      local oRoom;

      oRoom = Send(SYS,@FindRoombyNum,#num=RID);
      if oRoom = $
      {
         // If FindRoomByNum returns nothing - bad RID
         return FALSE;
      }

      if NOT pbLogged_on
      {
         // If they're not logged in, don't teleport 'em
         return FALSE;
      }

      Send(oRoom,@Teleport,#what=self,#foyer=foyer);

      if bAdminPort
      {
         // Log the teleport.
         GodLog("Admin ",Send(self,@GetTrueName)," teleported to ",
               Send(oRoom,@GetName));
      }

      return TRUE;
   }

   AdminGoToObject(what = $)
   "Admin supported\n"
   "Sends the user as near as possible to <what>."
   {
      local oNew_Room,iRow,iCol,iFineRow,iFineCol,ret_val,logged_off;

      if what = $
      {
         Debug("Got what = $");

         return FALSE;
      }

      if not pbLogged_on
      {
         return FALSE;
      }

      logged_off = FALSE;
      
      if IsClass(what,&Player) AND NOT Send(what,@IsLoggedOn)
      {
         // Logged out players may still have a location.
         oNew_room = Send(SYS,@FindRoomByNum,#num=Send(what,@GetSaveRoom));
         if (oNew_room = $)
         {
            return FALSE;
         }

         iRow = Send(what,@GetSaveRow);
         iCol = Send(what,@GetSaveCol);
         iFineRow = Send(what,@GetSaveFineRow);
         iFineCol = Send(what,@GetSaveFineCol);

         logged_off = TRUE;
      }
      else
      {
         // All objects, including players logged in.
         oNew_room = Send(SYS,@UtilGetRoom,#what=what);
         if (oNew_room = $)
         {
            return FALSE;
         }

         iRow = Send(what,@GetRow);
         iCol = Send(what,@GetCol);
         iFineRow = Send(what,@GetFineRow);
         iFineCol = Send(what,@GetFineCol);
      }

      if iRow = $ OR iCol = $
      {
         Debug("Got bad row or column for object",what);

         return FALSE;
      }

      ret_val = Send(SYS,@UtilGoNearSquare,#what=self,#where=oNew_room,
                     #new_row=iRow,#new_col=iCol,
                     #fine_row=iFineRow,#fine_col=iFineCol,
                     #max_distance=2);

      if ret_val
      {
         if logged_off
         {
            logged_off = user_last_known;
         }
         else
         {
            logged_off = Send(what,@GetDef);
         }

         Send(self,@MsgSendUser,#message_rsc=user_goto_object,
               #parm1=logged_off,#parm2=Send(what,@GetName));
      }

      if IsClass(self,&DM)
      {
         GodLog("Admin ",Send(self,@GetTrueName)," teleported to object ",
               Send(what,@GetTrueName)," in room ",Send(oNew_room,@GetName));
      }
      else
      {
         GodLog(Send(self,@GetTrueName)," was teleported to object ",
            Send(what,@GetTrueName)," in room ",Send(oNew_room,@GetName));
      }

      return ret_val;
   }

   GetMoveOnType()
   {
      local iFlags;

      iFlags = MOVEON_NO;

      if Send(self,@IsInCannotInteractMode)
      {
         iFlags = (iFlags & ~MOVEON_NO);
      }

      // Angeled characters cannot block other players.
      // Disabled for now because minions try to stand on top of them.
      /*if NOT (piFlags & PFLAG_PKILL_ENABLE)
         OR (piFlags & PFLAG_PERMA_NO_PVP)
      {
         iFlags = (iFlags & ~MOVEON_NO);
      }*/

      return iFlags;
   }

   GetDrawingEffectsNoPhase()
   "Drawing effects without phase/spectate."
   {
      local iFlags;

      iFlags = piDrawFx;

      if (piFlags & PFLAG_INVISIBLE)
      {
         // invisibility overrides any other drawfx
         iFlags &= (~DRAWFX_MASK);
         iFlags |= DRAWFX_INVISIBLE;
      }

      if (piFlags & PFLAG_PHASED)
      {
         iFlags &= ~DRAWFX_DITHERINVIS;
      }

      if (piFlags & PFLAG_SPECTATOR)
      {
         iFlags &= ~DRAWFX_DITHERGREY;
      }

      return iFlags;
   }

   GetDrawingEffects()
   {
      local iFlags;

      iFlags = piDrawFx;

      if (piFlags & PFLAG_INVISIBLE)
      {
         // invisibility overrides any other drawfx
         iFlags &= (~DRAWFX_MASK);
         iFlags |= DRAWFX_INVISIBLE;
      }

      if (piFlags & PFLAG_PHASED)
      {
         iFlags &= ~DRAWFX_MASK;
         iFlags |= DRAWFX_DITHERINVIS;
      }

      if (piFlags & PFLAG_SPECTATOR)
      {
         iFlags &= ~DRAWFX_MASK;
         iFlags |= DRAWFX_DITHERGREY;
      }

      return iFlags;
   }

   GetObjectFlagsNoPhase()
   "Object flags without phase/spectate changes."
   {
      local iFlags, oIllusion;

      iFlags = OF_ATTACKABLE | OF_PLAYER | OF_OFFERABLE | OF_DISPLAY_NAME;

      oIllusion = Send(self,@GetIllusionForm);

      // If we're morphed, get rid of any "player" flags
      if (piFlags & PFLAG_MORPHED)
         AND oIllusion <> $
         AND IsClass(oIllusion,&Monster)
      {
         iFlags = (iFlags & ~OF_PLAYER & ~OF_OFFERABLE & ~OF_DISPLAY_NAME);
      }

      // Get the flashing/flickering/phasing/bouncing flags.
      iFlags |= piDrawEffectFlag;

      return iFlags;
   }

   GetObjectFlags()
   {
      local iFlags, oIllusion;

      iFlags = OF_ATTACKABLE | OF_PLAYER | OF_OFFERABLE | OF_DISPLAY_NAME;

      oIllusion = Send(self,@GetIllusionForm);

      // If we're morphed, get rid of any "player" flags
      if (piFlags & PFLAG_MORPHED)
         AND oIllusion <> $
         AND IsClass(oIllusion,&Monster)
      {
         iFlags = (iFlags & ~OF_PLAYER & ~OF_OFFERABLE & ~OF_DISPLAY_NAME);
      }
      
      if Send(self,@IsInCannotInteractMode)
      {
         iFlags |= OF_NOEXAMINE;
         iFlags = (iFlags & ~OF_ATTACKABLE & ~OF_OFFERABLE
                          & ~OF_PLAYER & ~OF_DISPLAY_NAME);
      }

      // Get the flashing/flickering/phasing/bouncing flags.
      iFlags |= piDrawEffectFlag;

      return iFlags;
   }

   GetPlayerNameColor()
   {
      local iDrawFX, iFlags;

      iFlags = 0;

      // Check for any shadow form effects.
      iDrawfX = Send(self,@GetDrawingEffects);
      if (iDrawFX & DRAWFX_BLACK) = DRAWFX_BLACK
      {
         iFlags |= NC_SHADOW;
      }

      if piNameColor <> 0
      {
         iFlags |= piNameColor;

         return iFlags;
      }

      // Send the appropriate flag to draw the name.
      if piFlags & PFLAG_MURDERER
      {
         iFlags |= NC_KILLER;
      }
      else
      {
         if (piFlags & PFLAG_OUTLAW)
         {
            iFlags |= NC_OUTLAW;
         }
         else
         {
            iFlags |= NC_PLAYER;
         }
      }

      return iFlags;
   }

   GetClientObjectType()
   {
      local iFlags;

      iFlags = 0;

      // Send the appropriate flag to draw the name.
      if piFlags & PFLAG_MURDERER
      {
         iFlags |= OT_KILLER;
      }
      else
      {
         if (piFlags & PFLAG_OUTLAW)
         {
            iFlags |= OT_OUTLAW;
         }
      }

      return iFlags;
   }

   IsEventCharacter()
   "Returns TRUE if this is an event character."
   {
      return FALSE;
   }

   SetLoginTime()
   {
      if piLastLoginTime = 0
      {
         piLastLoginTime = 1;
      }

      return;
   }

   ClearLoginTime()
   {
      piLastLoginTime = 0;

      return;
   }

   SetSafety()
   {
      Send(self,@SetPlayerPreference,#flag=CF_SAFETY_OFF,#value=FALSE);
      
      return;
   }

   IsLoggedOn()
   {
      return pbLogged_On;
   }

   GetSession()
   "Used in situations where you may need to tailor-make a package of "
   "text messages by hand without knowing how many variables there will "
   "be - example, showing all the names in a list - recursive stuff."
   {
      return poSession;
   }

   PlayerIsImmortal()
   {
      return FALSE;
   }

   FixMoney(amount = 50000)
   {
      local oMoney,num;

      oMoney = Send(self,@GetMoneyObject);
      if oMoney <> $
      {
         num = Send(oMoney,@GetNumber);
         if num < 0
         {
            Send(oMoney,@AddNumber,#number=-num+1);
         }

         if num > amount
         {
            Send(oMoney,@SubtractNumber,#number=num-50000);
         }
      }
      
      return;
   }

   GetDM()
   {
      return 0;
   }

   EraseAllMail()
   {
      plNew_mail = $;
      
      return;
   }

   AddCurrentQuest(node = $, template = $)
   "Adds a quest to the user's plActiveQuests list.  Each element in "
   "this list is a quest template ID followed by the current active "
   "quest node.  Quests are removed from this list by AddQuestHistory "
   "when the quest finishes."
   {
      local i;

      // Only add the quest if we have a valid quest template and quest node.
      if node = $
         OR template = $
      {
         return;
      }

      // See if we need to change the quest node.
      // QuestEngine prevents duplicate quests.
      foreach i in plActiveQuests
      {
         if First(i) = template
         {
            SetNth(i,2,node);

            return;
         }
      }

      // Add to the end, so quests are displayed in the order given.
      plActiveQuests = AppendListElem([template,node],plActiveQuests);

      // Notice for quest log updating (added or advanced quest).
      Send(self,@WaveSendUser,#what=self,#wave_rsc=user_quest_advance_wav);
      Send(self,@MsgSendUser,#message_rsc=user_quest_log_updated);

      // Update the user's quest log.
      Send(self,@ToCliStats,#group=STAT_GROUP_QUESTS);

      return;
   }

   RemoveCurrentQuest(index=$)
   "Deletes a quest from the user's plActiveQuests."
   {
      local i;

      if index = $
      {
         return;
      }

      foreach i in plActiveQuests
      {
         if First(i) = index
         {
            plActiveQuests = DelListElem(plActiveQuests,i);
         }
      }

      // Notice for quest log updating (finished quest).
      Send(self,@WaveSendUser,#what=self,#wave_rsc=user_quest_complete_wav);
      Send(self,@MsgSendUser,#message_rsc=user_quest_log_updated);

      // Post this, so plQuestHistory can update first.
      Post(self,@ToCliStats,#group=STAT_GROUP_QUESTS);

      return;
   }

   GetActiveQuestNode(index=$)
   "Uses the quest template index to get the quest node the "
   "user is currently on."
   {
      local i;

      if index = QST_ID_NONE
      {
         return $;
      }

      // Try active quests first.
      foreach i in plActiveQuests
      {
         if First(i) = index
         {
            return Nth(i,2);
         }
      }

      // Check completed list.
      foreach i in plQuestHistory
      {
         if (First(i) & QUEST_HISTORY_MASK) = index
            AND (First(i) & QUEST_HISTORY_SUCCESS)
         {
            return $;
         }
      }

      return $;
   }

   ResignFaction()
   "Cancel any active loyalty or faction quests."
   {
      local i, iQID;

      if plActiveQuests = $
      {
         propagate;
      }

      foreach i in plActiveQuests
      {
         iQID = First(i);
         if iQID = QST_ID_PRINCESS_SERVICE
            OR iQID = QST_ID_DUKE_SERVICE
            OR iQID = QST_ID_REBEL_SERVICE
            OR iQID = QST_ID_PRINCESS_SOLDIER
            OR iQID = QST_ID_DUKE_SOLDIER
            OR iQID = QST_ID_REBEL_SOLDIER
         {
            // Post this, because it will edit the plActiveQuests list.
            Post(Nth(i,2),@DeadlineExpired);
         }
      }

      propagate;
   }

   // plQuestHistory is list of lists of the format
   //  [ compound, last_success_time, last_failure_time ]
   // compound is:
   //  QUEST_HISTORY_SUCCESS bit indicates player has done quest successfully
   //   at least once
   //  QUEST_HISTORY_FAILURE bit indicates player has failed quest at least once
   //  Remaining bits are quest index.
   // Times are TimeLoggedIn values, which count the total time logged in
   //  across sessions

   GetQuestHistory(index = $)
   "Return quest history bits for indicated quest for this player, or nil "
   "if illegal index provided."
   {
      local lQH;
      
      if plQuestHistory = $ 
      {
         return [0,0,0];
      }
      
      if index = $ 
      {
         return $;
      }
      
      if (index & ~QUEST_HISTORY_MASK) <> 0 
      {
         Debug("GetQuestHistory got illegal index.");
         
         return $;
      }
      
      foreach lQH in plQuestHistory
      {
         if (first(lQH) & QUEST_HISTORY_MASK) = index
         {
            return lQH;
         }
      }
      
      return [0,0,0];
   }

   AddQuestHistory( index = $, success = $ )
   "Set quest history success/failure bit for indicated quest for this "
   "player, adding quest index to list if necessary, and update last "
   "successtime, failtime.  "
   "Returns TRUE on success, FALSE if illegal parameters provided."
   {
      local lQH, iLength, iTime, templQH;

      if index = $
      {
         return FALSE;
      }

      if (index & ~QUEST_HISTORY_MASK) <> 0
      {
         return FALSE;
      }

      if success = $
      {
         return FALSE;
      }

      Send(self,@RemoveCurrentQuest,#index=index);

      iTime = Send( self, @GetTimeLoggedIn );
      foreach lQH in plQuestHistory
      {
         if (first(lQH) & QUEST_HISTORY_MASK) = index
         {
            if success
            {
               SetNth(lQH,1,(First(lQH)|QUEST_HISTORY_SUCCESS));
               SetNth(lQH,2,iTime);
            }
            else
            {
               SetNth(lQH,1,(First(lQH)|QUEST_HISTORY_FAILURE));
               SetNth(lQH,3,iTime);
            }
            // Move quest to front of list.
            templQH = lQH;
            plQuestHistory = DelListElem(plQuestHistory, lQH);
            plQuestHistory = Cons(lQH, plQuestHistory);

            return TRUE;
         }
      }

      // new quest for this user
      if success
      {
         lQH = [(index | QUEST_HISTORY_SUCCESS), iTime, 0];
      }
      else
      {
         lQH = [(index | QUEST_HISTORY_FAILURE), 0, iTime];
      }

      plQuestHistory = Cons(lQH, plQuestHistory);

      return TRUE;
   }

   ClearQuestHistory(index=$, allBelow=FALSE, allAbove=FALSE)
   "Admin supported."
   "Clear a particular quest, or all above/below it (inclusive)."
   "Call with no args to clear all quests."
   "Called with no args at suicide."
   {
      local oQuestEngine, step;

      if index = $
         OR (allBelow AND allAbove)
      {
         plQuestHistory = $;
         if pbLogged_on
         {
            Send(self,@ToCliStats,#group=STAT_GROUP_QUESTS);
         }

         return;
      }

      oQuestEngine = Send(SYS,@GetQuestEngine);
      step = 0;
      
      if allBelow
      {
         step = -1;
      }
      
      if allAbove
      {
         step = 1;
      }
      
      if step = 0
      {
         Send(self,@ClearOneQuestHistory,#index=index);
      }
      else
      {
         while Send(oQuestEngine,@IsValidQuestTemplate,#index=index)
         {
            Send(self,@ClearOneQuestHistory,#index=index);
            index += step;
         }
      }
      
      return;
   }

   ClearOneQuestHistory(index = $)
   "Admin supported."
   "A little safer than ClearQuestHistory,"
   "since a typo won't screw up everything."
   {
      local lQH;

      foreach lQH in plQuestHistory
      {
         if (first(lQH) & QUEST_HISTORY_MASK) = index
         {
            plQuestHistory = DelListElem(plQuestHistory, lQH);
            
            if pbLogged_on
            {
               Send(self,@ToCliStats,#group=STAT_GROUP_QUESTS);
            }

            return TRUE;
         }
      }
      
      return FALSE;
   }

   UpdateTimeValues()
   "Sets all time variables to the current time.  Useful for when changing server time."
   {
      local i, iTime;

      // Don't set piTimeNewsPosted to current time.  That'd potentially make
      //  people unable to post for a while.
      piTimeNewsPosted = 0;

      // Eliminate logoff penalty time.  Just easier this way.
      Send(self,@RefreshPhaseTimeToBase);

      iTime = GetTime();

      // Set any 'future' mail to current time. Client uses the
      // string timestamp, int one is just for deleting old mails.
      foreach i in plNew_mail
      {
         if (Nth(i,2) > iTime)
         {
            SetNth(i,2,iTime);
         }
      }

      // Can be 0 for non-created players. Set to current if not 0.
      if (piLastLoginTime > 0)
      {
         piLastLoginTime = iTime;
      }

      propagate;
   }

   SomeoneOverheard(from=$,to=$,format=$,string=$)
   {
      local rFrom;
      
      if NOT pbLogged_on
      {
         propagate;
      }

      rFrom = Send(from,@GetTrueName);

      AddPacket(1,BP_SAID, 4,from, 4,rFrom, 1,SAY_GROUP_ONE, 4,format,
                4,rFrom, 4,Send(to,@GetTrueName), 0,string);
      SendPacket(poSession);

      propagate;
   }

   ResetCheaterLogs()
   "Resets the number of moves logged so that we can continue logging "
   "suspected speedhack abuse."
   {
      if piCheaterLogs > 0
      {
         piCheaterLogs = 0;
      }

      return;
   }

   HasMovedRecently()
   "Checks if user is mobile and has moved in the last few seconds."
   {
      // We're not moving if it's been more than 2 seconds since we moved
      //   OR if we're flagged as unable to move.
      if (Abs(GetTickCount() - piLastMoveUpdateTime) > 2000)
         OR (piFlags & PFLAG_NO_MOVE)
      {
         return FALSE;
      }

      return TRUE;
   }

   GetIdleTime()
   {
      return GetInactiveTime(poSession);
   }

   AdminGotoBlink()
   {
      local oRoom;

      if pbLogged_on
      {
         oRoom = poOwner;
         Send(oRoom,@Teleport,#what=self);
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=piSave_room);
         Send(self,@SetSaveLocation,
              #row=Send(oRoom,@GetTeleportRow),
              #col=Send(oRoom,@GetTeleportCol));
      }

      return;
   }

   SetSaveLocation(rid=$,row=$,col=$)
   {
      if rid <> $
      {
         piSave_room = rid;
      }

      if row <> $
      {
         piSave_row = row;
         piSave_fine_row = FINENESS/2;
      }

      if col <> $
      {
         piSave_col = col;
         piSave_fine_col = FINENESS/2;
      }

      return;
   }

   GetSaveRoomLoggedOn()
   {
      return piSave_room;
   }

   GetSaveRoom()
   {
      if pbLogged_on
      {
         return $;
      }

      return piSave_room;
   }

   GetSaveRow()
   {
      if pbLogged_on
      {
         return $;
      }

      return piSave_row;
   }

   GetSaveCol()
   {
      if pbLogged_on
      {
         return $;
      }

      return piSave_Col;
   }

   GetSaveFineRow()
   {
      if pbLogged_on
      {
         return $;
      }

      return piSave_Fine_row;
   }

   GetSaveFineCol()
   {
      if pbLogged_on
      {
         return $;
      }

      return piSave_Fine_Col;
   }

   GetSaveAngle()
   {
      if pbLogged_on
      {
         return $;
      }

      return piSave_Angle;
   }

   FixMailTimestamps()
   "Adds the new timestamp field to each mail in plNew_mail."
   {
      local i;

      foreach i in plNew_mail
      {
         if (Length(i) < 5)
         {
            i = InsertListElem(i,MAIL_LONG_TIME,
                     OldTimestampFix(Nth(i,MAIL_SHORT_TIME)));
         }
      }

      return;
   }

   RemoveOldMail(iDays=180)
   {
      local iCutoff_time, lRecent_mail, lNew_mail, iTime, iRemoved;

      iCutoff_time =  GetTime() - (iDays * DAY);
      iRemoved = 0;

      foreach lNew_mail in plNew_mail
      {
         // This is a list of [ from, time, list of to, other ]
         iTime = Nth(lNew_mail,MAIL_SHORT_TIME); // use GetTime() here
         if (iTime > iCutoff_time)
            AND iTime < GetTime()
         {
            lRecent_mail = Cons(lNew_mail,lRecent_mail);
         }
         else
         {
            ++iRemoved;
         }
      }
      if Length(plNew_mail) <> Length(lRecent_mail)
      {
         Debug("User",self,vrName,"had",Length(plNew_mail),"now",
               Length(lRecent_mail));
      }
      plNew_mail = lRecent_mail;

      return iRemoved;
   }

   CleanBadMail()
   {
      local lNew_mail, stuff, i, j;

      i = 1;
      foreach lNew_mail in plNew_mail
      {
         // This is a list of [ from, short time, unix timestring, list of to, list of stuff ]
         stuff = Nth(lNew_mail,MAIL_TEXT);
         if (Length(stuff) > 1)
         {
            j = 1;
            while j <= Length(stuff)
            {
               if (Nth(stuff,j+1) = $)
               {
                  Debug("found bad mail",self);
                  plNew_mail = DelListElem(plNew_mail, lNew_mail);

                  return 1;
               }
               j += 2;
            }
         }
         ++i;
      }

      return 0;
   }

   AdminSetIP()
   "Sets plIPAddress to current IP if logged on. Useful for initial setting."
   {
      if (pbLogged_on)
      {
         plIPAddress = GetSessionIP(poSession);
      }

      return;
   }

   AdminClearIP()
   "Clears plIPAddress for non-logged in users."
   {
      if (NOT pbLogged_on)
      {
         plIPAddress = $;
      }

      return;
   }

   GetIP()
   "Returns the user's ip in a list which contains the 16 octets (IPv6)"
   "use this message for comparisons and the string message sparingly."
   {
      return plIPAddress;
   }

   GetIPString()
   "returns ip as a string.  Use this sparingly and only if"
   "you need the human readable string, use the list returned by"
   "GetIP() for comparisons."
   {
      local i, sReturn;

      if (plIPAddress = $)
      {
         return;
      }

      ClearTempString();

      for (i = 1; i < 16; ++i)
      {
         AppendTempString(Nth(plIPAddress, i));
         AppendTempString(":");
      }
      AppendTempString(Nth(plIPAddress,16));

      return SetString($,GetTempString());
   }

   SendStatChange()
   "Sends a stat change request to the client"
   {
      local lSpellLevels, lSkillLevels;

      // if stats reset is turned off, ignore the request
      if NOT Send(SETTINGS_OBJECT,@GetStatsResetEnabled)
      {
         return;
      }

      // must have a token if over the free stat reset cap
      if Send(self,@FindHolding,#class=&StatsResetToken) = $
         AND (piBase_Max_Health > Send(SETTINGS_OBJECT,@GetFreeStatsResetCap))
      {
         return;
      }

      lSpellLevels = Send(self, @GetSpellSchoolLevels);
      lSkillLevels = Send(self, @GetSkillSchoolLevels);

      // TODO: don't load module if it is already loaded
      Send(self,@UserLoadModule,#module=user_statchange_module);

      AddPacket(1,BP_STAT_CHANGE, 1,piMight, 1,piIntellect, 1,piStamina,
                1,piAgility, 1,piMysticism, 1,piAim, 1,First(lSpellLevels),
                1,Nth(lSpellLevels,2), 1,Nth(lSpellLevels,3),
                1,Nth(lSpellLevels,4), 1,Nth(lSpellLevels,5),
                1,Nth(lSpellLevels,6), 1,First(lSkillLevels));
      SendPacket(poSession);

      return;
   }

   UserChangedStats(might=25,intellect=25,stamina=25,agility=25,mysticism=25,
                     aim=25,shallile_lvl=0,qor_lvl=0,kraanan_lvl=0,faren_lvl=0,
                     riija_lvl=0,jala_lvl=0,weaponcraft_lvl=0)
   "Processes a stat change request from the client"
   {
      local i, lSpellLevels, lSkillLevels, lSpellLevels_new, lSkillLevels_new,
            totalLevels, totalSchools, totalLvlOnes, iPrimaryStat, oSpell,
            iSpellAbility, iSpellNum, oSkill, iSkillAbility, iSkillNum;

      // if stats reset is turned off, ignore the request
      if NOT Send(SETTINGS_OBJECT,@GetStatsResetEnabled)
      {
         return;
      }
      
      if Send(self,@FindHolding,#class=&StatsResetToken) = $
         AND (piBase_Max_Health > Send(SETTINGS_OBJECT,@GetFreeStatsResetCap))
      {
         return;
      }
      
      i = 1;
      totallevels = 0;
      totalLvlOnes = 0;
      totalSchools = 0;
      lSpellLevels = Send(self, @GetSpellSchoolLevels);
      lSpellLevels_new = [shallile_lvl,qor_lvl,kraanan_lvl,
                           faren_lvl,riija_lvl,jala_lvl];
      lSkillLevels = Send(self, @GetSkillSchoolLevels);
      lSkillLevels_new = [weaponcraft_lvl];
   
      // Range Checks, no client hacking negative stats funny business!
      if (might < 1 OR might > 50)
         OR (intellect < 1 OR intellect > 50)
         OR (stamina < 1 OR stamina > 50)
         OR (agility < 1 OR agility > 50)
         OR (mysticism < 1 OR mysticism > 50)
         OR (aim < 1 OR aim > 50)
      {
         Debug("Stat Range Check: Failed!");
         return FALSE;
      }
      
      // School Range Check
      if (shallile_lvl < 0 OR shallile_lvl > 6)
         OR (qor_lvl < 0 OR qor_lvl > 6)
         OR (kraanan_lvl < 0 OR kraanan_lvl > 6)
         OR (faren_lvl < 0 OR faren_lvl > 6)
         OR (riija_lvl < 0 OR riija_lvl > 6)
         OR (jala_lvl < 0 OR jala_lvl > 6)
         OR (weaponcraft_lvl < 0 OR weaponcraft_lvl > 6)
      {
         Debug("School Range Check: Failed!");
         return FALSE;
      }
         
      // Quick check for too many points in stats
      if ((might + intellect + stamina + agility + mysticism + aim) > 200 )
      {
         Debug("Points Check: FAIL!");
         return FALSE;
      }
      Debug(("points check: PASS"));

      // Check school levels for funny business
      
      // Count schools above level 1
      
      // Spell Levels - skipping DM school (7)
      while (i < NUM_SCHOOLS)
      {
         if (Nth(lSpellLevels_new,i) = 1)
         {
            ++totalLvlOnes;
         }
         if (Nth(lSpellLevels_new,i) > 1)
         {
            ++totalSchools;
            totalLevels += Nth(lSpellLevels_new,i);
         }
         if (Nth(lSpellLevels_new,i) > Nth(lSpellLevels,i))
         {
            Debug("School Not Increased Check: FAIL!");
            return FALSE;
         }
         ++i;
      }
      
      // skill levels
      i = 1;
      while (i <= NUM_SKILL_SCHOOLS)
      {
         if (Nth(lSkillLevels_new,i) = 1)
         {
            ++totalLvlOnes;
         }
         if (Nth(lSkillLevels,i) > 1)
         {
            ++totalSchools;
            totalLevels += Nth(lSkillLevels_new,i);
         }
         if (Nth(lSkillLevels_new,i) > Nth(lSkillLevels,i))
         {
            Debug("School Not Increased Check: FAIL!");
            return FALSE;
         }
         ++i;
      }

      // treat level 1s as level 2s
      totalLevels += totalLvlOnes;

      // See if the player has enough int to support their levels
      if ((totalLevels - totalSchools > 8)
               AND (((totalLevels - totalSchools - 8) * 5) > intellect))
      {
         Debug("Int Check: FAIL!");
         //Debug("total levels",totalLevels,"intellect",intellect,"needed",
         //      (totalLevels - totalSchools - 8) * 5);
         return FALSE;
      }
      
      Debug(("School Level Check: PASS"));
      
      // everything looks good, start adjusting stats
      
      // Consume token
      if piBase_Max_Health > Send(SETTINGS_OBJECT,@GetFreeStatsResetCap)
      {
         Send(Send(self,@FindHolding,#class=&StatsResetToken),@Delete);
      }
      
      // Strip Spell Levels
      i = 1;
      while (i < NUM_SCHOOLS)
      {
         if (Nth(lSpellLevels,i) > 0 )
         {
            while (Nth(lSpellLevels,i) > Nth(lSpellLevels_new,i))
            {
               Send(self,@StripSpellsOfSchoolByLevel,#school=i,
                     #level=Nth(lSpellLevels,i));
               SetNth(lSpellLevels,i,Nth(lSpellLevels,i) - 1);
            }
         }
         ++i;
      }

      Debug("Spell Schools Stripped");
      // Strip Skills (Skill schools start at 10)
      i = 1;
      while (i <= NUM_SKILL_SCHOOLS)
      {
         if (Nth(lSkillLevels,i) > 0)
         {
            while(Nth(lSkillLevels,i) > Nth(lSkillLevels_new,i))
            {
               // have to add 9 to i to get the proper school id
               Send(self,@StripSkillsOfSchoolByLevel,#school=i+9,
                     #level=Nth(lSkillLevels,i));
               SetNth(lSkillLevels,i,Nth(lSkillLevels,i) - 1);
            }
         }
         ++i;
      }
      Debug("Skill Schools Stripped");

      // Now iterate through the player's spells and strip 2// per stat loss
      foreach i in plSpells
      {
         iSpellNum = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
         iPrimaryStat = Send(oSpell,@GetPrimaryStat);
         iSpellAbility = Send(self,@DecodeSpellAbility,#compound=i);

         if (iPrimaryStat = STAT_ID_STAMINA)
         {
            if (iSpellAbility > (stamina * 2)) AND (stamina < piStamina)
               OR (iSpellAbility = 99 AND piStamina = 50 AND stamina < 50)
            {
               Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,
                     #amount=((piStamina - stamina)
                     * Send(SETTINGS_OBJECT,@GetStatsResetPenalty)));
            }
         }
         else if (iPrimaryStat = STAT_ID_INTELLECT)
         {
            if (iSpellAbility > (intellect * 2)) AND (intellect < piIntellect)
               OR (iSpellAbility = 99 AND piIntellect = 50 AND intellect < 50)
            {
               Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,
                     #amount=((piIntellect - intellect)
                     * Send(SETTINGS_OBJECT,@GetStatsResetPenalty)));
            }
         }
         else if (iPrimaryStat = STAT_ID_MYSTICISM)
         {
            if (iSpellAbility > (mysticism * 2)) AND (mysticism < piMysticism)
               OR (iSpellAbility = 99 AND piMysticism = 50 AND mysticism < 50)
            {
               Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,
                     #amount=((piMysticism - mysticism)
                     * Send(SETTINGS_OBJECT,@GetStatsResetPenalty)));
            }
         }
      }
      Debug("Spell % Recalculated");
      
      foreach i in plSkills
      {
         iSkillNum = Send(self,@DecodeSkillNum,#compound=i);
         oSkill = Send(SYS,@FindSkillByNum,#num=iSkillNum);
         iPrimaryStat = Send(oSkill,@GetPrimaryStat);
         iSkillAbility = Send(self,@DecodeSkillAbility,#compound=i);
         
         if (iPrimaryStat = STAT_ID_AGILITY)
         {
            if (iSkillAbility > (agility * 2)) AND (agility < piAgility)
               OR (iSkillAbility = 99 AND piAgility = 50 AND agility < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piAgility - agility) * -2));
            }
         }
         else if (iPrimaryStat = STAT_ID_AIM)
         {
            if (iSkillAbility > (aim * 2)) AND (aim < piAim)
               OR (iSkillAbility = 99 AND piAim = 50 AND aim < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piAim - aim) * -2));
            }
         }
         else if (iPrimaryStat = STAT_ID_MIGHT)
         {
            if (iSkillAbility > (might * 2)) AND (might < piMight)
               OR (iSkillAbility = 99 AND piMight = 50 AND might < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piMight - might) * -2));
            }
         }
         else if (iPrimaryStat = STAT_ID_STAMINA)
         {
            if (iSkillAbility > (stamina * 2)) AND (stamina < piStamina)
               OR (iSkillAbility = 99 AND piStamina = 50 AND stamina < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piStamina - stamina) * -2));
            }
         }
      }
      Debug("Skill % Recalculated");

      Debug(Send(self,@GetTrueName), " changed stats from ",
         piMight, piIntellect, piStamina, piAgility, piMysticism, piAim,
         " to ", might, intellect, stamina, agility, mysticism, aim);

      // Change stamina and check HP in a separate message, number of
      // locals is getting too high in this one.
      Send(self,@UserStatChangeStamina,#stamina=stamina);

      piIntellect = intellect;
      piMight = might;
      piAgility = agility;
      piMysticism = mysticism;
      piAim = aim;

      // recalculate mana pool based on nodes and mysticism
      Send(self,@ComputeMaxMana);
      Debug("Mana Recalculated");
      
      // TODO: Unload stats.dll module.

      // Refresh the client screen so they see the new stats
      Send(self, @InvalidateData);
      Debug("Player Updated!");

      return;
   }

   UserStatChangeStamina(stamina = $)
   {
      local iMaxHP, iNewMaxHP;

      if (stamina = $)
      {
         Debug("UserStatChangeStamina sent $ stamina for ",self);

         return;
      }

      // Get the old max HP before adjusting stamina.
      iMaxHP = Send(self,@GetBaseMaxHealth);

      piStamina = stamina;

      iNewMaxHP = Send(self,@GetBaseMaxHealth);

      // Set their max health to the correct level.
      if (iMaxHP <> iNewMaxHP)
      {
         Send(self,@GainMaxHealth,#amount=iNewMaxHP - iMaxHP);
         Send(self,@NewHealth);
         Debug("HP Recalculated");
      }

      return;
   }

   SetUserTrail(iRow=$,iCol=$,iFineRow=$,iFineCol=$)
   {
      local i;

      if (poOwner = $)
         OR (iRow = $)
         OR (iCol = $)
         OR (iFineRow = $)
         OR (iFineCol = $)
      {
         plUserTrail = $;
      }
      else
      {
         plUserTrail = Cons([iRow,iCol,iFineRow,iFineCol],plUserTrail);

         if Length(plUserTrail) > Send(poOwner,@GetTrailLength)
         {
            plUserTrail = DelLastListElem(plUserTrail);
         }
      }

      return;
   }

   GetUserTrail()
   {
      return plUserTrail;
   }

   SetLastServerTeleport()
   {
      piLastServerTeleport = GetTickCount();
      return;
   }

end
////////////////////////////////////////////////////////////////////////////////
