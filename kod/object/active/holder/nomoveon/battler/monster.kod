// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


//////////////////////////////////////////////////////////////////////////////
Monster is Battler

constants:

   include blakston.khd
   include protocol.khd

   // 9 minutes
   TURN_TIME = 9*60*1000   

   // How many percents between each message for how much a player needs to
   //  learn to qualify for a new spell.
   MONSTER_LEARN_GRADIENT = 15

   // Values returned by UserGet
   AUTOLOOT_GOT_ITEM = 1
   AUTOLOOT_OUT_OF_RANGE = 2
   AUTOLOOT_GOT_PARTIAL_STACK = 3
   AUTOLOOT_CANNOT_GET = 4

   // Number of ms to lose one boosted health or mana point.
   BOOST_DECAY_TIME = 30000 

   // Monsters can exceed a player's stats. By how much?
   MONSTER_STAT_CAP = 500 

   // This tick factor modifies responsiveness of resource regeneration for
   // monsters. The factor is a percentage of the original and will scale
   // tick duration and the amount of resource gained/lost accordingly.
   TICK_FACTOR_MONSTER = 500

resources:

   include monster.lkod

   monster_percent_q = "%q"
   monster_color_blue_rsc = "~b"

   monster_plural = "s"
   monster_little = "a little "             // for under 15pts to gain
   monster_nothing = ""                     // for 15-30 pts to gain
   monster_some = "some "                   // for 30-45 pts to gain
   monster_much = "much "                   // for 45-60 pts to gain
   monster_significantly = "significantly " // for 60-75 pts to gain
   monster_drastically = "drastically "     // for 75+ pts to gain

   monster_teach_karma = \
      "Your karma is not far enough along the true path for you to learn %s."
   monster_teach_quest_needed = \
      "I can teach you %s, but first you must prove your worth as a pupil."
   monster_teach_base = \
      "Your mind is focused properly, and with %sfurther progress in the "
      "previous %s levels you can learn %s." 
   monster_teach_success = \
      "You are currently qualified to learn %s.  Congratulations."
   monster_teach_already = "You have already been taught %s."
   monster_teach_nobase = \
      "You first need to have some knowledge of the previous level before you "
      "can learn %s."
   monster_teach_impossible = \
      "Indeed, you have learned so much already! A fine accomplishment.  You "
      "have no... need... to learn further in this school."

   monster_level = "level"
   monster_said_resource_str = "%s%s says, \"%s~n\""

   monster_teach_comma = ", "
   monster_teach_and = "and "
   monster_teach_blank = ""

   monster_anonymous_response = \
      "%s looks at you with a peculiar expression, and does not respond." 

   LS_Cant_part = \
      "I cannot see how you could bear to part with %s%s!  I certainly "
      "couldn't be the one to take it off your hands."
   LS_Signet_returned = \
      "Oh! I was sure this was lost forever.  Thank you very, very much for "
      "bringing it back to me.  Here, let me give you a small reward."
   LS_Signet_wrong = \
      "An heirloom for sure.  You should take it to %s%s yourself.  There's "
      "likely to be a reward for its return."
   LS_wanted_keep = "Thank you.  I will someday return the favor."
   LS_unwanted_keep = \
      "~k%s%s tells you, \"Thank you.  It is very nice of you to just give "
      "this to me.~n~k\""
   LS_unwanted_pay = \
      "~k%s%s tells you, \"Here.  I'll give you a few shillings for "
      "this.~n~k\""
   LS_unwanted_give = \
      "~k%s%s tells you, \"I simply have no need for that.~n~k\""
   LS_unwanted_token = \
      "~k%s%s tells you, \"I am honored to hold it briefly, but this token "
      "must be returned to the member of the Meridian Council who studies "
      "it.  I'm afraid I must give it back to you.~n~k\""
   LS_nofight_attacked = \
      "You have a funny feeling that attacking is pointless."

   Lm_nothing_for_sale = "I'm afraid I have nothing to sell right now."

   Lm_first_damage_level = "~B~r%s%s is slightly wounded."
   Lm_second_damage_level = "~B~r%s%s is clearly injured."
   Lm_third_damage_level = "~B~r%s%s is seriously wounded."
   Lm_fourth_damage_level = "~B~r%s%s is weak, and near death."
   Lm_first_heal_level = "~B~t%s%s has recoverd a little and looks pretty healthy once more."
   Lm_second_heal_level = "~B~t%s%s has recoverd a little but still shows signs of being slightly wounded."
   Lm_third_heal_level = "~B~t%s%s has recoverd a little but still suffers from clearly visible wounds."
   Lm_fourth_heal_level = "~B~t%s%s has recoverd a little but still suffers from serious injuries."
   Lm_party_killed_monster = "~B%s%s has valiantly slain %s%s!"
   Lm_party_monster_died_to_dot = "%s%s has succumbed to %s injuries!"

   Lm_monster_winded = "~I~r%s%s needs a moment to catch %s breath!"
   Lm_monster_spin = "~I~r%s%s spins around in a vicious attack!"

   monster_desc_level = "This opponent will take you to %i hitpoints."
   Lm_condition_healthy = "%s\n\n%r"
   Lm_condition_good = \
      "%s\n\n%r\n\n%s%s is injured, but is still relatively strong."
   Lm_condition_fair = \
      "%s\n\n%r\n\n%s%s is wounded, but is still relatively strong."
   Lm_condition_poor = "%s\n\n%r\n\n%s%s is suffering from deep wounds."
   Lm_condition_bad = \
      "%s\n\n%r\n\n%s%s is weak and seems unlikely to survive much longer."

   Lm_cant_remove_item = "You can't give %s%s away right now."
   Lm_mrcnt_not_selling = "You tried to buy something that is not being sold."
   Lm_mrcnt_too_costly = "Come back when you have enough money for %s%s."
   Lm_mrcnt_cant_give = \
      "I'm unable to give you %s%s.  Perhaps you carry too much?"
   Lm_mrcnt_can_give_some = \
      "It looks like you can only hold some of %s%s. I'll reduce your tally."

   Lm_only_receiver = "%s%s says, \"I don't buy things, but I do take gifts.\""
   Lm_buyer_offer_busy = "%s is busy right now with another customer." 
   Lm_buyer_no_value = "I can't even give you a shilling for that."
   Lm_buyer_timeout = \
      "Can't make up your mind?  Think on it and come back when you are ready."
   Lm_buyer_unwanted = "I'm not interested."
   Lm_bnkr_balance = "You have %i shillings in your account."
   Lm_bnkr_did_deposit = \
      "Thank you for your deposit.  You now have %i shillings in your account."
   Lm_bnkr_no_account = "You have no money to withdraw!"
   Lm_bnkr_acct_full = \
      "You have so many shillings stored here, that I'm afraid I have no "
      "space to store any more!"
   Lm_bnkr_acct_almost_full = \
      "You have so many shillings stored here, that I'm afraid I can only "
      "store %i more."
   Lm_bnkr_not_enough_withdraw = \
      "But you only have %i shillings in your account!"
   Lm_bnkr_not_enough_deposit = \
      "But you only have %i shillings in your possession!"
   Lm_bnkr_did_withdraw = \
      "Here are your %i shillings. Thank you for your business."
   Lm_bnkr_player_full = \
      "I swear, if I gave you a shilling more than %i you'd topple right over!"
   Lm_bnkr_player_all_full = "You can't hold even a single shilling more!"

   Lm_mercenary_join = \
      "You shouldn't go alone, it's dangerous out there...  Let me join you "
      "until ~Iit's time to part ways again~I."
   Lm_mercenary_join_contracted = "Reporting for duty!"
   Lm_mercenary_leave = "I'll be getting back to my squad.  Stay safe out there!"
   Lm_mercenary_leave_trigger = "it's time to part ways again"

   vaultman_nogold = "You may not use my services to store %s%s."
   vaultman_nocursed = "I cannot take %s%s from you."
   vaultman_fullvault = \
      "Your vault cannot hold that much stuff!  Perhaps you should try "
      "offering items in smaller quantities."
   vaultman_thanks_amount = \
      "That will cost %i shillings.  Thank you for trusting me to "
      "quartermaster your gear."
   vaultman_dont_have = "Hmmm, I can't seem to find %s%s in your vault."
   vaultman_no_room = \
      "You can't carry all of that!  Perhaps you should try withdrawing the "
      "items one at a time."
   vaultman_deposit_thanks = \
      "Thank you for trusting me to quartermaster your gear."
   vaultman_thanks = "Here is your gear.  Thank you for your patronage."
   vaultman_withdraw_failed = \
      "I was unable to complete our transaction.  Please sort your inventory "
      "and try again."
   vaultman_nowithdraw_cash = \
      "You currently cannot pay the exit fee to get your stuff out."
   vaultman_nodeposit_cash = \
      "Storing these items would cost %i shillings - which I see you do not "
      "have."
   vaultman_cant_part = \
      "Wow... I couldn't feel responsible if your %s were to disappear - I "
      "cannot store it."
   vaultman_noaccount = "I do not seem to be storing any of your gear."
   vaultman_not_enough = "You don't have that many %s stored in your name!"

   monster_say_to_one = "~k%s%s tells you, \"%s~n~k\""

   monster_iteach = "I teach %s%s%s%s%s%s%s%s%s%s%s%s at that level."
   monster_teachnothing = "I teach no abilities at that level."

   monster_koc_name = "moch"

   monster_report_balance = \
      "~B~g[~n~k%s%s tells you, \"%q has %i shillings in this bank.\"~B~g]"
   Monster_Sweep_Reward = \
      "Hmm... that looks a bit cleaner.  Here, take this as payment, %s%s."

   monster_default_attack = "attack"
   minion_trouble = \
      "You sense your minion has gotten you into some trouble..."

   autolooted_all = "You loot the corpse clean, and find %d shillings."
   autolooted_all_no_money = "You loot the corpse clean."
   autolooted_some = "You loot some of the items from your fallen kill, and "
      "find %d shillings."
   autolooted_some_no_money = "You loot some of the items from your fallen enemy."
   autolooted_only_money = "You find nothing easily lootable on your slain "
      "enemy other than %d shillings."
   autolooted_none = "You find nothing easily lootable on your slain enemy."
     
   autoloot_too_far_away = "You're too far away to loot your fallen enemy!"
   autoloot_got_some_but_full_now = "You pick up some of your slain enemy's "
      "loot, but find yourself too encumbered to get it all."
   autoloot_got_nothing_because_full= "You can't carry any more, so you loot "
      "nothing from your fallen enemy."
   autoloot_got_only_shillings_because_full = "You can't carry any more, so you "
      "loot nothing from your fallen enemy, but you do find %d shillings."

   monster_faction_negative_msg = \
      "Your standing with The %s has decreased"

   monster_faction_positive_msg = \
      "Your standing with The %s has increased"

   monster_faction_unspecified = "UNSPECIFIED MONSTER FACTION!"
   monster_faction_farol = "Minions of Life"
   monster_faction_orc = "Orcs"
   monster_faction_troll = "Trolls"
   monster_faction_farnohl = "House of Lord Far'Nohl"
   monster_faction_lich = "Subjects of Queen Venya'cyr"
   monster_faction_psavar = "Peet-Seeeep Avar Clan"
   monster_faction_kkavar = "Kyip-Kyip-Kreeet Avar Clan"
   monster_faction_ctavar = "Chyup-Tewee Avar Clan"
   monster_faction_fey_good = "Fey Elhai"
   monster_faction_fey_evil = "Fey Dirhai"
   monster_faction_frogmen = "Frogmen"
   monster_faction_heretic = "Cult of the Three"
   monster_faction_undead = "Minions of Death"

   monster_illusion_poison = \
      "~k~I%s%s reels as poison from your attack courses through %s veins.%s"
   monster_illusion_bleed = \
      "~k~I%s%s groans as you leave a bleeding gash on %s side, dealing ~r%i~k damage."
   monster_illusion_siphon = \
      "~k~I%s%s looks distressed as as your attack siphons mana from %s soul.%s"
   monster_illusion_fatigue = \
      "~k~I%s%s gasps for air as your attack takes %s breath away.%s"
   monster_illusion_burn = \
      "~k~I%s%s flails around wildly as your attack sets %s clothes on fire.%s"
   monster_illusion_damage_blank = ""

   monster_leash_reset = \
      "~o~BTired of chasing, %s%s calls off the hunt."

   monster_projectile_icon = rocksm.bgf

classvars:

   vrKocName = monster_koc_name
   viGender = GENDER_NEUTER
   
   vbNamedMob = FALSE
   
   vrDead_icon = $
   vrDead_name = $

   viAttack_type = ATK_TYPE_HIT
   viSpell_type = 0
   viMerchant_markup = MERCHANT_NORMAL
   viCancel_offer_time = 30000
   // Default to teleport if there's no move anim, also used for movement timer
   //  (range is 1 to 20)
   viSpeed = 0

   // Speed while strolling...
   // A percentage of regular speed. 50 by default.
   viStrollSpeed = 50

   viTreasure_type = TID_NONE

   // Random delay from delay to 1.50*delay
   viRandom_delay = 40000
   // from delay to 1.33*delay
   viSpasm_delay  = 15000

   viQuestID      = 0
   // viAttributes is a bitvector of behavior and services
   viAttributes   = 0
   // viOccupation is what this mob does for a living, used for NPCs.
   viOccupation   = 0
   viKarma        = 0

   // If the monster is undead, set this to TRUE.
   vbIsUndead = FALSE

   // viLevel ranges from 25 to 200 (150 and above is for "boss" mobs)
   //  determines hit points.
   viLevel        = 25

   // viDifficulty ranges from 1 to 9, increases combat prowess. 10 can
   // be used but is far too difficult for general use.
   viDifficulty = 0

   // viVisionDistance is the radius (in row/col units) that the monster
   // can see within. Default 10.
   viVisionDistance = 10

   // viMeleeRange is the radius (in FINENESS units) that the monster
   // can attack within. Default 128, or 2 row/cols.
   viMeleeRange = 128

   // viFireRange is the radius (in FINENESS units) that the monster
   // can reach when firing. Default 0 for melee mobs that don't fire.
   viFireRange = 0

   // All monsters use BRAIN_ORIGINAL for now.
   viBrain_type = BRAIN_ORIGINAL

   // Bitvector for monster/NPC behaviors. This variable contains the flags
   // monsters use for determining combat/aggro behavior.
   viDefault_behavior = 0

   viCashmin = 1
   viCashmax = 10

   // Bonus spellpower. Default is based on mysticism and intellect.
   viSpellPower = 0

   // Monster cast at a percentage of power relative to regular player spells.
   // If viPowerLevel is nil, powerlevel is computer based on mysticism,
   // intellect and monster level.
   viPowerLevel = $

   // Percentage chance to do an extra swing. 150 means a guaranteed 2nd
   // swing as well as a 50 percent chance to swing thrice.
   viBonusSwing = 0

   // Percentage chance to do an extra shot.
   viBonusShot = 0

   // Percentage chance to do an extra spin.
   viBonusSpin = 0

   viWimpy = 0

   // Aquatic mobs don't mind getting their feet wet while strolling.
   vbAquatic = FALSE

   // Trools can rally to a flag pole.
   vbCanRally = FALSE

   // How likely are monster to try and chat others up and how likely are they
   // to mind their own business? Takes values between 0 and 100.
   // 0 will always walk alone, 100 will always look for others.
   // Unsocial monsters will also not come to their allies help.
   viSocial = 50

   // Some monsters classes may inherently have higher (or lower) stats.
   viBonusAgility = 0
   viBonusAim = 0
   viBonusMight = 0
   viBonusStamina = 0
   viBonusIntellect = 0
   viBonusMysticism = 0

   // Some monster classes may inherently have more (or less) resources.
   viBonusHealth = 0
   viBonusMana = 0
   viBonusVigor = 0
   viBonusArmor = 0

   // Some monster classes may cause drain effects or poison their enemy.
   viPoisonChance = 0
   viPoisonStrength = $
   viPoisonDuration = $
   viPoisonVisualEffect = $
   viPoisonVisualEffectDuration = 0
   vrPoisonVisualEffectMessage = $
   // Percentage of poison strength affecting each resource.
   viPoisonHealth = 100
   viPoisonMana = 0
   viPoisonVigor = 0
   viBleedChance = 0
   viBleedStrength = $
   viBleedDuration = $
   viSiphonChance = 0
   viSiphonStrength = $
   viSiphonDuration = $
   viFatigueChance = 0
   viFatigueStrength = $
   viFatigueDuration = $
   viBurnChance = 0
   viBurnStrength = $
   viBurnDuration = $

   // Some monsters are immune to certain drain effects.
   vbCanPoison = TRUE
   vbCanBleed = TRUE
   vbCanSiphon = TRUE
   vbCanFatigue = TRUE
   vbCanBurn = TRUE

   vbCanSeduce = TRUE

   // If true, items that are sold actually come out of the monster's
   // inventory. If false, the items in the inventory are inexhaustible
   // templates, and copies are sold.
   vbSellFromInventory = FALSE

   vrCondition_healthy = Lm_condition_healthy
   vrCondition_good = Lm_condition_good
   vrCondition_fair = Lm_condition_fair
   vrCondition_poor = Lm_condition_poor
   vrCondition_bad = Lm_condition_bad
   vrFirst_damage_level = Lm_first_damage_level
   vrSecond_damage_level = Lm_second_damage_level
   vrThird_damage_level = Lm_third_damage_level
   vrFourth_damage_level = Lm_fourth_damage_level
   vrFirst_heal_level = Lm_first_heal_level
   vrSecond_heal_level = Lm_second_heal_level
   vrThird_heal_level = Lm_third_heal_level
   vrFourth_heal_level = Lm_fourth_heal_level
   vrParty_killed_monster = Lm_party_killed_monster
   vrParty_monster_died_to_dot = Lm_party_monster_died_to_dot

   vrTeach_message = monster_iteach
   vrTeach_nothing = monster_teachnothing
   vrUnwanted_keep = LS_unwanted_keep
   vrUnwanted_pay = LS_unwanted_pay
   vrUnwanted_give = LS_unwanted_give
   vrUnwanted_token = LS_unwanted_token
   vrTeach_quest_needed = monster_teach_quest_needed
   vrNothing_for_sale = Lm_nothing_for_sale
   vrMrcnt_too_costly = Lm_mrcnt_too_costly
   vrMinion_trouble = minion_trouble

   vrIllusionPoison = monster_illusion_poison
   vrIllusionBleed = monster_illusion_bleed
   vrIllusionSiphon = monster_illusion_siphon
   vrIllusionFatigue = monster_illusion_fatigue
   vrIllusionBurn = monster_illusion_burn

   vrMercenaryJoin = Lm_mercenary_join
   vrMercenaryJoinContracted = Lm_mercenary_join_contracted
   vrMercenaryLeave = Lm_mercenary_leave

   // Obsolete, but still included here for safety's sake.
   vrSound_hit = $
   vrSound_miss = $
   vrSound_aware = $
   vrSound_death = $
   viDead_drawfx = 0
   vrProjectile_icon = monster_projectile_icon
   viProjectileSpeed = 8

   viFaction = FACTION_NEUTRAL

   vbIsAreaEffect = FALSE

   // What are the monster's priorities regarding basic actions?
   viMeleePriority = 600
   viMovePriority = 500
   viFirePriority = 550
   vbSpin = FALSE
   viSpinAnimationTime = 100

   // How well can the monster see in the dark? Default: 5
   // Counteracts low room light level (0-255)
   viNightVision = 5

   // If nil, chase range is based on vision range.
   // Else, takes regular full units.
   viChaseRange = $

   viBonusXP = 0
   viBonusTP = 0

properties:

   piVisionDistance
   piMeleeRange
   piFireRange
   piAnimation = ANIM_NONE

   // List of the mobs wanted items.
   plWantedItems = $
   // List of items offered to the player by buyer.
   plOffer_items = $
   // List of items offered to the player by seller.
   // [item list, skill list, spell list, conditional items (?)]
   plFor_sale = $

   ptCancelOffer = $
   ptRandom = $
   ptSpasm = $

   // Who we are dealing with.
   poCustomer = $

   poBrain = $

   piBadSteps = 0
   piTargetLocationRow
   piTargetLocationCol
   piTargetLocationFineRow = 0
   piTargetLocationFineCol = 0
   piPatrolAttempts = 0
   plPatrolPath = $
   piPatrolNode = 0
   // chance to move to next patrol node (1 to 10000)
   piChanceToPatrol = 125

   //// The Monster State Meta-Object

   // These should be modified only by the EnterStateX routines
   // Who to chase or attack
   poTarget = $
   // Bitvector of personality and mutable behavior
   piState = 0
   // Either chasing, moving, or attacking
   ptBehavior = $
   // Behavior flags = have prefix of AI_
   // All mobs will loop through a patrol path, if one is available.
   piBehavior = AI_LOOPING_PATROL
   // Who is our master, if we have one.
   poMaster = $
   // Who is our leader, if we have one.
   poLeader = $
   // Player who has turned us.
   poHolySymbolCaster = $
   // Timer to expire turning.
   ptUnturn = $
   piHatred = 0
   // Emulates combat stats for monsters based on difficulty.
   piAgility = 25
   piAim = 25
   piMight = 25
   piStamina = 25
   piIntellect = 25
   piMysticism = 25

   piEnch_flags = 0

   piDrawfx = 0

   // A list of quest nodes for which this monster is the destination NPC
   plActiveQuestNodes = $

   //// Monster flags that keep track of irregularities in a mobs existence.
   //// If a monster has any of the flags below, it won't count towards the
   //// room's monster count.
   // Mob is an illusion.
   pbIllusion = FALSE
   // Mob has been summoned.
   vbSummoned = FALSE
   // Mob belongs to a predefined spawn event. (e.g. mummies in trasure room)
   pbEvent = FALSE

   // Apparition object (caster)
   poApparitionCaster = $

   // Should this monster stick around through a call to DestroyDisposable()?
   pbDontDispose = FALSE

   piMood = 0

   // list of keyed speechlib items [class, key] triggered since last
   //  RandomTimer firing
   plSpamList = $

   piColor_Translation = 0

   piSweepCounter = 0

   // List of spells this monster can cast. Has the format:
   plActions = $

   // Monster's spellpower.
   piSpellPower = 50

   piOffense = $
   piDefense = $
   piMinDamage = $
   piMaxDamage = $

   piArmor = 0

   // Was this monster boosted by a Survival Room?
   piBoostedLevel = 0

   piLastTimeAttacked = 0
   poLastAttacker = $

   // some monsters are created on the fly (ex: avar) we may need to set this at
   // runtime
   piReputationGroup = REP_NEUTRAL
   plReputationEnemies = $

   // 20 seconds default for players, 60 for monsters
   piHurtMeTime = 60000

   // Handles any delayed combat animations, such as multiple hits
   // or spinning.
   piAction = 0
   ptAction = $

   // Allows tracing a monster to its generator.
   // $ if not spawned on a generator. If spawned by a generator (or as part
   // of a boss encounter: piSpawnLoc = IIIRRRCCC
   // III: Index of the Generator or Boss Spawn
   // RRR: Row of the spawn   CCC: Col of the spawn.
   piSpawnLoc = $

   // Mobs may acquire a trigger object in a room that they can interact with.
   poObject = $

messages:

   Constructor(template=FALSE,color=0,piSurvivalLevel=0,iBrain=0,bEvent=FALSE)
   "Simple enough, we create a monster. If they are questworthy, we note it."
   {
      // Creates stats based on a mobs viDifficulty and randomization.
      Send(self,@CreateStats,#template=template);

      // Sets a mobs derived stats such as resources based on stats.
      Send(self,@SetResources,#piSurvivalLevel=piSurvivalLevel);

      if Send(self,@MobIsSeller)
      {
         Send(self,@SetForSale);
      }

      if Send(self,@MobIsCondSeller)
      {
         Send(self,@InitCondSale);
      }

      if (viDefault_behavior & AI_NPC) = AI_NPC
      {
         Send(Send(SYS,@GetLibrary),@AddNPC,#who=self);
      }

      if viOccupation <> 0
         AND NOT template
      {
         // template set to TRUE means this monster is in the System
         // monster template list, so we shouldn't add it.
         Send(Send(SYS,@GetLibrary),@AddToOccupationList,#who=self);
      }

      Send(self,@TryAddToLibrary);

      if (iBrain > 0 AND iBrain <= BRAIN_MAX_NUM)
      {
         poBrain = Send(SYS,@FindBrainByNum,#num=iBrain);
      }
      else
      {
         poBrain = Send(SYS,@FindBrainByNum,#num=viBrain_type);
      }

      piState &= ESTATE_ZERO_MASK;
      Send(poBrain,@MobConstructor,#mob=self);

      piEnch_flags = 0;

      Send(self,@ClearActiveQuests);
      Send(self,@ResetBehaviorFlags);

      piMood = 0;

      if color <> 0
      {
         piColor_translation = color;
      }

      pbEvent = bEvent;

      // Start timers...
      Send(self,@NewVigor);

      propagate;
   }

   CreateStats(template=FALSE)
   {
      local iStatPoints, iRandom, iTotal, iDiff, lTemp, lStats, i;

      // Creating random stats. Currently 6 stats, if you want to add more,
      // change i to a different number and assign accordingly below.
      i = 6;

      // The total amount of stat points distributed. A couple points may
      // by lost to truncation in the process, but (carelevel << carethreshold)
      iStatPoints = Bound(viDifficulty + 1,1,10) * 5 * i;
      iTotal = 0;
      iDiff = 0;

      // Create a stat list with random entries between 1 and 50
      while i-- > 0
      {
         iRandom = Random(1,50);
         lStats = Cons(iRandom,lStats);
         iTotal += iRandom;
      }

      // Scale stats so they approach the desired stat total.
      // Crop stats that exceed 50 points. Sum up extra points.
      foreach i in lStats
      {
         i = i * iStatPoints / iTotal;
         if i > 50
         {
            iDiff += i-50;
            i = 50;
         }

         lTemp = Cons(i,lTemp);
      }

      lStats = $;

      // Distribute leftover points across needy stats.
      foreach i in lTemp
      {
         if i < 50
         {
            i += iDiff;
            iDiff = Bound(i - 50,0,$);
            if iDiff > 0
            {
               i = 50;
            }
         }

         lStats = Cons(i,lStats);
      }

      lTemp = $;

      // Below: Assign values to stats with a lil shake up.
      // Also add any bonus values if applicable.
      while Length(lStats) > 0
      {
         iRandom = Random(1,Length(lStats));
         lTemp = Cons(Nth(lStats,iRandom),lTemp);
         lStats = DelListElem(lStats,Nth(lStats,iRandom));
      }

      // No randomization for templates, just straight values scaled with viDifficulty.
      if template
      {
         piAgility = Bound((viDifficulty+1)*5+viBonusAgility,1,MONSTER_STAT_CAP);
         piAim = Bound((viDifficulty+1)*5+viBonusAim,1,MONSTER_STAT_CAP);
         piMight = Bound((viDifficulty+1)*5+viBonusMight,1,MONSTER_STAT_CAP);
         piStamina = Bound((viDifficulty+1)*5+viBonusStamina,1,MONSTER_STAT_CAP);
         piIntellect = Bound((viDifficulty+1)*5+viBonusIntellect,1,MONSTER_STAT_CAP);
         piMysticism = Bound((viDifficulty+1)*5+viBonusMysticism,1,MONSTER_STAT_CAP);
      }
      else
      {
         piAgility = Bound(First(lTemp)+viBonusAgility,1,MONSTER_STAT_CAP);
         piAim = Bound(Nth(lTemp,2)+viBonusAim,1,MONSTER_STAT_CAP);
         piMight = Bound(Nth(lTemp,3)+viBonusMight,1,MONSTER_STAT_CAP);
         piStamina = Bound(Nth(lTemp,4)+viBonusStamina,1,MONSTER_STAT_CAP);
         piIntellect = Bound(Nth(lTemp,5)+viBonusIntellect,1,MONSTER_STAT_CAP);
         piMysticism = Bound(Nth(lTemp,6)+viBonusMysticism,1,MONSTER_STAT_CAP);
      }

      return;
   }

   SetResources(piSurvivalLevel=0)
   {
      // Health
      piMax_health = viLevel * Bound(80 + piStamina,$,120) / 100
                     + piSurvivalLevel * viDifficulty + viBonusHealth;
      piMax_health = Bound(piMax_health,1,$);
      piHealth = piMax_health * 100;

      // Mana
      piMax_mana = piMysticism * 2 + viBonusMana;
      piMana = piMax_mana * 100;

      // Vigor
      piMax_vigor = 100 + piStamina * 2 + viBonusVigor;
      piVigor_rest_threshold = 40 + piStamina * 4 / 5 + viBonusVigor / 2;
      piVigor = Random(piVigor_rest_threshold,piMax_vigor) * 100;

      piMeleeRange = viMeleeRange;
      piFireRange = viFireRange * (75 + piAim) / 100;
      piSpellPower = Bound((piIntellect + piMysticism) / 2, 25, 50) + viSpellPower;
      piVisionDistance = viVisionDistance + piSurvivalLevel + (piIntellect + piAim) / 20;
      piChanceToPatrol = 50 + piAgility + piStamina;
      piBoostedLevel = piSurvivalLevel;

      if piSurvivalLevel > 0
      {
         piOffense = Send(self,@GetOffense) + piSurvivalLevel * viDifficulty;
         piDefense = Send(self,@GetDefense) + piSurvivalLevel * viDifficulty;
         piMinDamage = viLevel / 15 + piSurvivalLevel / 2;
         piMaxDamage = viLevel / 10 + piSurvivalLevel / 2;
         piArmor = piSurvivalLevel / 5;
      }

      return;
   }

   Constructed()
   {
      local lActions, lTemp, i, oSpell;

      // Any entry in the monster's spell book needs to have the
      // following form: [SID,Mana,Vigor,Range,Priority,P-Factor,SP].
      // SID: Spell ID (e.g. SID_SPLASH_OF_ACID)
      // Mana: Cost of the spell, NOT in precision mode (e.g. 4)
      // Vigor: Cost of the spell, NOT in precision mode (e.g. 1)
      // Range: Squared fine range of the spell (e.g. (3x64)^2 = 36.864)
      // Priority: Mobs will choose spells with higher priority.
      // P-Factor: Factor that determines how much priority an action
      // loses after each use.
      // SP: Spellpower the spell contributes. Additive to monster SP.
      lActions = ListCopy(plActions);
      plActions = $;

      foreach i in lActions
      {
         // We recognize list lengths of 1,4 and 7. If we get anything
         // else, skip and move on.
         // Nothing provided but the spell...
         if Length(i) = 1
         {
            oSpell = Send(SYS,@FindSpellByNum,#num=First(i));
            i = [First(i),
                 Send(oSpell,@GetMonsterManaCost)*100,
                 Send(oSpell,@GetMonsterExertion)*100,
                 Send(oSpell,@GetSquaredRange),
                 Send(oSpell,@GetStartingPriority),
                 Send(oSpell,@GetPriorityAdjustment),
                 Bound(Random(viDifficulty*3,viDifficulty*6),1,49),
                 Send(oSpell,@GetCombatType)];
         }
         // Spell, priority, P-factor and spellpower provided.
         if Length(i) = 4
         {
            oSpell = Send(SYS,@FindSpellByNum,#num=First(i));
            i = [First(i),
                 Send(oSpell,@GetMonsterManaCost)*100,
                 Send(oSpell,@GetMonsterExertion)*100,
                 Send(oSpell,@GetSquaredRange),
                 Nth(i,2),
                 Nth(i,3),
                 Nth(i,4),
                 Send(oSpell,@GetCombatType)];
         }
         // At this stage, our list should have 8 entries. If it
         // doesn't, skip.
         if  Length(i) = 8
         {
            plActions = Cons(i,plActions);
         }
      }

      // Add default actions to the list:
      // Movement.
      lTemp = [SKID_MINIMUM,0,20,MAX_KOD_INT,viMovePriority,0,100,COMBAT_ACTION_NEUTRAL];
      plActions = Cons(lTemp,plActions);

      // Melee attacks.
      if (GetListNode(plActions, 1, SKID_SLASH) = $)
      {
         lTemp = [SKID_SLASH,0,100,piMeleeRange*piMeleeRange,viMeleePriority,0,100,COMBAT_ACTION_HARM];
         plActions = Cons(lTemp,plActions);
      }

      // Only add fire, if we can attack at range.
      if piFireRange > 0
      {
         if (GetListNode(plActions, 1, SKID_FIRE) = $)
         {
            lTemp = [SKID_FIRE,0,100,piFireRange*piFireRange,viFirePriority,0,100,COMBAT_ACTION_HARM];
            plActions = Cons(lTemp,plActions);
         }
      }

      // Only add spin, if we have an area effect attack.
      if vbSpin
      {
         if (GetListNode(plActions, 1, SKID_SPIN) = $)
         {
            lTemp = [SKID_SPIN,0,500,piMeleeRange*piMeleeRange,viMeleePriority+1,0,75,COMBAT_ACTION_HARM];
            plActions = Cons(lTemp,plActions);
         }
      }

      // Check if the monster starts out socializing or minding their own business.
      if Random(1,100) <= viSocial
      {
         piBehavior |= AI_SOCIALIZER;
      }

      propagate;
   }

   AddCombatAction(iNum=0)
   {
      local oSpell, lSpell;

      if (iNum > 0)
         AND NOT Send(self,@MonsterHasAbility,#iNum=iNum)
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=iNum);
         lSpell = [iNum,
                   Send(oSpell,@GetMonsterManaCost)*100,
                   Send(oSpell,@GetMonsterExertion)*100,
                   Send(oSpell,@GetSquaredRange),
                   Send(oSpell,@GetStartingPriority),
                   Send(oSpell,@GetPriorityAdjustment),
                   Bound(Random(viDifficulty*3,viDifficulty*6),1,49),
                   Send(oSpell,@GetCombatType)];

         plActions = Cons(lSpell,plActions);

         return TRUE;
      }

      return FALSE;
   }

   RemoveCombatAction(iNum=0)
   {
      local i;

      foreach i in plActions
      {
         if (First(i) = iNum)
         {
            plActions = DelListElem(plActions,i);

            return TRUE;
         }
      }

      return FALSE;
   }

   SetPatrolPath(lPath = $)
   {
      if (lPath <> $)
      {
         plPatrolPath = lPath;
         Send(self,@SetBehaviorFlag,#flag=AI_CAN_PATROL,#value=TRUE);
      }

      return;
   }

   GetKocName()
   {
      return vrKocName;
   }

   IsNamedMob()
   {
      return vbNamedMob;
   }

   // Overridden for specific NPCs,
   // common point for mood changes, except word triggers
   AffectMood( why = $, what = $ )
   {
      return;
   }

   ClearActiveQuests()
   {
      plActiveQuestNodes = $;

      if (poOwner <> $)
      {
         Post(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   // This monster is the destination NPC for a questnode
   // Add the node to his list, so he can check completion criteria
   //  when someone enters, says something, or gives him something
   AddQuestNodeToActiveList(node = $, type = $)
   {
      local i, iCount;

      if node = $
      {
         Debug("AddQuestNode: nil questnode.");

         return;
      }

      // Sort list by adding nodes with questers to front and showup-type
      // quests to back. Insert other quest types after quests with active
      // questers.
      if (plActiveQuestNodes = $
         OR Send(node,@GetQuesters) <> $)
      {
         plActiveQuestNodes = Cons(node, plActiveQuestNodes);
      }
      else if (type <> $ AND type = QN_TYPE_SHOWUP)
      {
         plActiveQuestNodes = AppendListElem(node, plActiveQuestNodes);
      }
      else
      {
         iCount = 1;
         foreach i in plActiveQuestNodes
         {
            if (Send(node,@GetQuesters) = $)
            {
               break;
            }
            ++iCount;
         }
         plActiveQuestNodes = InsertListElem(plActiveQuestNodes, iCount, node);
      }

      if (poOwner <> $)
      {
         Post(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }
 
   // Remove the questnode from this NPCs list
   RemoveQuestNodeFromActiveList(node = $)
   {
      local iLength, oActiveNode;

      if node = $
      {
         Debug("RemoveQuestNode: nil questnode.");

         return;
      }

      // Save original Length for validation
      iLength = Length( plActiveQuestNodes );

      foreach oActiveNode in plActiveQuestNodes
      {
         if oActiveNode = node
         {
            plActiveQuestNodes = DelListElem(plActiveQuestNodes,oActiveNode);
         }
      }

      if (poOwner <> $)
      {
         Post(poOwner,@SomethingChanged,#what=self);
      }

      // validate that we removed it
      if iLength > Length(plActiveQuestNodes)
      {
         return;
      }

      Debug( "RemoveQuestNode: couldn't find questnode." );

      return;
   }

   GetActiveQuestForUser(who = $, index = 0)
   "Preferentially return the quest node the user is on. If they haven't "
   "started the quest yet, return a free one.  Have to iterate the whole "
   "list to make sure we don't have one with the player already assigned."
   {
      local i, oQN;

      foreach i in plActiveQuestNodes
      {
         if (Send(i,@GetQuestTemplateIndex) = index)
         {
            if (Send(i,@IsPlayerQuester,#who=who))
            {
               return i;
            }
            else if (Send(i,@IsQuestOpenForPlayer,#who=who))
            {
               oQN = i;
            }
         }
      }

      return oQN;
   }

   HasQuestsForUser(who = $)
   {
      local i;

      if (who = $
         OR NOT IsClass(who,&User))
      {
         return FALSE;
      }

      foreach i in plActiveQuestNodes
      {
         if (Send(i,@CanPlayerStartQuest,#who=who))
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   IsQuestableForUser(who = $)
   {
      local i, lQuests, oQT, lQT;

      if (who = $
         OR NOT IsClass(who,&User))
      {
         return FALSE;
      }

      foreach i in plActiveQuestNodes
      {
         oQT = Send(i,@GetQuestTemplateObject);

         // Skip quests that already have someone else doing them.
         if (NOT Send(i,@IsQuestOpenForPlayer,#who=who))
         {
            continue;
         }

         // Only true for quests that the player is already doing, or could
         // possibly be eligible for.
         if (Send(i,@IsPlayerQuester,#who=who)
            OR Send(i,@CanPlayerEverStartQuest,#who=who))
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   GetQuestsForUser(who = $)
   "Must remove quests waiting for other players, but can leave in quests that "
   "are waiting for any player with this player not meeting the requirements."
   "Returns a list of [quest template object, quest node object]."
   {
      local i, lQuests, oQT, lQT;

      if (who = $
         OR NOT IsClass(who,&User))
      {
         return FALSE;
      }

      foreach i in plActiveQuestNodes
      {
         oQT = Send(i,@GetQuestTemplateObject);

         // Skip quests that already have someone else doing them.
         if (NOT Send(i,@IsQuestOpenForPlayer,#who=who))
         {
            continue;
         }

         // Only show quests that the player is already doing, or could
         // possibly be eligible for.
         if (Send(i,@IsPlayerQuester,#who=who)
            OR Send(i,@CanPlayerEverStartQuest,#who=who))
         {
            lQuests = Cons([oQT, i],lQuests);
         }
      }

      return lQuests;
   }

   TryAddToLibrary()
   "Adds the NPC to the library's random NPC lists, which are used as "
   "defaults for quests and other things, e.g. signet rings. Some NPCs "
   "should have chatter and random triggers, but should not be part of "
   "the game's quest system.  This procedure should be overwritten "
   "for them to return FALSE."
   {
      if (viAttributes & MOB_RANDOM) AND (viAttributes & MOB_LISTEN)
      {
         Send(Send(SYS,@GetLibrary),@AddToSignetNPCList,#who=self);
         if (viAttributes & MOB_RECEIVE) OR (viAttributes & MOB_BUYER)
         {
            Send(Send(SYS,@GetLibrary),@AddToRandomNPCList,#who=self);
         }

         return TRUE;
      }

      return FALSE;
   }

   Delete()
   "End of monster. Clean up any quests it might have spawned."
   {
      local i, j, k;

      // Minion Management - upon dying they should leave your control list
      if poMaster <> $
      {
         Send(poMaster,@RemoveControlledMinion,#what=self);
      }

      // Tell the leader of our demise - so that he may replace us. Sucks.
      if poLeader <> $
      {
         Send(self,@SetLeader,#report=FALSE);
      }

      // Enchantments must be removed before brain gets set to $.
      Send(self,@RemoveAllEnchantments);

      // Same goes for over time effects.
      Send(self,@DeleteAllOverTimeEffects);

      // If this monster is an Apparition, tell the original it was deleted.
      if poApparitionOriginal <> $
      {
         Send(poApparitionOriginal,@RemoveApparition,#what=self);
         poApparitionOriginal = $;
         poApparitionCaster = $;
      }

      // Under rare conditions delete is called twice in succession
      if poBrain <> $
      {
         Send(poBrain,@MobDelete,#mob=self,#state=piState);
         poBrain = $;
      }

      Send(self,@ClearBehavior);
      Send(self,@ClearBasicTimers);

      if (viDefault_behavior & AI_NPC) = AI_NPC
      {
         Send(Send(SYS,@GetLibrary),@RemoveNPC,#who=self);
      }

      if (plFor_sale <> $)
      {
         Send(self,@DeleteForSaleList);
      }

      if (viAttributes & MOB_RANDOM)
      {
         Send(Send(SYS,@GetLibrary),@DeleteFromSignetNPCList,#who=self);
         if (viAttributes & MOB_LISTEN)
            AND (viAttributes & MOB_RECEIVE)
         {
            Send(Send(SYS,@GetLibrary),@DeleteFromRandomNPCList,#who=self);
         }
      }

      Send(Send(SYS,@GetLibrary),@DeleteFromOccupationList,#who=self);

      foreach i in plWantedItems
      {
         if i = &SignetRing
         {
            foreach j in Send(Send(SYS,@GetLibrary),@GetSignetRings)
            {
               if Send(j,@GetRingOwner) = self
               {
                  Send(Send(SYS,@GetLibrary),@UnregisterSignet,#newring=j);
                  Send(j,@Delete);
               }
            }
         }
      }

      plActions = $;
      poMaster = $;
      poObject = $;
      poHolySymbolCaster = $;

      if ptUnturn <> $
      {
         DeleteTimer(ptUnturn);
         ptUnturn = $;
      }

      if ptAction <> $
      {
         DeleteTimer(ptAction);
         ptAction = $;
      }

      poLastAttacker = $;

      propagate;
   }

   // For illusionary form, it makes a bunch of monsters so it can call 'em and
   //  get access to their SendAnimation() things.  To be useful, it needs to
   //  be able to set our piAnimation (to either ANIM_NONE or ANIM_ATTACK, which
   //  work for all monsters).

   SetAnimation(animation = $)
   {
      piAnimation = animation;

      return;
   }

   //// Enchantments of Monsters

   EnchantmentTimer(timer = $)
   {
      local i;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            if Length(i) > ENCHANTMENT_LIST_NO_STATE
            {
               Send(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@EndEnchantment,#who=self);
            }

            plEnchantments = DelListElem(plEnchantments,i);

            return;
         }
      }

      propagate;
   }

   StartEnchantment(what = $,time = $,state=$, iSpellPower = 0,
                    lastcall = TRUE, bRadiusEnchant = FALSE)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ OR time = SPELL_INDEFINITE_DURATION 
      {
         oTimer = $;
      }
      else if lastcall
      {
         oTimer = CreateTimer(self,@EnchantmentTimer,time);
      }
      else
      {
         oTimer = CreateTimer(self,@PeriodicEnchantmentTimer,time);
      }

      if state <> $
      {
         lNew_enchantment = [ oTimer, what, state, iSpellPower ];
      }
      else
      {
         lNew_enchantment = [ oTimer, what, iSpellPower ];
      }

      if (bRadiusEnchant)
      {
         plRadiusEnchantments = Cons(lNew_enchantment,plRadiusEnchantments);
      }
      else
      {
         plEnchantments = Cons(lNew_enchantment,plEnchantments);
      }

      return;
   }

   RemoveAllEnchantments()
   "Remove all current enchantments."
   {
      local i;

      foreach i in plEnchantments
      {
         Send(self,@RemoveEnchantment,#what=Nth(i,2));
      }
      
      foreach i in plRadiusEnchantments
      {
         Send(self,@RemoveRadiusEnchantment,#what=Nth(i,2),#state=Nth(i,3));
      }

      plRadiusEnchantments = $;

      return;
   }

   RemoveEnchantment(what = $)
   "If have a current enchantment set by <what>, end it."
   {
      local i, state;

      state = $;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if First(i) <> $
            {
               if IsTimer(First(i))
               {
                  DeleteTimer(First(i));
               }
            }
            SetFirst(i,$);

            if Length(i) > ENCHANTMENT_LIST_NO_STATE
            {
               Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,
                    #state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self);
            }

            plEnchantments = DelListElem(plEnchantments,i); 
         }
      }

      return;
   }

   ////  State Transition Functions
   
   EnterStateLimbo()
   {
      // SetTarget without a 'what' passed sets target to nil.
      if (poTarget <> $)
      {
         Send(self,@SetTarget);
      }

      Send(self,@SetState,#bit=STATE_LIMBO);

      Send(self,@ClearBehavior);

      // Unset our resting flag.
      piBattlerFlags &= ~BFLAG_RESTING;

      piHatred = 0;

      // The whole point of the limbo state is that there are no timers to set.

      return;
   }

   // Note: mobs shouldn't be in STATE_WAIT if they don't have an owner.
   // Mobs with $ owner should ideally be in STATE_LIMBO.
   EnterStateWait(actnow=FALSE,delay=MOB_MOVE_TIMER_WAIT)
   {
      // Some things post EnterStateWait so that the effects take place after
      // the call chain finishes, but we should discard that if the mob died
      // somewhere further in the call chain.
      // Example: mob killed with Mark of Dishonor weapon, spell is cast during
      // the damage calculation process (maybe not ideal?) but before the mob
      // actually dies. MoD posts EnterStateWait which is called here after
      // the mob is already dead.
      if (poOwner = $)
      {
         return;
      }

      // SetTarget without a 'what' passed sets target to nil.
      if (poTarget <> $)
      {
         Send(self,@SetTarget);
      }

      Send(self,@SetState,#bit=STATE_WAIT);

      Send(self,@ClearBehavior);

      piHatred = 0;

      if delay = $
      {
         return;
      }

      if actnow
      {
         Send(self,@WaitTimer);
      }
      else
      {
         ptBehavior = CreateTimer(self,@WaitTimer,delay);
      }

      return;
   }

   EnterStateMove(actnow=FALSE)
   {
      // SetTarget without a 'what' passed sets target to nil.
      if (poTarget <> $)
      {
         Send(self,@SetTarget);
      }

      // Note: All monsters "move" even the ones who physically can't.
      Send(self,@SetState,#bit=STATE_MOVE);

      Send(self,@ClearBehavior);

      piHatred = 0;

      if actnow
      {
         Send(self,@MoveTimer);
      }
      else
      {
         ptBehavior = CreateTimer(self,@MoveTimer,Send(self,@GetMoveTime));
      }

      return;
   }

   EnterStateEngage( target = $, actnow = TRUE, delay = 0)
   {
      if poTarget <> target AND vrSound_aware <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=vrSound_aware,
              #flags=SOUND_RANDOM_PITCH);
      }

      Send(self,@SetState,#bit=STATE_ENGAGE);
      Send(self,@ClearBehavior);

      // Unset our resting flag.
      piBattlerFlags &= ~BFLAG_RESTING;

      // If we have a leader and we are about to smack him, it's probably
      // a good time to tell him that we are no longer convinced of his
      // leadership.
      if target = poLeader
      {
         // SetLeader sets leader to nil if none is passed.
         Send(self,@SetLeader,#report=FALSE);
      }

      if actnow
      {
         Send(self,@EngageTimer);
      }
      else
      {
         ptBehavior = CreateTimer(self,@EngageTimer,delay);
      }

      return;
   }

   EnterStateRest(delay = 0)
   {
      Send(self,@SetState,#bit=STATE_REST);
      Send(self,@ClearBehavior);

      ptBehavior = CreateTimer(self,@RestTimer,delay);

      return;
   }

   //// Sensory Inputs
   
   NewOwner(what = $)
   "Monster just entered this room. Right now, thats only possible on a"
   "creation. So, lets pause for a few beats if we got users."
   {
      if what = $
      {
         Send(self,@ClearBasicTimers);

         propagate;
      }

      // Mobs can change owner, i.e. wanderers. This lets them react properly
      // to leaving a room with users and arriving in a room without them.
      if poOwner <> $
         AND Send(poOwner,@IsUserInRoom)
         AND NOT Send(what,@IsUserInRoom)
      {
         Post(self,@LastUserLeft);
      }

      if Send(what,@IsUserInRoom)
      {
         Send(self,@StartBasicTimers);
      }

      Send(poBrain,@NewOwner,#mob=self,#state=piState,#what=what);

      propagate;
   }

   FirstUserEntered(what = $,new_row = $,new_col = $)
   "Since we've already been notified in SomethingEntered that a user got"
   "here, we have already handled the case that the user was plunked down"
   "near a non-fighting and agressive mob. So, lets just start our timers."
   {
      if ((piState & STATE_LIMBO)
         OR (piBehavior & AI_NPC))
      {
         Send(self,@StartBasicTimers);
      }

      Send(poBrain,@FirstUserEntered,#mob=self,#state=piState,
           #what=what,#new_row=new_row,#new_col=new_col);

      propagate;
   }

   LastUserLeft()
   "All our users just left, so lets stop all our timers. If we were a"
   "seller of some conditional goods, we hide them again so the next"
   "set of players has to ask for them by name."
   {
      local i;

      Send(self,@ClearBasicTimers);

      if Send(self,@MobIsCondSeller)
      {
         foreach i in Nth(plFor_sale,4)
         {
            Send(self,@RemoveFromConditionalList,#obj=First(i));
         }
      }

      Send(poBrain,@LastUserLeft,#mob=self,#state=piState);

      propagate;
   }
   
   SomethingMoved(what=$,new_row=$,new_col=$,fine_row=$,fine_col=$)
   "Check to see if we need to change our combat plan because someone moved."
   {
      // If either we or our target moved, then we no longer know 
      //  if the attack is valid.
      if what = self OR what = poTarget
      {
         piState &= VSTATE_VALIDITY_MASK;
      }

      if poBrain <> $
      {
         Send(poBrain,@SomethingMoved,#mob=self,#state=piState,
               #what=what,#new_row=new_row,#new_col=new_col,
               #fine_row=fine_row,#fine_col=fine_col);
      }

      propagate;
   }

   SomethingAttacked(what = $,victim = $,use_weapon = $)
   "Something in the room has been attacked. We might want to respond"
   "by defending ourselves or our allies."
   {
      if poBrain <> $
      {
         Send(poBrain,@SomethingAttacked,#mob=self,#state=piState,
               #what=what,#victim=victim,#use_weapon=use_weapon);
      }

      propagate;
   }

   SomethingHelped(what = $, target = $, oSpell = $, iAmount = 0)
   "Something in the room has helped someone. We might want to respond"
   "by aiding them or dispatching of them pesky healers."
   {
      if poBrain <> $
      {
         Send(poBrain,@SomethingHelped,#mob=self,#state=piState,
               #what=what,#target=target,#oSpell=oSpell,#iAmount=iAmount);
      }

      propagate;
   }

   RecordTimeAttacked(who=$)
   "This records the last time the monster attacked someone, "
   "and the player or monster it attacked."
   {
      local oMaster;

      piLastTimeAttacked = GetTickCount();

      poLastAttacker = who;

      return;
   }

   GetTimeAttacked()
   {
      return piLastTimeAttacked;
   }

   GetLastAttacker()
   {
      return poLastAttacker;
   }

   CanAttackNow()
   {
      return Abs(piLastTimeAttacked - GetTickCount()) > Send(self,@GetAttackTime);
   }

   SomethingEntered(what = $,where=$)
   {
      local oQuestNode;

      Send(poBrain,@SomethingEntered,#mob=self,#state=piState,
           #what=what,#where=where);

      // Check if it was this mob's temporary owner.
      Send(self,@MobSeduceCheck,#what=what);

      // If there are active quest nodes, notify them -AJM
      /*if plActiveQuestNodes <> $
      {
         // make sure it's a player who entered
         if IsClass(what,&Player)
         {
            foreach oQuestNode in plActiveQuestNodes
            {
               if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what)
               {
                  return;
               }
            }
         }
      }*/

      propagate;
   }

   SomethingLeft(what = $, iRow=0, iCol=0)
   "We lost someone, perhaps we need to clear our targets."
   {
      local cClass;

      // Apparitions are dispelled if the caster or original target leave.
      if ((poApparitionCaster <> $ AND what = poApparitionCaster)
            OR (poApparitionOriginal <> $ AND what = poApparitionOriginal))
      {
         Send(self,@Delete);

         return;
      }

      // Our master may have left.  If he did, and he is close by,
      // teleport after him.
      if poMaster <> $ AND what = poMaster
      {
         cClass = GetClass(self);

         if iRow <> 0 AND iCol <> 0
            AND Send(poMaster,@GetOwner) <> $
         {
            if ((piRow - iRow) <= 3
               AND (piCol - iCol) <= 3
               AND NOT (cClass = &EvilTwin
                  AND (NOT Send(self,@IsEnchanted,#byClass=&Seduce))))
               OR cClass = &Reflection // Flecs follow.
               OR vbIsUndead // So do undead (Animate).
            {
               Post(self,@GotoMaster);
            }
         }
      }

      // Our leader may have left.
      if poLeader <> $ AND what = poLeader
      {
         // If we can follow him, let's do that.
         if (iRow <> 0) 
            AND (iCol <> 0) 
            AND (Send(poLeader,@GetOwner) <> $)
         {
            Post(self,@GotoLeader);
         }
         // Followers are quite loyal and won't just call it quits.
         // Instead, they wait at the next safe spot the leader visits.
         else if IsClass(self,&Follower)
         {
            Send(self,@FollowerAbsence,#iDelay=30000);
         }
         else
         {
            // If we aren't, let's stop following.
            // SetLeader sets leader to nil if none is passed.
            Send(self,@SetLeader);
         }
      }
      
      // Cannot find trigger our object, we are no longer are interested in it.
      if poObject <> $ AND Send(poObject,@GetOwner) = $
      {
         poObject = $;
      }

      if poBrain <> $
      {
         Send(poBrain,@SomethingLeft,#mob=self,#state=piState,#what=what);
      }

      propagate;
   }

   SomethingPhasedOut(what=$)
   {
      if ((poApparitionCaster <> $ AND what = poApparitionCaster)
            OR (poApparitionOriginal <> $ AND what = poApparitionOriginal))
      {
         Send(self,@Delete);
      }

      return;
   }

   SomethingPhasedIn(what=$)
   {
      // Check if it was this mob's temporary owner.
      Send(self,@MobSeduceCheck,#what=what);

      return;
   }

   SomethingSpectatedOut(what=$)
   {
      if ((poApparitionCaster <> $ AND what = poApparitionCaster)
            OR (poApparitionOriginal <> $ AND what = poApparitionOriginal))
      {
         Send(self,@Delete);
      }

      return;
   }

   SomethingSpectatedIn(what=$)
   {
      // Check if it was this mob's temporary owner.
      Send(self,@MobSeduceCheck,#what=what);

      return;
   }

   MobSeduceCheck(what=$)
   "Checks if the mob is under the effect of the Seduce spell, and should "
   "return control to the master (e.g. master logs off/on)."
   {
      local oState;

      if (NOT (piBehavior & AI_NPC)
         AND poMaster = $)
      {
         oState = Send(self,@GetEnchantedState,
                        #what=Send(SYS,@FindSpellByNum,#num=SID_SEDUCE));
         // If we have no master and state for seduce, then our master
         // logged off and back on again. We're still under the effect
         // of the spell, so the player can have the mob back.
         if (oState <> $)
         {
            Send(self,@SetMaster,#oMaster=oState);
         }
      }

      return;
   }

   GotoMaster()
   {
      local oNewRoom;

      if poMaster = $
      {
         return;
      }

      oNewRoom = Send(poMaster,@GetOwner);
      if oNewRoom = $
      {
         return;
      }

      if (Send(oNewRoom,@CountMonsters,#mastered=TRUE) < 200)
      {
         Send(oNewRoom,@NewHold,#what=self,
               #new_row=Send(poMaster,@GetRow),#new_col=Send(poMaster,@GetCol),
               #new_angle=Send(poMaster,@GetAngle));
      }
      else
      {
         Debug("Warning: minion blocked from entering ",Send(oNewRoom,@GetName),
               "with >200 mobs. Minion master is ",poMaster,
               Send(poMaster,@GetTrueName));
      }

      return;
   }

   GotoLeader()
   {
      local oNewRoom;

      if poLeader = $
      {
         return;
      }

      oNewRoom = Send(poLeader,@GetOwner);

      if oNewRoom = $
         OR NOT Send(oNewRoom,@IsAccessibleForFollowers)
      {
         Send(self,@FollowerAbsence,#iDelay=30000);

         return;
      }

      Send(oNewRoom,@NewHold,#what=self,#new_row=Send(poLeader,@GetRow),
         #new_col=Send(poLeader,@GetCol),#new_angle=Send(poLeader,@GetAngle));

      return;
   }

   FollowerAbsence()
   {
      Debug("Non-Follower Class mob ",self, Send(self,@GetName),
            " tried to handle FollowerAbsence. Setting mob free.");
      Send(self,@SetLeader);

      return;
   }

   SomethingKilled(what = $,victim = $,use_weapon = $)
   "Someone just died, perhaps we need to clear our target."
   {
      Send(poBrain,@SomethingKilled,#mob=self,#state=piState,
           #what=what,#victim=victim,#use_weapon=use_weapon);

      propagate;
   }

   //// New Utility Routines

   OfferSubtractNumberItems()
   "filler because some junk in user.kod assumes everyone has this"
   {
      return;
   }

   GetTarget()
   {
      return poTarget;
   }

   GetCustomer()
   {
      return poCustomer;
   }

   CanPatrol()
   {
      return (plPatrolPath <> $);
   }

   GetChanceToPatrol()
   {
      return piChanceToPatrol;
   }

   SetChanceToPatrol(chance=125)
   {
      piChanceToPatrol = chance;

      return;
   }

   GetNextPatrolNode()
   {
      if (plPatrolPath = $)
      {
         return;
      }

      piPatrolNode = piPatrolNode + 1;

      if (piPatrolNode > Length(plPatrolPath))
      {
         if (piBehavior & AI_LOOPING_PATROL)
         {
            piPatrolNode = 1;
         }
         else
         {
            piPatrolNode = Length(plPatrolPath);
         }
      }

      return Nth(plPatrolPath, piPatrolNode);
   }

   SetPatrolNode(node=1)
   {
      piPatrolNode = node;

      return;
   }

   IncrementPatrolAttempts()
   {
      ++piPatrolAttempts;

      return;
   }

   GetPatrolAttempts()
   {
      return piPatrolAttempts;
   }

   ClearPatrolAttempts()
   {
      piPatrolAttempts = 0;

      return;
   }

   ClearPatrolLocation()
   {
      Send(self,@SetBehaviorFlag,#flag=AI_HAS_TARGET_LOCATION,#value=FALSE);
      piTargetLocationRow  = 0;
      piTargetLocationCol  = 0;
      piTargetLocationFineRow = 0;
      piTargetLocationFineCol = 0;

      return;
   }

   ClearStrollLocation()
   {
      Send(self,@SetBehaviorFlag,#flag=AI_STROLLING,#value=FALSE);
      piTargetLocationRow  = 0;
      piTargetLocationCol  = 0;
      piTargetLocationFineRow = 0;
      piTargetLocationFineCol = 0;

      return;
   }

   ClearRallyLocation()
   {
      Send(self,@SetBehaviorFlag,#flag=AI_RALLY,#value=FALSE);
      piTargetLocationRow  = 0;
      piTargetLocationCol  = 0;
      piTargetLocationFineRow = 0;
      piTargetLocationFineCol = 0;

      return;
   }

   ClearSpawnReturnLocation()
   {
      Send(self,@SetBehaviorFlag,#flag=AI_RETURN_TO_SPAWN,#value=FALSE);
      piTargetLocationRow  = 0;
      piTargetLocationCol  = 0;
      piTargetLocationFineRow = 0;
      piTargetLocationFineCol = 0;

      return;
   }

   ////  Action Routines
   EngageTimer( timer = $ )
   "We're trying to engage our target, so either we keep"
   "chasing, or we attack. Note that even if we can't move,"
   "we can still be 'engaging'...."
   {
      local i, iDistance, iChaseRange, iDelay, bSight;

      Send(self,@ClearBehavior,#timer=timer);

      // Sanity checks
      if poOwner = $
      {
         Debug("Unreachable. Null owner.");
         Send(self,@EnterStateLimbo);

         return;
      }

      // If target left, we should already know
      if poTarget = $
      {
         //Debug("Unreachable. Null victim.");
         Send(self,@EnterStateMove);

         return;
      }

      // Victim phased out or is now in spectator mode, break aggro.
      if IsClass(poTarget,&User)
         AND Send(poTarget,@IsInCannotInteractMode)
      {
         Send(self,@EnterStateMove);

         return;
      }

      // If we were dragged too far from our spawn point, reset.
      if Send(self,@ReturnToSpawn)
      {
         Send(self,@MonsterLeashReset);

         // Also reset our minions. 
         foreach i in plControlledMinions
         {
            Send(i,@MonsterLeashReset);
         }

         return;
      }

      // If we have too much distance to our commander, return to them.
      if Send(self,@ReturnToCommander)
      {
         Send(self,@MonsterEndCombat);

         // Have our minions follow us, too.
         foreach i in plControlledMinions
         {
            Send(i,@MonsterEndCombat);
         }

         return;
      }

      // Get distance to target and check LoS.
      iDistance = Send(self,@SquaredFineDistanceTo3D,#what=poTarget);
      bSight = Send(poOwner,@LineOfSight,#obj1=self,#obj2=poTarget);

      // Mobs may stop chasing if the target gets out of range.
      // Not if it has hurt us recently though.
      if NOT Send(self,@GetHurtMeRecentlyAmount,#who=poTarget)
      {
         if viChaseRange = $
         {
            iChaseRange = piVisionDistance * FINENESS;
            iChaseRange = iChaseRange * (50 + piStamina) / 50;
         }
         else
         {
            iChaseRange = viChaseRange * FINENESS;
         }

         // Modified by the global chase range factor.
         iChaseRange = iChaseRange * Send(SETTINGS_OBJECT,@GetChaseRangeFactor) / 100;

         // Severely reduce chase range if target is out of sight.
         if NOT bSight
         {
            iChaseRange /= 5;
         }

         // Chase range is below max range. Square result.
         if iChaseRange < MAX_KOD_INT_SQRT
         {
            iChaseRange *= iChaseRange;
         }
         // Chase range is maximal. Never stop the chase.
         else
         {
            iChaseRange = iDistance;
         }

         // Mobs may lose interest if the target is too far away or out of sight.
         if (NOT ((piBehavior & AI_FIGHT_SINGLEMINDED) OR (poMaster <> $)))
            AND (iDistance > iChaseRange)
         {
            Send(self,@EnterStateMove);

            return;
         }
      }

      if Send(self,@MonsterCombatCheck)
      {
         iDelay = Send(self,@MonsterCombatAction,#distance=iDistance,#sight=bSight);
      }
      else
      {
         iDelay = 0;
      }

      // We may no longer be around after the attack
      // (e.g. evil twin killing a target).
      if poOwner = $
      {
         return;
      }

      // Got gassed after acting and is currently resting. Quit.
      if (piState & STATE_REST)
      {
         return;
      }

      // If we can move, we physically try to get closer.
      if iDelay = 0
      {
         Send(poBrain,@GetEngageBehavior,#mob=self,#target=poTarget,
               #behavior=piBehavior,#bSight=bSight);
      }

      // Monster acted in some way. Let's figure out what to do next.
      if poOwner <> $
      {
         Send(poBrain,@PostEngageTimer,#mob=self,#delay=Abs(iDelay));
      }

      return;
   }

   MoveTimer( timer = $ )
   "Time to move a notch."
   {
      Send(self,@ClearBehavior,#timer=timer);

      // Sanity checks
      if poOwner = $
      {
         Send(self,@EnterStateLimbo);

         return;
      }

      // Every now and then, mobs change how chatty they are.
      if (piBehavior & AI_SOCIALIZER)
      {
         // Mighty monsters tend to stick to themselves.
         if (Random(1,500) < piMight) AND (Random(1,100) >= viSocial)
         {
            piBehavior &= ~AI_SOCIALIZER;
         }
      }
      else
      {
         // Smart monsters tend to stick together.
         if (Random(1,500) < piIntellect) AND (Random(1,100) <= viSocial)
         {
            piBehavior |= AI_SOCIALIZER;
         }
      }

      // Okay, ask our brain how to move
      if Send(poBrain,@GetMoveBehavior,#behavior=piBehavior,#mob=self) = FALSE
      {
         return;
      }

      // See if we want to change state now, but check for brain here first.
      // Sometimes we've died by now.
      if poOwner <> $
      {
         Send(poBrain,@PostMoveTimer,#mob=self);
      }

      return;
   }

   WaitTimer( timer = $ )
   {
      Send(self,@ClearBehavior,#timer=timer);
      Send(poBrain,@PostWaitTimer,#mob=self);

      return;
   }

   RestTimer( timer = $ )
   {
      Send(self,@ClearBehavior,#timer=timer);
      Send(poBrain,@PostRestTimer,#mob=self);

      return;
   }

   ////  Spell Support

   ResetBehaviorFlags()
   "This starts with the default brain, and then goes through "
   "all the enchantments on a monster, tweaking flags as we go."
   "Note that this can be called both at the start and the end "
   "of an enchantment or behavior change."
   {
      local i, lBehavior;

      // Assume if the monster is being singleminded about something,
      //  he's got a good reason.  Example: pissed off charms.
      if piBehavior & AI_FIGHT_SINGLEMINDED
      {
         lBehavior = Cons(AI_FIGHT_SINGLEMINDED,lBehavior);
      }
      if piBehavior & AI_MOVE_WHEN_ALONE
      {
         lBehavior = Cons(AI_MOVE_WHEN_ALONE,lBehavior);
      }
      if piBehavior & AI_CAN_PATROL
      {
         lBehavior = Cons(AI_CAN_PATROL,lBehavior);
      }
      if piBehavior & AI_HAS_TARGET_LOCATION
      {
         lBehavior = Cons(AI_HAS_TARGET_LOCATION,lBehavior);
      }
      else
      {
         Send(self,@ClearPatrolLocation);
      }
      if piBehavior & AI_RETURN_TO_SPAWN
      {
         lBehavior = Cons(AI_RETURN_TO_SPAWN,lBehavior);
      }
      else
      {
         Send(self,@ClearSpawnReturnLocation);
      }
      if piBehavior & AI_LOOPING_PATROL
      {
         lBehavior = Cons(AI_LOOPING_PATROL,lBehavior);
      }

      piBehavior = viDefault_behavior;

      foreach i in lBehavior
      {
         Send(self,@SetBehaviorFlag,#flag=i);
      }

      foreach i in plEnchantments
      {
         Send(Nth(i,2),@ModifyMonsterBehavior,#mob=self);
      }

      // This is for monster specific things, such as the dragonfly queen
      //  being charmed.  We need to do this after we set defaultbehavior,
      //  so this goes here.  Monsters shouldn't need to overwrite
      //  ResetBehaviorFlags, but they are encouraged to overwrite
      //  TweakBehavior.  see monster\dflyq.kod.
      Send(self,@TweakBehavior);

      return;
   }

   TweakBehavior()
   {
      return;
   }

   GetBehavior()
   {
      return piBehavior;
   }

   GetAim()
   {
      return piAim;
   }

   AddMonsterAim(points=0)
   {
      local iOrigAim;

      iOrigAim = piAim;
      piAim = Bound(piAim + points,1,MONSTER_STAT_CAP);

      return piAim - iOrigAim;
   }

   GetAgility()
   {
      return piAgility;
   }

   AddMonsterAgility(points=0)
   {
      local iOrigAgil;

      iOrigAgil = piAgility;
      piAgility = Bound(piAgility + points,1,MONSTER_STAT_CAP);

      return piAgility - iOrigAgil;
   }

   GetMight()
   {
      return piMight;
   }

   AddMonsterMight(points=0)
   {
      local iOrigMight;

      iOrigMight = piMight;
      piMight = Bound(piMight + points,1,MONSTER_STAT_CAP);

      return piMight - iOrigMight;
   }

   GetStamina()
   {
      return piStamina;
   }

   AddMonsterStamina(points=0)
   {
      local iOrigStamina;

      iOrigStamina = piStamina;
      piStamina = Bound(piStamina + points,1,MONSTER_STAT_CAP);

      return piStamina - iOrigStamina;
   }

   GetIntellect()
   {
      return piIntellect;
   }

   AddMonsterIntellect(points=0)
   {
      local iOrigIntellect;

      iOrigIntellect = piIntellect;
      piIntellect = Bound(piIntellect + points,1,MONSTER_STAT_CAP);

      return piIntellect - iOrigIntellect;
   }

   GetMysticism()
   {
      return piMysticism;
   }

   AddMonsterMysticism(points=0)
   {
      local iOrigMysticism;

      iOrigMysticism = piMysticism;
      piMysticism = Bound(piMysticism + points,1,MONSTER_STAT_CAP);

      return piMysticism - iOrigMysticism;
   }

   StartPalsy()
   {
      piEnch_flags |= ENCH_PALSY;

      return;
   }

   EndPalsy()
   {
      piEnch_flags &= ~ENCH_PALSY;

      return;
   }
   
   StartDementia()
   {
      piEnch_flags |= ENCH_DEMENTIA;

      return;
   }

   EndDementia()
   {
      piEnch_flags &= ~ENCH_DEMENTIA;

      return;
   }

   AdjustedChanceBase(base = 0)
   "Adjusts the probability of a monster spell cast based on enchantments"
   {
      local oSpell;

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_ANTIMAGIC_ROOM);
      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_ANTI_MAGIC)
         AND (Send(poOwner,@GetEnchantmentState,#what=oSpell) <> $)
      {
         // Reduce chance to 2/3 by multplying base by 3/2
         base = (3 * base) / 2;
      }

      if (piEnch_flags & ENCH_DEMENTIA)
      {
         // Halve the chance by doubling the base
         base *= 2;
      }

      return base;
   }

   ////  Auxiliary Routines

   DoRandomWalk(override=FALSE)
   "Tries to immediately move the monster exactly one random step into direction N, E, S or W"
   "Does NOT use MoveTowardsCoords to perform the step. Legacy."
   {
      local iNew_row, iNew_col, iNew_finerow, iNew_finecol;

      // The bigger/tougher I am, the less likely I'm interested in milling
      //  around.
      if Random(1,140) < piHealth/100
         AND NOT override
      {
         return;
      }

      // start with old coordinates
      iNew_row = piRow;
      iNew_col = piCol;
      iNew_finerow = piFine_row;
      iNew_finecol = piFine_col;

      // make a random highres-step in one of 4 directions
      if Random(0,1) = 0
      {
         if (Random(0,1) = 0)
         {
            iNew_finerow += 16;
         }
         else
         {
            iNew_finerow -= 16;
         }
      }
      else
      {
         if (Random(0,1) = 0)
         {
            iNew_finecol += 16;
         }
         else
         {
            iNew_finecol -= 16;
         }
      }

      // moved down at least a full row 
      if iNew_finerow >= FINENESS
      {
         iNew_row = piRow + (iNew_finerow / FINENESS);
         iNew_finerow %= FINENESS;
      }
      else if iNew_finerow < 0
      {
         // moved up at least a full row
         iNew_row = piRow - Bound((-iNew_finerow / FINENESS), 1, 100);
         iNew_finerow = FINENESS - (-iNew_finerow % FINENESS);
      }
     
      // moved right at least a full col 
      if iNew_finecol >= FINENESS
      {
         iNew_col = piCol + (iNew_finecol / FINENESS);
         iNew_finecol %= FINENESS;
      }
      else if iNew_finecol < 0
      {
         // moved left at least a full row
         iNew_col = piCol - Bound((-iNew_finecol / FINENESS), 1, 100);
         iNew_finecol = FINENESS - (-iNew_finecol % FINENESS);
      }

      if Send(self,@ReqMonsterMove,#new_row=iNew_row,#new_col=iNew_col,
                  #new_finerow=iNew_finerow,#new_finecol=iNew_finecol)
      {
         Send(self,@MonsterOrient,#new_row=iNew_row,#new_col=iNew_col,
              #new_finerow=iNew_finerow,#new_finecol=iNew_finecol);

         // Check for owner, perhaps we died already
         if poOwner <> $
         {
            if Send(poOwner,@ReqSomethingMoved,#what=self,
                     #new_row=iNew_row,#new_col=iNew_col,
                     #new_finerow=iNew_finerow,#new_finecol=iNew_finecol,
                     #server_validate=(NOT(piBehavior & AI_MOVE_WALKTHROUGH_WALLS)))
            {
               Send(poOwner,@SomethingMoved,#what=self,
                     #new_row=iNew_row,#new_col=iNew_col,
                     #fine_row=iNew_finerow,#fine_col=iNew_finecol,
                     #speed=(0x80|piSpeed),#cause=CAUSE_MOB_MOVEMENT,
                     #non_monsters_only=TRUE);
            }
         }
      }

      return;
   }

   MoveToMaster()
   "Tries to immediately move the monster exactly one step towards its master."
   "Uses path-aware MoveTowardsCoords to perform the step."
   {
      local iRadius, iDist2;

      // Can be called for apparitions also ($ poMaster), return in that case.
      if poMaster = $
      {
         return FALSE;
      }

      // get squared 3d distance to master and how close we should get
      iDist2 = Send(self, @SquaredFineDistanceTo3D, #what=poMaster);
      iRadius = Send(self,@HowCloseToCommander) * FINENESS;

      // Try to get closer to the master, if we're not yet close enough.
      if (iDist2 > iRadius * iRadius)
      {
         Send(self,@MoveTowards,#oTarget=poMaster,#face_target=TRUE);
         return TRUE;
      }

      return FALSE;
   }

   MoveToLeader()
   "Tries to immediately move the monster exactly one step towards its leader."
   "Uses path-aware MoveTowardsCoords to perform the step."
   {
      local iRadius, iDist2;

      if poLeader = $
      {
         Debug("MovetoLeader Called with nil leader!",Send(self,@GetName));
         return FALSE;
      }

      // get squared 3d distance to master and how close we should get
      iDist2 = Send(self, @SquaredFineDistanceTo3D, #what=poLeader);
      iRadius = Send(self,@HowCloseToCommander) * FINENESS;

      // Try to get closer to the leader, if we're not yet close enough.
      if (iDist2 > iRadius * iRadius)
      {
         Send(self,@MoveTowards,#oTarget=poLeader,#face_target=TRUE);
         return TRUE;
      }

      return FALSE;
   }
 
   MoveToTriggerObject()
   "Tries to immediately move the monster exactly one step towards its triggerobject."
   "Uses path-aware MoveTowardsCoords to perform the step."
   {
      local iDist2;
     
      // get squared 3d distance to poObject
      iDist2 = Send(self, @SquaredFineDistanceTo3D, #what=poObject);

      // Let's move up to the object unless we are close enough already.
      // 4096=64*64 (1 big row/col)
      if (iDist2 > 4096)
      {
         Send(self,@MoveTowards,#oTarget=poObject,#face_target=TRUE);
         return TRUE;
      }

      return FALSE;
   }
   
   FollowTrail(oTarget=$)
   {
      local lTrail, i, iRow, iCol, iFineRow, iFineCol;

      if NOT IsClass(oTarget,&User)
      {
         return FALSE;
      }

      lTrail = Send(oTarget,@GetUserTrail);

      foreach i in lTrail
      {
         iRow = First(i);
         iCol = Nth(i,2);
         iFineRow = Nth(i,3);
         iFineCol = Nth(i,4);

         // Move to the most recent location the user has been in that we can reach.
         if CanMoveInRoomBSP(Send(poOwner,@GetRoomData),piRow,piCol,piFine_row,
            piFine_col,piHeight,iRow,iCol,iFineRow,iFineCol,piSpeed,self,CANMOVE_NO_FLAG)
            OR (CanMoveInRoomBSP(Send(poOwner,@GetRoomData),iRow,iCol,
            iFineRow,iFineCol,piHeight,piRow,piCol,piFine_row,piFine_col,piSpeed,self,CANMOVE_NO_FLAG)
               AND IsClass(self,&Follower))
         {
            // We already checked for a valid move. Move freely.
            Send(self,@MoveTowardsCoords,#iRow=iRow,#iCol=iCol,#iFineRow=iFineRow,
               #iFineCol=iFineCol,#face_target=TRUE,#pass_walls=TRUE);

            return TRUE;
         }
      }

      return FALSE;
   }

   DoGoTowardsLocation()
   {
      local iDist2;

      // see how far away we are (2D only)
      iDist2 = Send(self,@SquaredFineDistanceToLocation,
                    #row=piTargetLocationRow,
                    #col=piTargetLocationCol,
                    #fine_row=piTargetLocationFineRow,
                    #fine_col=piTargetLocationFineCol);

      // more than 64 fine-units far away (64*64=4096)
      // and not yet reached maxattempts
      if iDist2 > 4096 AND piPatrolAttempts < 500
      {
         // Try to get closer...
         Send(self,@MoveTowardsTargetLocation);

         ++piPatrolAttempts;
      }
      else
      {
         // Close enough...
         Send(self,@ClearLocation);
      }

      return;
   }

   // Time to stop walking and reset temporary behavior modifications.
   ClearLocation()
   {
      local i;

      // Clear all flags that may have prompted us to start walking.
      Send(self,@SetBehaviorFlag,#flag=AI_HAS_TARGET_LOCATION,#value=FALSE);
      Send(self,@SetBehaviorFlag,#flag=AI_STROLLING,#value=FALSE);
      Send(self,@SetBehaviorFlag,#flag=AI_RALLY,#value=FALSE);
      Send(self,@SetBehaviorFlag,#flag=AI_RETURN_TO_SPAWN,#value=FALSE);

      // Revoke temporary NPC status if necessary.
      if (piBehavior & AI_NPC)
         AND NOT (viDefault_behavior & AI_NPC)
      {
         Send(self,@SetBehaviorFlag,#flag=AI_NPC,#value=FALSE);
         Send(poOwner,@SomethingChangedFlags,#what=self);
      }

      // Revoke temporary go through walls status if necessary.
      if (piBehavior & AI_MOVE_WALKTHROUGH_WALLS)
         AND NOT (viDefault_behavior & AI_MOVE_WALKTHROUGH_WALLS)
      {
         Send(self,@SetBehaviorFlag,#flag=AI_MOVE_WALKTHROUGH_WALLS,#value=FALSE);
      }

      piPatrolAttempts = 0;

      // Also tell our minions that we've arrived.
      foreach i in plControlledMinions
      {
         Send(i,@ClearLocation);
      }

      return;
   }

   StartNextPatrolLeg()
   {
      local lPatrolNode;

      lPatrolNode = Send(self,@GetNextPatrolNode);

      if (lPatrolNode <> $)
      {
         Send(self,@GotoCoords,#iRow=First(lPatrolNode),#iCol=Nth(lPatrolNode,2));
      }

      return;
   }

   //// Combat messages

   AllowBattlerAttack(victim=$,stroke_obj=$,report=TRUE,minion=FALSE,
                      actual=TRUE,oRoomOverride=$)
    "Can this monster attack the victim? "
   {
      local oRoom, bWasBad, lMinions;

      // Must be in a room to attack, must have target.
      if (poOwner = $
         OR victim = $)
      {
         return FALSE;
      }

      // Can't attack the master.
      if (victim = poMaster)
      {
         return FALSE;
      }

      // NPCs can't attack. Don't check AI_NOFIGHT here, as those mobs
      // might have a non-direct attack to cause damage with (e.g. brambles).
      if (piBehavior & AI_NPC)
      {
         return FALSE;
      }

      // Default location to check is the room the victim is in.
      // This allows X-room atacks (such as firewalls) to work.
      oRoom = Send(victim,@GetOwner);

      // Check if we are in the same room as our victim.
      if oRoom <> poOwner
      {
         // If we are not, check if we have been fed an override.
         if (oRoomOverride <> $)
         {
            oRoom = oRoomOverride;
         }
      }

      // Our victim has left the world of the living since we started plotting
      // our attack. Let's leave it in peace.
      if oRoom = $
      {
         return FALSE;
      }

      // Phased players can't be hit.
      // Jig prevents combat between players and monsters.
      if IsClass(victim,&User)
         AND (Send(victim,@IsInCannotInteractMode)
            OR Send(victim,@IsAffectedByRadiusEnchantment,#byClass=&Jig))
      {
         return FALSE;
      }

      // Make sure room allows the attack.
      if NOT Send(oRoom,@ReqSomethingAttack,#what=self,#victim=victim,
                  #stroke_obj=stroke_obj,#actual=actual)
      {
         // Check if room has special combat effects.
         return FALSE;
      }

      // If we're hitting another monster, check if we can reach or attack it.
      // We also don't hit allies. Total no go. Seriously.
      if IsClass(victim,&Monster)
      {
         if NOT Send(victim,@CanMonsterFight,#who=self,
               #oStroke=stroke_obj,#use_weapon=stroke_obj)
            OR Send(self,@IsAlly,#target=victim)
         {
            return FALSE;
         }
      }

      // Minions are attacking for a master. Handle ETs, Reflections,
      // Seduced and Animated monsters here. If the master can't attack,
      // we can't either. If they can, we treat it as if they personally
      // attacked the target.
      if poMaster <> $
         AND IsClass(poMaster,&Player)
      {
         // Is the caster bad to start with? This is for flavor text.
         bWasBad = (Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
                    OR Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_MURDERER));

         // Check the attack here. If it fails, Player's AllowBatterAttack
         // handles the message sent to the player.
         if NOT Send(poMaster,@AllowBattlerAttack,#victim=victim,
                     #actual=actual,#report=report,#stroke_obj=self)
         {
            return FALSE;
         }

         // Don't attack other minions of the caster.
         lMinions = Send(poMaster,@GetControlledMinions);
         if (lMinions <> $ AND FindListElem(lMinions,victim))
         {
            return FALSE;
         }

         // If they weren't bad and become bad, let them know.
         if report
            AND actual
            AND NOT bWasBad
            AND (Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_MURDERER))
         {
            Send(poMaster,@MsgSendUser,#message_rsc=vrMinion_trouble);
         }
      }

      return TRUE;
   }

   TryAttack(what=$,stroke_obj=$)
   "Ok, we got someone to attack, lets try and hit them."
   {
      // AI_NOFIGHT means they can't directly attack.
      if (piBehavior & AI_NOFIGHT)
      {
         return FALSE;
      }

      // AllowBattlerAttack handles all other attack checks.
      if (NOT Send(self,@AllowBattlerAttack,#victim=what,#stroke_obj=stroke_obj))
      {
         return FALSE;
      }

      // Face the target.
      Send(self,@MonsterOrient,#new_row=Send(what,@GetRow),
            #new_col=Send(what,@GetCol),#new_finerow=Send(what,@GetFineRow),
            #new_finecol=Send(what,@GetFineCol),#face_target=TRUE);

      propagate;
   }

   GetOffense(what = $, stroke_obj=$)
   "This returns the battler's ability to-hit.  Ranges from 1 to 2000."
   {
      local iAttack;

      if piOffense = $
      {
         iAttack = 4*viLevel + 8*piAim;
      }
      else
      {
         iAttack = piOffense;
      }

      if piEnch_flags & ENCH_PALSY
      {
         iAttack = iAttack * 3 / 4;
      }

      return Bound(iAttack,1,2000);
   }

   GetDefense(what = $, stroke_obj=$)
   "This returns the battler's ability to avoid being hit.  Ranges from "
   "1 to 2000."
   {
      local iDefense;

      if piDefense = $
      {
         iDefense = 4*viLevel + 8*piAgility;
      }
      else
      {
         iDefense = piDefense;
      }

      return Bound(iDefense,1,2000);
   }

   // The next message deals with the three defense skills.  These messages
   //  return the relative values of the three skills.  Used for defense
   //  messages.

   GetDodgeAbility(stroke_obj=$)
   {
      if (stroke_obj <> $) AND NOT Send(stroke_obj,@CanDodge)
         OR (piBehavior & AI_NOMOVE) OR (piBehavior & AI_MOVE_RANDOM)
      {
         return 0;
      }

      return (viDifficulty * 11);
   }

   // This returns the damage done to target "what"
   GetDamage(what = $, stroke_obj=$)
   {
      local iDamage, oWeapon;

      // Special case for snowball weapon.
      oWeapon = Send(self,@GetWeapon);
      if (oWeapon <> self // most cases
         AND oWeapon <> $
         AND IsClass(oWeapon,&Snowball)
         AND NOT Send(oWeapon,@CanDoDamage))
      {
         return 0;
      }

      if piMinDamage = $ and piMaxDamage = $
      {
         iDamage = Send(Self,@Fuzzy,#num=viLevel*100/Random(10,15));
      }
      else
      {
         if piMinDamage = $ OR piMinDamage > piMaxDamage
         {
            piMinDamage = piMaxDamage;
         }
         if piMaxDamage = $ OR piMaxDamage < piMinDamage
         {
            piMaxDamage = piMinDamage;
         }
         iDamage = Random(piMinDamage*100,piMaxDamage*100);
      }

      if piEnch_flags & ENCH_PALSY
      {
         iDamage = iDamage * 3 / 4 ;
      }

      // Scale damage with monster might.
      iDamage = iDamage * (50+piMight)/75;

      return Bound(iDamage,0,$);
   }

   // This is the type of damage done.
   GetAttackType(what = $)
   {
      return viAttack_type;
   }

   // This is the magical type of damage done.
   GetSpellType(what = $)
   {
      return viSpell_type;
   }

   IsRangedAttack()
   {
      return FALSE;
   }

   // Handles damage done to monster
   // IMPORTANT NOTE: AssessDamage handles both legacy damage calculations and 
   // high precision damage calculation which avoid truncation. If you feed 
   // AssessDamage with a high precision damage number such as 941 for 9.41 
   // points of damage, you need to notify AssessDamage by passing it a 
   // #precision=TRUE. If you don't, AssessDamage will assume that you are 
   // passing a legacy damage value and multiply it by 100 for further 
   // calculations. Most notably, damage from attackspells and melee is now 
   // handled with high precision. Eventually, all damage calculations should 
   // be handled in high precision mode.
   AssessDamage(what=$,damage=$,atype=0,stype=0,bonus=0,scalefactor=1000,
      absolute=FALSE,precision=FALSE)
   {
      local iDamage, iResist, iPercentClass, i, each_obj;

      if NOT precision
      {
         damage *= 100;
      }

      if (piBehavior & AI_NPC)
      {
         Send(what,@MsgSendUser,#message_rsc=LS_nofight_attacked);

         return 0;
      }

      // Check for any applicable resistances.
      if NOT absolute
      {
         iDamage = Send(self,@ArmorCheck,#what=what,#bonus=bonus,#atype=atype,
            #stype=stype,#damage=damage);
         iResist = Send(self,@ResistanceCheck,#atype=atype,#stype=stype);
         iDamage = Send(self,@GetDamageFromResistance,#what=iDamage,#value=iResist);
         iDamage += bonus;
         iDamage = iDamage * scalefactor / 1000;
      }
      else
      {
         iDamage = damage;
      }

      // Set a predamage mark... we'll compare to it to see if threshold crossed.
      iPercentClass = piHealth/(piMax_health*20);

      // Make sure we don't deal negative damage.
      iDamage = Bound(iDamage,0,$);

      piHealth -= iDamage;

      if poOwner = $
      {
         return 0;
      }

      if piHealth <= 0
      {
         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_obj = First(i);
            if IsClass(each_obj,&User)
               AND each_obj <> what
               AND Send(each_obj,@GetKillTarget)=self
            {
               Post(each_obj,@MsgSendUser,#what=self,
                    #message_rsc=vrParty_killed_monster,
                    #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));
            }
         }
         
         return $;
      }

      Send(self,@NewHealth);

      // Check to see if we crossed a threshold due to the damage.
      if iPercentClass <> (piHealth / (piMax_health * 20))
      {
         Send(self,@HitPointThresholdDamage);
      }

      // Let the attacker know if they hit some weakness/strength of the mob
      if IsClass(what,&player) AND NOT absolute
      {
         Post(what,@MsgPlayerHitResisted,#what=what,#resistance=iResist,
              #target=self,#color_rsc=monster_color_blue_rsc);
      }

      Send(self,@AddHurtMeRecently,#who=what,#amount=iDamage);

      return iDamage;
   }

   HealthRegen()
   "Make damage thresholds available for hots/regeneration."
   {
      local iPercentClass;

      ptHealth = $;

      // There's no reason this should ever happen really.
      if poOwner = $
      {
         return;
      }

      // Check health before gaining a health point.
      iPercentClass = piHealth/(piMax_health*20);

      piHealth = Bound(piHealth + Send(self,@GetTickFactor,#i=100),$,piMax_health*100);

      // Check if we crossed a threshold due to decay.
      if iPercentClass <> (piHealth / (piMax_health * 20))
      {
         Send(self,@HitPointThresholdHeal);
      }

      Send(self,@NewHealth);

      return;
   }

   HealthDecay()
   "Make damage thresholds available to dots as well."
   {
      local iPercentClass;

      ptHealth = $;

      // There's no reason this should ever happen really.
      if poOwner = $
      {
         return;
      }

      // Check health before losing a health point.
      iPercentClass = piHealth/(piMax_health*20);

      piHealth = Bound(piHealth - Send(self,@GetTickFactor,#i=100),0,$);

      // We've run out of health. Check what happens now.
      if piHealth < 1
      {
         Send(self,@ZeroHealth);
      }
      // Still alive, check if we crossed a threshold due to decay.
      else if iPercentClass <> (piHealth / (piMax_health * 20))
      {
         Send(self,@HitPointThresholdDamage);
      }

      Send(self,@NewHealth);

      return;
   }

   // Allows monsters to have armor not related to specific equipped items. 
   // Based on piArmor and viBonusArmor.
   ArmorCheck(what=$,damage=0,atype=0,stype=0,bonus=0)
   {
      local iArmor, oAttribute;

      foreach oAttribute in plObject_attributes
      {
         damage = Send(oAttribute,@ModifyDefenseDamage,#who=self,#what=what,
            #damage=damage,#atype=atype,#stype=stype);
      }

      // piArmor may be adjusted situationally (e.g. survival room)
      iArmor = piArmor + viBonusArmor;

      // Randomization simulates hits of differently armored body parts.
      iArmor = Bound(Random(iArmor*33,iArmor*100),0,damage);

      // Armor is only fully effective against physical attacks.
      if stype<> 0
      {
         // Reduce damage if part of the damage is spell
         if atype <> 0
         {
            // Only 2/3 of the damage reduction if we're doing both weapon
            // and spell damage types.
            iArmor *= 2;
            iArmor /= 3;
         }
         else
         {
            // If we're doing pure spell damage, we get no reduction.
            iArmor = 0;
         }
      }
      
      return damage - iArmor;
   }

   AssessHit(what = $, stroke_obj = $, damage = $)
   "This does the fallout of a hit, gives appropriate message, etc.  "
   "Called on self when hit opponent."
   {
      if poOwner = $
      {
         // No owner to send this to, so propagate.
         propagate;
      }

      if vrSound_miss <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=vrSound_miss,
               #flags=SOUND_RANDOM_PITCH);
         if (IsClass(what,&Player))
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,
                  #wave_rsc=Send(what,@GetOuchSound),#flags=SOUND_RANDOM_PITCH);
         }
      }

      propagate;
   }

   AssessMiss(what = $, stroke_obj = $)
   "This does the fallout of a miss, gives appropriate message, etc.  "
   "Called on target when missing."
   {
      if poOwner = $
      {
         // No owner to send this to, so propagate.
         propagate;
      }

      if vrSound_miss <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=vrSound_miss,
               #flags=SOUND_RANDOM_PITCH);
      }

      propagate;
   }

   // This function handles damage done, etc.
   DidDamage(what = $, amount = 0)
   {
      Send(self,@HitSideEffect,#what=what,#amount=amount);

      return;
   }

   // Can an opponent dodge this monster's attack?
   CanDodge()
   {
      return TRUE;
   }

   // Can an opponent parry this monster's attack?
   CanParry()
   {
      return TRUE;
   }

   // Can an opponent block this monster's attack with a shield?
   CanBlock()
   {
      return TRUE;
   }

   // This function returns the name of the monster's attack.
   GetAttackName()
   {
      return monster_default_attack;
   }

   GetVisionDistance()
   "Returns vision radius."
   {
      return piVisionDistance;
   }

   GetMeleeRange()
   {
      return piMeleeRange;
   }

   GetFireRange()
   {
      return piFireRange;
   }

   GetAttackRange(bRanged=FALSE)
   "Returns the attack range of the monster, in FINENESS units. "
   "Default for most monsters is 128 (2 row/col units)."
   {
      if bRanged
      {
         return Bound(piFireRange,piMeleeRange,$);
      }

      return piMeleeRange;
   }

   GetOptimalRange()
   "For most monsters, this is the attack range."
   {
      return Bound(piFireRange,piMeleeRange,$);
   }

   GetTargetsInRange(bRanged=FALSE)
   {
      local oRoom, i, each_obj, lValidTargets;

      oRoom = Send(self,@GetOwner);
      foreach i in Send(oRoom,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&Battler)
            AND (NOT Send(self,@IsAlly,#target=each_obj))
            AND (NOT Send(each_obj,@IsInCannotInteractMode))
            AND Send(self,@CanReach,#what=each_obj,#bRanged=bRanged)
         {
            lValidTargets = Cons(each_obj,lValidTargets);
         }
      }

      return lValidTargets;
   }

   CanSee(what = $)
   {
      if what = $
      {
         return FALSE;
      }

      if poOwner <> Send(what,@GetOwner)
      {
         return FALSE;
      }

      if (Send(self,@SqFineDistToVision,#what=what) / FINENESS_SQUARED)
               <= (piVisionDistance*piVisionDistance)
      {
         return TRUE;
      }

      return FALSE;
   }

   ValidAttack(who=$)
   {
      local iRange;

      iRange = Send(self,@GetAttackRange);

      if who = poTarget
      {
         // Range in FINENESS units.
         if Send(self,@SquaredFineDistanceTo3D,#what=who) > (iRange * iRange)
         {
            return;
         }

         piState &= VSTATE_VALIDITY_MASK;
         piState |= VSTATE_VALID_ATTACK;
      }

      return;
   }

   CanReach( what = $ , bRanged = FALSE)
   {
      local iRange;

      iRange = Send(self,@GetAttackRange,#bRanged=bRanged);

      if poOwner <> Send(what,@GetOwner)
      {
         return FALSE;
      }

      // Check range first, for speed (in FINENESS units).
      if Send(self,@SquaredFineDistanceTo3D,#what=what)
            > (iRange * iRange)
      {
         if what = poTarget
         {
            piState |= VSTATE_INVALID_ATTACK;
         }

         return FALSE;
      }

      // if neither the player or the monster has moved lately,
      // we don't have to check this stuff again.
      if what = poTarget
      {
         if (piState & VSTATE_VALID_ATTACK)
         {
            return TRUE;
         }

         if (piState & VSTATE_INVALID_ATTACK)
         {
            return FALSE;
         }
      }

      // Some monsters (revenants) don't care about walls.
      if (piBehavior & AI_FIGHT_THROUGH_WALLS)
      {
         if what = poTarget
         {
            piState |= VSTATE_VALID_ATTACK;
         }

         return TRUE;
      }

      /// Okay, now then, check for walls.
      if Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         if what = poTarget
         {
            piState |= VSTATE_VALID_ATTACK;
         }

         return TRUE;
      }

      if what = poTarget
      {
         piState |= VSTATE_INVALID_ATTACK;
      }

      return FALSE;
   }

   CanReachLocation(row=$,col=$,fine_row=$,fine_col=$)
   {
      local iRange;

      iRange = Send(self,@GetAttackRange);

      if Send(self,@SquaredFineDistanceToLocation3D,#row=row,#col=col,
            #fine_row=fine_row,#fine_col=fine_col)
         <= (iRange * iRange)
      {
         return TRUE;
      }

      return FALSE;
   }

   //// Movement messages

   MoveTowards(oTarget = $, face_target=FALSE, face_away=FALSE,pass_walls=FALSE,bEngage=FALSE)
   "Tries to immediately move the monster exactly one step towards oTarget"
   "Uses MoveTowardsCoords to perform the step."
   {
      if oTarget = $
      {
         Debug("Bad info passed to MoveTowards!");

         return FALSE;
      }

      return Send(self, @MoveTowardsCoords,
                   #iRow=Send(oTarget,@GetRow),
                   #iCol=Send(oTarget,@GetCol),
                   #iFineRow=Send(oTarget,@GetFineRow),
                   #iFineCol=Send(oTarget,@GetFineCol),
                   #face_target=face_target,
                   #face_away=face_away,
                   #pass_walls=pass_walls,
                   #bEngage=bEngage);
   }

   MoveAway(oTarget = $, face_target=FALSE, face_away=FALSE)
   "Tries to immediately move the monster exactly one step away from oTarget"
   "Uses MoveTowardsCoords to perform the step."
   {
      local drow, dcol;
  
      if oTarget = $
      {
         Debug("Bad info passed to MoveAway!");

         return FALSE;
      }

      if poOwner <> Send(oTarget,@GetOwner)
      {
         return FALSE;
      }

      // calculate square delta in fineness
      // vector from oTarget to self
      drow = (piRow * FINENESS) + piFine_row;
      dcol = (piCol * FINENESS) + piFine_col;
      drow -= ((Send(oTarget,@GetRow) * FINENESS) + Send(oTarget,@GetFineRow));
      dcol -= ((Send(oTarget,@GetCol) * FINENESS) + Send(oTarget,@GetFineCol));

      // add vector from oTarget to self on our position and try move there
      return Send(self, @MoveTowardsCoords,
                   #iRow=(piRow + (drow / FINENESS)),
                   #iCol=(piCol + (dcol / FINENESS)),
                   #iFineRow=(piFine_row + (drow % FINENESS)),
                   #iFineCol=(piFine_col + (dcol % FINENESS)),
                   #face_target=face_target,
                   #face_away=face_away);
   }
   
   MoveTowardsTargetLocation()
   "Tries to immediately move the monster exactly one step towards its current target-location."
   "Uses MoveTowardsCoords to perform the step."
   {
      return Send(self,@MoveTowardsCoords,#iRow=piTargetLocationRow,#iCol=piTargetLocationCol,
         #iFineRow=piTargetLocationFineRow,#iFineCol=piTargetLocationFineCol);
   }

   // We can pass a direction (-10 to 10) to RandomCombatMove.
   // 10 is a guaranteed step towards the target, -10 away from it.
   RandomCombatMove(direction=FALSE)
   "Tries to immediately move the monster exactly one step into"
   "a random direction or towards/away from its current target."
   "Uses MoveTowardsCoords to perform the step."
   {
      local iMRow, iMCol, iMRowFine, iMColFine, iSpeed;

      if poOwner = $
      {
         return;
      }

      direction = Bound(direction,-10,10);

      iSpeed = piSpeed;

      if direction AND poTarget <> $ AND (Send(poTarget,@GetOwner) <> $)
      {
         if direction > 0 AND Random(direction,10) = 10
         {
            Send(self,@MoveTowards,#oTarget=poTarget,#face_target=TRUE,
                  #face_away=FALSE);
         }
         else if direction < 0 AND Random(-10,direction) = -10
         {
            Send(self,@MoveAway,#oTarget=poTarget,#face_target=TRUE,
                  #face_away=FALSE);
         }
         else
         {
            direction = FALSE;
         }
      }
      else
      {
         direction = FALSE;
      }

      if (NOT direction)
         AND GetRandomMoveDestBSP(Send(poOwner,@GetRoomData), 48, 128, 1536,
                                   piRow, piCol, piFine_row, piFine_col, 
                                   *iMRow, *iMCol, *iMRowFine, *iMColFine)
      {
         Send(self,@MoveTowardsCoords,#iRow=iMRow,#iCol=iMCol,
               #iFineRow=iMRowFine,#iFineCol=iMColFine,
               #face_target=TRUE,#face_away=FALSE);
      }

      return;
   }

   ReqMonsterMove(new_row = $,new_col = $,new_finerow = FINENESS_HALF,
                  new_finecol = FINENESS_HALF)
   "Called by monster moving code to check if we really want to go"
   "to <new_row>,<new_col>."
   {
      local r,c;

      // Not actively chasing anyone. Let's avoid getting our feet wet.
      // If we are already wading through water, we might as well keep
      // going.
      if (piState & STATE_MOVE)
         AND (piBehavior & AI_STROLLING)
         AND NOT vbAquatic
         AND (Send(poOwner,@GetSectorIDAtLocation,#row=new_row,#col=new_col,
                  #fine_row=new_finerow,#fine_col=new_finecol) = 10)
      {
         if Send(poOwner,@GetSectorIDAtLocation,#row=piRow,#col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col) <> 10
         {
            return FALSE;
         }
      }

      if NOT (piBehavior & AI_MOVE_WALKTHROUGH_WALLS)
      {
         return TRUE;
      }

      // Get coordinates in highres squares
      r = ((new_row * FINENESS) + new_finerow) / 16;
      c = ((new_col * FINENESS) + new_finecol) / 16;

      // Monsters that can attack/move through walls shouldn't wander off the
      // map.
      if r > Send(poOwner,@GetRoomRowsHighRes)
         OR r < 1
         OR c > Send(poOwner,@GetRoomColsHighRes)
         OR c < 1
      {
         return FALSE;
      }

      return TRUE;
   }

   MonsterOrient(new_row = $,new_col = $,new_finerow = FINENESS_HALF,
               new_finecol=FINENESS_HALF,face_target = FALSE, face_away=FALSE)
   "Called by monster moving code before and after a real move"
   {
      local drow, dcol, iAngle;

      // aiming towards a target or away from it
      if (NOT (poTarget = $)) AND (face_target OR face_away)
      { 
         // build face towards (in fine-units)
         drow = (Send(poTarget,@GetRow) * FINENESS) + Send(poTarget,@GetFineRow);
         dcol = (Send(poTarget,@GetCol) * FINENESS) + Send(poTarget,@GetFineCol);
         drow = drow - ((piRow * FINENESS) + piFine_row);
         dcol = dcol - ((piCol * FINENESS) + piFine_col);

         // rotate 180??, if we face away
         if face_away
         { 
            drow = -drow;
            dcol = -dcol;
         }
      }
      else
      {
         drow = (new_row * FINENESS) + new_finerow;
         dcol = (new_col * FINENESS) + new_finecol;
         drow -= ((piRow * FINENESS) + piFine_row);
         dcol -= ((piCol * FINENESS) + piFine_col);
      }

      if poOwner <> $
      {
         iAngle = Send(SYS,@UtilGetAngleTowards,#row=drow,#col=dcol);

         // only if new_angle is different
         if iAngle <> Send(self,@GetAngle)
         {
            Send(poOwner,@SomethingTurned,#what=self,#new_angle=iAngle);
         }
      }

      return;
   }

   ReconsiderMoveDestination()
   "Called if too many steps by heuristic"
   {
      // check if strolling
      if (piBehavior & AI_STROLLING)
      {
         Send(self, @ClearStrollLocation);
         return FALSE;
         //Debug("Discarded current stroll location!!");
      }

      // check if returning to spawn
      if (piBehavior & AI_RETURN_TO_SPAWN)
      {
         Send(self, @ClearSpawnReturnLocation);
         return FALSE;
         //Debug("Discarded SPAWN return location!!");
      }

      return TRUE;
   }

   MoveTowardsCoords(iRow=$,iCol=$,iFineRow=FINENESS_HALF,iFineCol=FINENESS_HALF,
                     face_target=FALSE,face_away=FALSE,pass_walls=FALSE,bEngage=FALSE)
   "Tries to immediately move the monster exactly one step towards the location specified in arguments."
   "The performed step can be straight towards the location or a step on a astar path or"
   "a step determined by the move-heuristic. Raises @ReconsiderMoveDestination if two steps in a row"
   "were performed by the heuristic. In this case it's unlikely the monster will ever reach"
   "the desired location passed in arguments and going elsewhere should be considered."
   {
      local iState, iMoveFlags, iSpeed, oCommander, iStillGo;

      if (iRow = $ or iCol = $)
      {
         return;
      }

      // Mobs that can move outside the BSP tree set this field which is then
      // combined with the state flags and sent to GetStepTowardsBSP. These
      // moves aren't checked against room geometry.
      iMoveFlags = 0;
      if (piBehavior & AI_MOVE_WALKTHROUGH_WALLS) OR pass_walls
      {
         iMoveFlags |= MSTATE_MOVE_OUTSIDE_BSP;
      }

      // WORKAROUND/TODO: existing monsters don't have a height yet
      Send(self, @InitHeight);

      // query where to step next
      // note: these need some persistent info across
      // calls which are stored in piState (flags from old KOD code)
      iState = GetStepTowardsBSP(
                Send(poOwner, @GetRoomData),
                piRow, piCol, piFine_row, piFine_col, piHeight,
                *iRow, *iCol, *iFineRow, *iFineCol, piSpeed,
                piState | iMoveFlags, self);

      if iState <> $
      {
         piState = iState;

         // stores if we reconsidered our move destination
         iStillGo = TRUE;

         // check if this was a 'good' step (=on a path or directly towards)
         if (iState & STATE_MOVE_PATH) OR (iState & STATE_MOVE_DIRECT)
         {
            // reset badstep counter
            piBadSteps = 0;
         }
         else
         {
            // increment bad step counter
            piBadSteps = piBadSteps + 1;

            // Unreachable targets are lowered on the hate list.
            if bEngage
            {
               Send(self,@ModifyHurtMeRecently,#who=poTarget,
                  #iPercentage=Send(poBrain,@GetAggroPercentageLoss));
               Send(self,@SetTarget,#what=Send(self,@GetTopHurter));
            }

            // too many heuristic steps, consider going elsewhere
            if (piBadSteps % 2 = 0)
            {
               iStillGo = Send(self,@ReconsiderMoveDestination);
            }
         }

         if iStillGo AND Send(self,@ReqMonsterMove,#new_row=iRow,#new_col=iCol,
                  #new_finerow=iFineRow,#new_finecol=iFineCol)
         {
            Send(self,@MonsterOrient,#new_row=iRow,#new_col=iCol,
                 #new_finerow=iFineRow,#new_finecol=iFineCol,
                 #face_target=face_target,#face_away=face_away);

            Send(poOwner,@SomethingMoved,#what=self,#speed=piSpeed,
                 #new_row=iRow,#new_col=iCol,
                 #fine_row=iFineRow,#fine_col=iFineCol,
                 #cause=CAUSE_MOB_MOVEMENT,#non_monsters_only=TRUE);

            // Turn to face target
            Send(self,@MonsterOrient,#new_row=iRow,#new_col=iCol,
                 #new_finerow=iFineRow,#new_finecol=iFineCol,
                 #face_target=face_target,#face_away=face_away);

            return TRUE;
         }
      }

      return FALSE;
   }

   GotoCoords(iRow=$,iCol=$,iFineRow=FINENESS_HALF,iFineCol=FINENESS_HALF)
   "Sets a new target location for the monster to get to."
   "Does not perform any move steps directly."
   {
      if (iRow = $ OR iCol = $)
      {
         return;
      }

      Send(self,@ClearStrollLocation);

      piTargetLocationRow = iRow;
      piTargetLocationCol = iCol;
      piTargetLocationFineRow = iFineRow;
      piTargetLocationFineCol = iFineCol;
      Send(self,@SetBehaviorFlag,#flag=AI_HAS_TARGET_LOCATION,#value=TRUE);

      return;
   }

   GoStrolling()
   "Sets a random new target location to stroll to."
   "Does not perform any move steps directly."
   {
      local iMRow,iMCol,iMRowFine,iMColFine;

      if (NOT GetRandomMoveDestBSP(Send(poOwner,@GetRoomData), 48, 128, 1536,
                                   piRow, piCol, piFine_row, piFine_col, 
                                   *iMRow, *iMCol, *iMRowFine, *iMColFine))
         OR (Send(poOwner,@GetSectorIDAtLocation,#row=iMRow,#col=iMCol,
                  #fine_row=iMRowFine,#fine_col=iMColFine) = 10)
         OR (piBehavior & AI_HAS_TARGET_LOCATION)
         OR (piBehavior & AI_CAN_PATROL)
      {
         return FALSE;
      }
      else
      {
         piTargetLocationRow = iMRow;
         piTargetLocationCol = iMCol;
         piTargetLocationFineRow = iMRowFine;
         piTargetLocationFineCol = iMColFine;
      }

      Send(self,@SetBehaviorFlag,#flag=AI_STROLLING,#value=TRUE);

      return;
   }

   GoRally()
   "Walk over to the flagpole if we care for it and one is present."
   {
      local iRow, iCol;

      if NOT vbCanRally
      {
         return FALSE;
      }

      iRow = Send(poOwner,@GetFlagRow);
      iCol = Send(poOwner,@GetFlagCol);

      if iRow <> $ AND iCol <> $
      {
         piTargetLocationRow = iRow;
         piTargetLocationCol = iCol;
         piTargetLocationFineRow = FINENESS_HALF;
         piTargetLocationFineCol = FINENESS_HALF;

         Send(self,@SetBehaviorFlag,#flag=AI_RALLY,#value=TRUE);

         return TRUE;
      }

      return FALSE;
   }

   ReturnToSpawn()
   "Return to our spawn point if we have one and we have strayed too far."
   {
      local iRow, iCol, iRadius;

      if piSpawnLoc = $
      {
         return FALSE;
      }

      if (piState & STATE_ENGAGE)
      {
         // Only leash bosses and their mercenaries.  Those have
         // spawn IDs greater than the number of generators.
         if piSpawnLoc / 1000000 <= Send(poOwner,@GetNumGenerators)
         {
            return FALSE;
         }

         iRadius = Send(poOwner,@GetLeashRadius);
      }
      else
      {
         iRadius = Send(poOwner,@GetPatrolRadius);
      }

      if (iRadius > 0)
      {
         iRow = (piSpawnLoc / 1000) % 1000;
         iCol = piSpawnLoc % 1000;

         if (Send(self,@SquaredDistanceToLocation,#row=iRow,#col=iCol) > iRadius)
         {
            Send(self,@ClearLocation);
            piTargetLocationRow = iRow;
            piTargetLocationCol = iCol;
            piTargetLocationFineRow = FINENESS_HALF;
            piTargetLocationFineCol = FINENESS_HALF;

            Send(self,@SetBehaviorFlag,#flag=AI_RETURN_TO_SPAWN,#value=TRUE);

            return TRUE;
         }
      }

      return FALSE;
   }

   ReturnToCommander()
   "Return to our commander if we have one and we have strayed too far."
   {
      local iRow, iCol, iRadius, oCommander, oRoom;

      // Usually, our leader is in command.
      oCommander = poLeader;

      // If we (also) have a master, his orders are to be obeyed.
      // This also takes care of the case of a follower being seduced.
      if poMaster <> $
      {
         oCommander = poMaster;
      }

      // No commander, bail out.
      if (oCommander = $)
      {
         return FALSE;
      }

      oRoom = Send(oCommander,@GetOwner);

      // If commander is not in a room (logged out/dead mob) or is in a
      // different room, don't go to them. If the mob should be teleported
      // to the commander, this should be handled when commander changes room.
      if (oRoom = $
         OR oRoom <> poOwner)
      {
         return FALSE;
      }

      iRadius = Send(self,@HowCloseToCommander);

      // If our commander doesn't have vision of the target, return sooner.
      if Send(poOwner,@LineOfSight,#obj1=poTarget,#obj2=oCommander)
      {
         iRadius *= 9;
      }
      else
      {
         iRadius *= 3;
      }

      iRadius *= iRadius;

      if (Send(poTarget,@GetOwner) <> poOwner)
      {
         return (Send(self,@SquaredDistanceTo,#what=oCommander) > iRadius);
      }

      return ((Send(poTarget,@SquaredDistanceTo,#what=oCommander) > iRadius)
         AND (Send(self,@SquaredDistanceTo,#what=oCommander) > iRadius));
   }

   GetTargetLocationRow()
   {
      return piTargetLocationRow;
   }

   GetTargetLocationCol()
   {
      return piTargetLocationCol;
   }

   GetTargetLocationFineRow()
   {
      return piTargetLocationFineRow;
   }

   GetTargetLocationFineCol()
   {
      return piTargetLocationFineCol;
   }

   //// Spasming messages

   SpasmMonsterTimer()
   {
      if poOwner = $ OR NOT (viAttributes & MOB_SPASM)
      {
         return;
      }

      ptSpasm = $;
      Send(self,@DoSpasm);
      ptSpasm = CreateTimer(self,@SpasmMonsterTimer,
                            viSpasm_delay+Random(0,viSpasm_delay/3));

      return;
   }

   DoSpasm()
   {
      return;
   }

   //// Receive messages

   CanAcceptGift()
   {
      // We AND this with TRUE so that we get a boolean instead of the raw
      //  value.
      return ((viAttributes & MOB_RECEIVE) AND TRUE);
   }

   CanAcceptOffer(who=$)
   {
      return ((viAttributes & MOB_BUYER OR viAttributes & MOB_RECEIVE)
               OR (who <> $ AND IsClass(who,&DM)));
   }

   TryGiveQuestItem(what = $, item_list = $)
   {
      local i, oQuestNode;

      if item_list = $
      {
         return;
      }

      // Check for if in the same room.
      if Send(what,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(what,@GetTrueName),what,"offered items to NPC",
               Send(self,@GetTrueName),"from distant RID",
               Send(Send(what,@GetOwner),@GetRoomNum));
         
         return;
      }

      // If there are active quest nodes, notify them   -AJM
      foreach i in item_list
      {
         // first, let's be sure the item CAN be given away.
         if NOT Send(i,@CanBeGivenToNPC)
            OR NOT Send(i,@CanBeUsedInQuests)
         {
            Post(self,@SayToOne,#target=what,#message_rsc=LS_cant_part,
                 #parm1=Send(i,@GetIndef),#parm2=Send(i,@GetName));

            return;
         }

         if NOT Send(what,@ReqLeaveHold,#what=i)
         {
            Post(what,@MsgSendUser,#message_rsc=Lm_cant_remove_item,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return;
         }

         foreach oQuestNode in plActiveQuestNodes
         {
            if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                    #item_offered=i)
            {
               return;
            }
         }
      }

      return;
   }

   ReqOffer(what = $, item_list = $)
   "Someone offered us something, figure out if we want it, etc. "
   "Return TRUE if the offer should go through, meaning that the monster will "
   "offer the value of the items in return."
   {
      local i,j, lArgList, iValueOffered, oQuestNode, bIsBuyer, bWarnAboutUnwantedItems;

      if item_list = $
      {
         return FALSE;
      }

      // Check for if in the same room.
      if Send(what,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(what,@GetTrueName),what,"offered items to NPC",
               Send(self,@GetTrueName),"from distant RID",
               Send(Send(what,@GetOwner),@GetRoomNum));
         
         return FALSE;
      }     

      // If there are active quest nodes, notify them   -AJM
      foreach i in item_list
      {
         /// first, let's be sure the item CAN be given away.
         if NOT Send(i,@CanBeGivenToNPC)
         {
            Post(self,@SayToOne,#target=what,#message_rsc=LS_cant_part,
                 #parm1=Send(i,@GetIndef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         if NOT Send(what,@ReqLeaveHold,#what=i)
         {
            Post(what,@MsgSendUser,#message_rsc=Lm_cant_remove_item,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         foreach oQuestNode in plActiveQuestNodes
         {
            if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                    #item_offered=i)
            {
               return FALSE;
            }
         }
      }

      bIsBuyer = Send(self,@MobIsBuyer);
      if (viAttributes & MOB_RECEIVE)
      {
         // If we also buy items, don't complain about being offered something
         // that we can't use for a quest.  Maybe we'll buy it.
         bWarnAboutUnwantedItems = (NOT Send(self, @MobIsVaultman)) AND
              (NOT bIsBuyer);
         if Send(self,@ReqGive,#what=what,#item_list=item_list,
                 #notify_about_unwanted_items = bWarnAboutUnwantedItems)
         {
            return FALSE;
         }

         // If we both buy items and receive them, fall through to the buy case.
         if NOT bIsBuyer
         {
            return FALSE;
         }
      }

      if bIsBuyer
      {
         if poCustomer <> $
         {
            Send(what,@MsgSendUser,#message_rsc=Lm_buyer_offer_busy,
                 #parm1=Send(self,@GetName));

            return FALSE;
         }

         iValueOffered = 0;

         foreach i in item_list
         {
            if NOT Send(what,@ReqLeaveHold,#what=i)
            {
               Post(what,@MsgSendUser,#message_rsc=Lm_cant_remove_item,
                    #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

               return FALSE;
            }

            if NOT Send(self,@ObjectDesired,#what=i)
            {
               Send(self,@SayToOne,#target=what,#message_rsc=Lm_buyer_unwanted);

               return FALSE;
            }

            iValueOffered += Send(i,@GetValue);
         }

         if iValueOffered = 0
         {
            Send(self,@SayToOne,#target=what,#message_rsc=Lm_buyer_no_value);

            return FALSE;
         }

         if NOT Send(self,@IsCustomerOkay,#who=what)
         {
            return FALSE;
         }

         return TRUE;
      }

      // Let DMs give monsters stuff - will drop on death.
      if IsClass(what,&DM)
      {
         return TRUE;
      }

      return FALSE;
   }

   ReqGive(what = $, item_list = $, notify_about_unwanted_items = TRUE)
   "Returns TRUE if we'll take everything that was offered."
   {
      local i, j, bWanted, oQuestNode, bAllWanted;

      bAllWanted = TRUE;

      foreach i in item_list
      {
         if NOT Send(what,@ReqLeaveHold,#what=i)
         {
            Post(what,@MsgSendUser,#message_rsc=LM_cant_remove_item,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         // If there are active quest nodes, notify them   -AJM
         foreach oQuestNode in plActiveQuestNodes
         {
            if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                    #item_offered=i)
            {
               return TRUE;
            }
         }

         bWanted = FALSE;
         bAllWanted = FALSE;
         foreach j in plWantedItems 
         {
            if IsClass(i,j)
            {
               // We were offered something we want.
               Send(self,@GotWantedItem,#obj=i,#who=what);
               bWanted = TRUE;

               break;
            }
         }

         // Were we offered something we dont want?
         if (NOT bWanted) AND notify_about_unwanted_items
         {
            Send(self,@GotUnwantedItem,#obj=i,#who=what);
         }
      }

      // Last chance.  Am I a vaultman?
      if Send(self,@MobIsVaultman)
      {
         Send(self,@VaultDeposit,#who=what,#lItems=item_list);

         return TRUE;
      }

      return bAllWanted;
   }

   GotWantedItem(obj = $, who = $)
   "We have been given an item on our wanted list. This is either a banker"
   "type, or a quest completion of some kind or an intrigue token."
   {
      // Handle the kludgy banker interface immediately.
      if (viAttributes & MOB_BANKER) AND IsClass(obj,&Money)
      {
         Send(self,@BankDeposit,#who=who,#amount=Send(obj,@GetNumber));

         return;
      }

      // We musta wanted the item for some other reason. So do special stuff
      // If we get a FALSE return, it means we didnt keep the item.
      if NOT Send(self,@CheckWhyWanted,#obj=obj,#who=who)
      {
         return;
      }

      // accepting some items makes NPC's happier or sadder
      Send(self,@AffectMood,#why=MOODMOD_ACCEPT_ITEM,#what=obj);

      if IsClass(obj,&Token) AND Send(SYS,@GetTokenGame) <> $
      {
         Send(Send(SYS,@GetTokenGame),@TokenDelivered,
              #what=obj,#who=who,#mob=self);

         return;
      }

      //Lets dispose of the offered item.
      if Send(obj,@IsStackable)
      {
         Send(who,@RemoveNumberItemFromPossession,#ToBeRemoved=obj);
      }

      Send(obj,@Delete);

      return;
   }

   GotUnwantedItem(obj = $, who = $)
   "Someone just randomly gave us an object we didnt really want."
   "They could be fishing for a quest, so occasionally, lets keep it."
   {
      // Quickly, lets check to see if it's a signet ring.  If so, give a
      //  special message.
      if IsClass(obj,&SignetRing)
      {
         Post(poOwner,@SomeoneSaid,#what=self,
              #string=LS_Signet_wrong,#type=SAY_RESOURCE,
              #parm1=Send(Send(obj,@GetRingOwner),@GetDef),
              #parm2=Send(Send(obj,@GetRingOwner),@GetName));

         return;
      }

      // Handle giving us a token.  In general, we don't want it.
      if IsClass(obj,&Token) AND NOT IsClass(self,&DragonFlyQueen)
      {
         Post(who,@MsgSendUser,#message_rsc=vrUnwanted_token,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         Send(obj,@OfferRejected);
         Send(who,@NewHold,#what=obj);

         return;
      }

      // So this really was a random offering it appears so lets act alive.
      // We say no thanks, and return the item to the giver.
      Post(who,@MsgSendUser,#message_rsc=vrUnwanted_give,
           #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
      if Send(obj,@IsStackable)
      {
         // Delete the numberitem because it was created special for the offer.
         // Giver still has all the original number.
         Send(obj,@Delete);
      }
      else
      {
         Send(who,@NewHold,#what=obj);
      }

      return;
   }

   //// Speech messages

   SomeoneSaid(what = $,type = $,string = $)
   "Takes the said string and if its from a user searches libraries for"
   "a response."
   {
      local i, lActionList, oLibrary, oQuestNode;

      // Are we supposed to hear things?
      if (NOT (viAttributes & MOB_LISTEN))
         OR string = $
      {
         propagate;
      }

      // Was it a user talking, another NPC, or myself?
      if NOT IsClass(what,&User)
      {
         if what = self OR NOT (viAttributes & MOB_LISTEN_MOB)
         {
            propagate;
         }
      }

      oLibrary = Send(SYS,@GetLibrary);

      if IsClass(what,&User)
      {
         // Anonymous (and morph) filter
         // Don't handle triggers normally if player's anonymous flag is set,
         // just say anonymous_response
         if (Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
              OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED))
            AND type <> SAY_DM
         {
            Send(what,@MsgSendUser,#message_rsc=monster_anonymous_response,
                  #parm1=Send(self,@GetName));

            return;
         }

         // Quest engine hook: if there are active quest nodes, notify them   -AJM
         foreach oQuestNode in plActiveQuestNodes
         {
            if Send(oQuestNode,@CheckCompletionCriteria,#who_tried=what,
                    #message=string)
            {
               return;
            }
         }
      }

      // Maybe it was just a simple speech trigger. So, we check and parse.
      lActionList = Send(oLibrary,@SearchSpeechLib,#target=what,#mob=self,#string=string);
      if lActionList <> $
      {
         Post(oLibrary,@ParseAction,#action=First(lActionList),
              #mob=self,#target=what);
         Send(self,@AddToSpamList,#mob_class=Nth(lActionList,2),
              #key_num=Nth(lActionList,3));
      }

      // Last but not least, is the player asking about one of my spells/skills?
      if (viAttributes & MOB_TEACHER)
      {
         Send(self,@SomeoneSaidLevel,#what=what,#string=string);
      }

      // The investigator can use "dm top accounts" or "dm PlayerName" to get
      //  info on accounts.
      if type = SAY_DM
         AND Send(self,@MobIsBanker)
         AND (Send(SYS,@GetInvestigator) = what)
      {
         if StringEqual(string,"top accounts")
         {
            Send(self,@ReportBankBalance,#number=10);

            propagate;
         }

         i = Send(SYS,@FindUserByString,#string=string);
         if i <> $
         {
            Send(self,@ReportBankBalance,#who=i);

            propagate;
         }
      }

      propagate;
   }

   SomeoneSaidLevel(what = $,type = $,string = $)
   {
      local iLevel;

      if (Nth(plFor_Sale,2) = $ AND Nth(plFor_Sale,3) = $)
         OR NOT StringContain(string,monster_level)
      {
         return FALSE;
      }

      iLevel = Send(Send(SYS,@GetLore),@CheckLevelString,#string=string);

      if iLevel = 0
      {
         return FALSE;
      }

      Post(self,@ReportLevel,#iLevel=iLevel);

      return TRUE;
   }

   ReportLevel(iLevel=0)
   {
      local i, oAbility, iNum, lAvailable;

      iNum = 0;
      foreach i in Nth(plFor_Sale,2)
      {
         oAbility = Send(SYS,@FindSkillByNum,#num=i);
         if iLevel = Send(oAbility,@GetLevel)
            AND Send(oAbility,@IsAccessible)
         {
            if oAbility <> $
            {
               lAvailable = Cons(oAbility,lAvailable);
            }
         }
      }

      foreach i in Nth(plFor_Sale,3)
      {
         oAbility = Send(SYS,@FindSpellByNum,#num=i);
         if iLevel = Send(oAbility,@GetLevel)
            AND Send(oAbility,@IsAccessible)
         {
            if oAbility <> $
            {
               lAvailable = Cons(oAbility,lAvailable);
            }
         }
      }

      if poOwner = $
      {
         return;
      }

      Send(self,@SendReportLevel,#lAvailable=lAvailable);

      return;
   }

   SendReportLevel(lAvailable=$)
   {
      local i, iNumAbilities, iNumRsc, iCounter;

      AddPacket(1,BP_SAID, 4,self, 4,Send(self,@GetName), 1,SAY_RESOURCE,
                4,monster_said_resource_str, 4,Send(self,@GetCapDef),
                4,Send(self,@GetName));

      if lAvailable = $
      {
         AddPacket(4, vrTeach_nothing);
         Send(poOwner,@SendCopyPacketAllInRoom);

         return;
      }

      // Add master rsc.
      AddPacket(4,vrTeach_message);

      iCounter = 0;
      iNumRsc = 0;

      iNumAbilities = Length(lAvailable);

      foreach i in lAvailable
      {
         iCounter++;

         if iNumAbilities > 1
         {
            if iCounter = iNumAbilities
            {
               iNumRsc = iNumRsc + 2;
               if IsClass(self,&KocatanBonePriestess)
               {
                  AddPacket(4,Send(self,@GetRandomSquawkRsc),4,Send(i,@GetName));
               }
               else
               {
                  AddPacket(4,monster_teach_and, 4,Send(i,@GetName));
               }
            }
            else
            {
               iNumRsc += 2;
               AddPacket(4,Send(i,@GetName), 4,monster_teach_comma);
            }
         }
         else
         {
            iNumRsc++;
            AddPacket(4,Send(i,@GetName));
         }
      }

      // If we didn't add enough location resources, make up for it
      // with blank ones.
      while iNumRsc++ < 12
      {
         AddPacket(4,monster_teach_blank);
      }

      Send(poOwner,@SendCopyPacketAllInRoom);

      return;
   }

   GetTeachMessage(level=$)
   {
      return vrTeach_message;
   }

   OnSpamList(mob_class = $, key_num = 0)
   "Return TRUE if speech item is on the spam list."
   {
      local lSpeechItem;

      if plSpamList = $
      {
         return FALSE;
      }

      if key_num = 0 OR mob_class = $
      {
         return FALSE;
      }

      // plSpamlist is [ [mob_class, key_num],...]
      // List should be small, so we'll just do a linear search.
      foreach lSpeechItem in plSpamList
      {
         if First(lSpeechItem) = mob_class AND Nth(lSpeechItem,2) = key_num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   AddToSpamList(mob_class = $, key_num = 0)
   "Add a speech item to the spam list."
   {
      if key_num = 0 OR mob_class = $
      {
         return;
      }

      // plSpamlist is [ [mob_class, key_num],...]
      plSpamList = Cons([mob_class,key_num], plSpamList);

      // Spam list cleared with random timer, so if we add something we need
      // to make sure that timer is set.
      if (ptRandom = $)
      {
         ptRandom = CreateTimer(self,@RandomTimer,viRandom_delay
                        + Random(0,viRandom_delay/2));
      }

      return;
   }

   //// Random Messages

   RandomTimer(timer = $,test = FALSE)
   "Handle a random timer, and set up the next one."
   {
      local lAction, iNum, oTarget, i, lActives, oLibrary;

      if (ptRandom <> $
         AND ptRandom <> timer)
      {
         DeleteTimer(ptRandom);
      }

      ptRandom = $;

      // Clear spam list
      plSpamList = $;

      if poOwner = $ OR NOT ((viAttributes & MOB_RANDOM) OR test)
      {
         return;
      }

      // This has to stay >0 or things go bad in library.
      iNum = Random(1,100);

      oLibrary = Send(SYS,@GetLibrary);
      lAction = Send(oLibrary,@SearchRandomLib,#mob=self,#percent=iNum);
      if lAction <> $
      {
         // we found an applicable random trigger, find a random user.
         iNum = 0;
         oTarget = $;
         foreach i in Send(poOwner,@GetHolderActive)
         {
            if IsClass(First(i),&User)
            {
               if Random(0,iNum) = 0
               {
                  oTarget = First(i);
               }

               ++iNum;
            }
         }

         if oTarget = $
         {
            Debug("BAD: RandomTimer expired without user present for mob ",
                  self, Send(self,@GetName));

            return;
         }

         Send(oLibrary,@ParseAction,#action=lAction,#mob=self,#target=oTarget);
      }

      if NOT test
      {
         ptRandom=CreateTimer(self,@RandomTimer,
                              viRandom_delay + Random(0,viRandom_delay/2));
      }

      return;
   }

   //// Other Trigger messages

   AmbientLightChanged(test = FALSE)
   "Triggered every Meridian hour (5 min).  Used to damp out mood swings and "
   "trigger time-of-day mood changes."
   {
      local iHour, iMoodMod;

      iHour = Send(SYS,@GetHour);

      if iHour = 6
      {
         Send(self,@AffectMood,#why=MOODMOD_DAWN);
         piSweepCounter = 0;
      }
      else if iHour = 18
      {
         Send(self,@AffectMood,#why=MOODMOD_DUSK);
      }

      // Damp out mood swings every 4 Meridian hours
      if (iHour % 4 = 0) OR test
      {
         // if in [-5, 5] do nothing
         if piMood >= -5 AND piMood <= 5
         {
            return;
         }

         // otherwise move halfway to [-5, 5]
         iMoodMod = ((Abs(piMood) - 5) / 2) * (piMood / Abs(piMood));
         Send(self,@SetMood,#new_mood=piMood-iMoodMod);
      }

      propagate;
   }

   UserEntered(who = $)
   "A User just entered the room."
   {
      return;
   }

   // A monster's attack may cause side effects.
   HitSideEffect(what=$,who=$,amount=0)
   "Called after every non-fatal monster hit."
   {
      local oEffect, iStrength, iDuration;

      // Who should be nil at this point, unless a player
      // is assuming the form of a monster.
      if who = $
      {
         who = self;
      }

      // Check for various effects.
      // Poison: Frequency scales with intellect, strength with intellect,
      // duration with mysticism.
      if viPoisonChance > 0
         AND Random(1,100) <= Bound(viPoisonChance * (50 + piIntellect) / 75,0,100)
         AND Send(what,@CanPoison)
      {
         oEffect = Send(SYS,@FindSpellByNum,#num=SID_POISON);
         iStrength = Send(self,@GetPoisonStrength,#amount=amount);
         iStrength = iStrength * (50 + piIntellect) / 75;
         iDuration = Send(self,@GetPoisonDuration,#amount=amount);
         iDuration = iDuration * (50 + piMysticism) / 75;
         if (Send(oEffect,@StartPoison,#who=what,#source=who,#duration=iDuration,
               #healthloss=iStrength * viPoisonHealth / 100,
               #manaloss=iStrength * viPoisonMana / 100,
               #vigorloss=iStrength * viPoisonVigor / 100))
         {
            // Only display hit/visual effect if poison was successful.
            Send(self,@IllusionHitEffectMessage,#who=who,#what=what,
                  #effect=$,#num=SID_POISON);
            Send(self,@PoisonVisualEffect,#what=what);
         }
      }

      // Bleed: Frequency scales with aim, strength with aim, duration with might.
      if viBleedChance > 0
         AND Random(1,100) <= Bound(viBleedChance * (50 + piAim) / 75,0,100)
         AND Send(what,@CanBleed)
      {
         oEffect = Send(SYS,@FindSpellByNum,#num=SID_BLEED);
         iStrength = Send(self,@GetBleedStrength,#amount=amount);
         iStrength = iStrength * Send(SETTINGS_OBJECT,@GetDrainFactor) / 100;
         iStrength = iStrength * (50 + piAim) / 75;
         iDuration = Send(self,@GetBleedDuration,#amount=amount);
         iDuration = iDuration * (50 + piMight) / 75;
         if Send(oEffect,@StartBleed,#who=what,#source=who,
               #strength=Random(iStrength / 5 * 4, iStrength),
               #duration=Random(iDuration / 5 * 4, iDuration))
         {
            Send(self,@IllusionHitEffectMessage,#who=who,#what=what,
                  #amount=(iStrength/100)*(iDuration/100)/100,#num=SID_BLEED);
         }
      }

      // Siphon: Frequency scales with mysticism, strength with mysticism, duration with intellect.
      if viSiphonChance > 0
         AND Random(1,100) <= Bound(viSiphonChance * (50 + piMysticism) / 75,0,100)
         AND Send(what,@CanSiphon)
      {
         oEffect = Send(SYS,@FindSpellByNum,#num=SID_SIPHON);
         iStrength = Send(self,@GetSiphonStrength,#amount=amount);
         iStrength = iStrength * Send(SETTINGS_OBJECT,@GetDrainFactor) / 100;
         iStrength = iStrength * (50 + piMysticism) / 75;
         iDuration = Send(self,@GetSiphonDuration,#amount=amount);
         iDuration = iDuration * (50 + piIntellect) / 75;
         if Send(oEffect,@StartSiphon,#who=what,#source=who,
               #strength=iStrength,#duration=iDuration)
         {
            Send(self,@IllusionHitEffectMessage,#who=who,#what=what,#num=SID_SIPHON);
         }
      }

      // Fatigue: Frequency scales with might, strength with might, duration with aim.
      if viFatigueChance > 0
         AND Random(1,100) <= Bound(viFatigueChance * (50 + piMight) / 75,0,100)
         AND Send(what,@CanFatigue)
      {
         oEffect = Send(SYS,@FindSpellByNum,#num=SID_FATIGUE);
         iStrength = Send(self,@GetFatigueStrength,#amount=amount);
         iStrength = iStrength * Send(SETTINGS_OBJECT,@GetDrainFactor) / 100;
         iStrength = iStrength * (50+piMight)/75;
         iDuration = Send(self,@GetFatigueDuration,#amount=amount);
         iDuration = iDuration * (50+piAim)/75;
         if Send(oEffect,@StartFatigue,#who=what,#source=who,
               #strength=iStrength,#duration=iDuration)
         {
            Send(self,@IllusionHitEffectMessage,#who=who,#what=what,#num=SID_FATIGUE);
         }
      }

      // Burn: Frequency scales with mysticism, strength with mysticism, duration with stamina.
      if viBurnChance > 0
         AND Random(1,100) <= Bound(viBurnChance * (50 + piMysticism) / 75,0,100)
         AND Send(what,@CanBurn)
      {
         oEffect = Send(SYS,@FindSpellByNum,#num=SID_BURN);
         iStrength = Send(self,@GetBurnStrength,#amount=amount);
         iStrength = iStrength * Send(SETTINGS_OBJECT,@GetDrainFactor) / 100;
         iStrength = iStrength * (50 + piMysticism) / 75;
         iDuration = Send(self,@GetBurnDuration,#amount=amount);
         iDuration = iDuration * (50 + piStamina) / 75;
         if Send(oEffect,@StartBurn,#who=what,#source=who,
               #strength=iStrength,#duration=iDuration)
         {
            Send(self,@IllusionHitEffectMessage,#who=who,#what=what,
                  #amount=(iStrength/100)*(iDuration/100)/100,#num=SID_BURN);
         }
      }

      return;
   }

   IllusionHitEffectMessage(who=$,what=$,effect=$,amount=0,num=$)
   {
      local rMessage, rAmount;

      if IsClass(who,&Player)
      {
         rAmount = monster_illusion_damage_blank;

         switch(num)
         {
         case SID_POISON:
            rMessage = vrIllusionPoison;
            break;
         case SID_BLEED:
            rMessage = vrIllusionBleed;
            rAmount = amount;
            break;
         case SID_SIPHON:
            rMessage = vrIllusionSiphon;
            break;
         case SID_FATIGUE:
            rMessage = vrIllusionFatigue;
            break;
         case SID_BURN:
            rMessage = vrIllusionBurn;
            break;
         }

         if rMessage <> $
         {
            Send(who,@MsgSendUser,#message_rsc=rMessage,
                  #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
                  #parm3=Send(what,@GetHisHer),#parm4=rAmount);
         }
      }

      return;
   }

   GetPoisonStrength(amount=$)
   {
      if viPoisonStrength <> $
      {
         return viPoisonStrength;
      }

      // Return a rate of 10% mob damage dealt per second.
      return Send(self,@GetDamage);
   }

   GetPoisonDuration(amount=$)
   {
      if viPoisonDuration <> $
      {
         return viPoisonDuration;
      }

      // Default duration of 10 seconds.
      return 10000;
   }

   PoisonVisualEffect(what=$)
   {
      if viPoisonVisualEffect <> $ AND IsClass(what,&Player)
      {
         Send(what,@EffectSendUserDuration,#effect=viPoisonVisualEffect,
            #duration=viPoisonVisualEffectDuration);

         if vrPoisonVisualEffectMessage <> $
         {
            Send(what,@MsgSendUser,#message_rsc=vrPoisonVisualEffectMessage);
         }
      }

      return;
   }

   GetBleedStrength(amount=$)
   {
      if viBleedStrength <> $
      {
         return viBleedStrength;
      }

      // Return a rate of 10% mob damage dealt per second.
      return Send(self,@GetDamage);
   }

   GetBleedDuration(amount=$)
   {
      if viBleedDuration <> $
      {
         return viBleedDuration;
      }

      // Default duration of 10 seconds.
      return 10000;
   }

   GetSiphonStrength(amount=$)
   {
      if viSiphonStrength <> $
      {
         return viSiphonStrength;
      }

      // Return a rate of 10% mob damage dealt per second.
      return Send(self,@GetDamage);
   }

   GetSiphonDuration(amount=$)
   {
      if viSiphonDuration <> $
      {
         return viSiphonDuration;
      }

      // Default duration of 10 seconds.
      return 10000;
   }

   GetFatigueStrength(amount=$)
   {
      if viFatigueStrength <> $
      {
         return viFatigueStrength;
      }

      // Return a rate of 10% mob damage dealt per second.
      return Send(self,@GetDamage);
   }

   GetFatigueDuration(amount=$)
   {
      if viFatigueDuration <> $
      {
         return viFatigueDuration;
      }

      // Default duration of 10 seconds.
      return 10000;
   }

   GetBurnStrength(amount=$)
   {
      if viBurnStrength <> $
      {
         return viBurnStrength;
      }

      // Return a rate of 10% mob damage dealt per second.
      return Send(self,@GetDamage);
   }

   GetBurnDuration(amount=$)
   {
      if viBurnDuration <> $
      {
         return viBurnDuration;
      }

      // Default duration of 10 seconds.
      return 10000;
   }

   KilledSomething(what=$,use_weapon=$)
   {
      local oOwner;

      if what = $
      {
         Debug("Bad info in killedsomething().");

         return;
      }

      // If we have a master, they are responsible for our kills.
      if poMaster <> $
      {
         if IsClass(what,&Player)
            AND IsClass(poMaster,&Player)
         {
            // If we killed an innocent, tell the master they're in trouble.
            if (NOT Send(poMaster,@CheckPlayerFlag,#flag=PFLAG_MURDERER))
               AND NOT (Send(what,@CheckPlayerFlag,#Flag=PFLAG_OUTLAW)
                  OR Send(what,@CheckPlayerFlag,#Flag=PFLAG_MURDERER))
            {
               Send(poMaster,@MsgSendUser,#message_rsc=vrMinion_trouble);
            }

            // Evil twins are dispelled by any player they kill.
            if IsClass(self,&EvilTwin)
            {
               Post(self,@Delete);
            }
         }

         // Our master handles the kill from here, since they
         // made us do it.
         return Send(poMaster,@KilledSomething,#what=what,
                     #use_weapon=use_weapon);
      }

      // If this is an apparition, and it has no master,
      // the caster of the apparition acts as the master for
      // tracking the results of monster kills, but not any
      // accidental player kills (or player minion kills).
      if poApparitionCaster <> $
      {
         return Send(poApparitionCaster,@KilledSomething,#what=what,
                     #use_weapon=use_weapon);
      }

      // If we don't have a master, proceed as normal.
      oOwner = Send(what,@GetOwner);

      if oOwner <> $
      {
         Send(oOwner,@SomethingKilled,#what=self,#victim=what);
      }

      if what = self
      {
         Post(what,@Killed,#what=self);
      }
      else
      {
         Send(what,@Killed,#what=self);
      }

      return;
   }

   CreateDeadBody(killer=$)
   {
      local oBody;

      if vrDead_icon <> $
      {
         oBody = Create(&DeadBody,#victim=self,#killer=killer,
                     #drawfx=viDead_drawfx,#BodyTranslation=piColor_translation);
      }

      return oBody;
   }

   GetDeadName()
   {
      return vrDead_name;
   }

   GetDeadIcon()
   {
      return vrDead_Icon;
   }

   Killed(what=$)
   "The mob was just killed."
   {
      local i,val,oBody,hReputation;

      // If the monster was just killed, assume it did itself in.
      if what = $
      {
         what = self;
      }

      if (viDefault_behavior & AI_NPC)
      {
         return;
      }

      if poOwner <> $
      {
         // If a monster was the killer, and it has a master, set 'what'
         // to the master. This *should* be handled by the killer in
         // KilledSomething, but to be safe (and because quests are
         // checked here) we should check again for a master.
         if IsClass(what,&Monster)
            AND Send(what,@GetMaster) <> $
         {
            what = Send(what,@GetMaster);
         }

         oBody = Send(self,@CreateDeadBody,#killer=what);

         if oBody <> $
         {
            Send(poOwner,@NewHold,#what=oBody,#new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col,
                  #new_angle=Send(self,@GetAngle));
         }

         if vrSound_death <> $
         {
            Send(poOwner,@SomethingWaveRoom,#what=oBody,#wave_rsc=vrSound_death,
                  #flags=SOUND_RANDOM_PITCH);
         }

         if Send(poOwner,@CanDropMonsterLoot)
         {
            // Notify the quest engine, to check if a quest is affected -AJM
            Send(Send(SYS,@GetQuestEngine),@MonsterKilled,#dead_monster=self,
                  #killing_player=what,#corpse=oBody);

            Send(EVENTENGINE_OBJECT,@MonsterKilled,#dead_monster=self,
                  #killing_player=what,#corpse=oBody);

            if (piReputationGroup <> REP_NEUTRAL
               AND Send(SETTINGS_OBJECT,@GetMonsterFactionEnabled))
            {
               hReputation = Send(what,@GetReputationHash);
               
               // attempt to create a players rep hash if it does not exist
               if (hReputation=$)
               {
                  hReputation = Send(what,@CreateReputationHash);

                  if (hReputation = $)
                  {
                     Debug("Unable to get player reputation hash, not changing reputation");
                  }
               }
               
               // now actually do the rep chenge unless there is no hash
               if (hReputation <> $)
               {
                  val=GetTableEntry(hReputation,piReputationGroup);
                  if (val <> $)
                  {
                     --val;
                     if (val >= -20000)
                     {
                        DeleteTableEntry(hReputation,piReputationGroup);
                        AddTableEntry(hReputation,piReputationGroup,val);
                     }
                  }
                  else
                  {
                     AddTableEntry(hReputation,piReputationGroup,-1);
                  }

                  Send(what,@MsgSendUser,
                     #message_rsc=monster_faction_negative_msg,
                     #parm1=Send(self,@GetMonsterFactionRSC,
                              #faction=piReputationGroup));

                  // Adjust reputation with enemies of this monster
                  foreach i in plReputationEnemies
                  {
                     val=GetTableEntry(hReputation,i);
                     if (val <> $)
                     {
                        ++val;
                        if (val <= 20000)
                        {
                           DeleteTableEntry(hReputation,i);
                           AddTableEntry(hReputation,i,val);
                        }
                     }
                     else
                     {
                        AddTableEntry(hReputation,i,1);
                     }

                     Send(what,@MsgSendUser,
                     #message_rsc=monster_faction_positive_msg,
                     #parm1=Send(self,@GetMonsterFactionRSC,#faction=i));
                  }
               }
            }
            Send(self,@CreateTreasure,#who=what,#corpse=oBody);
         }

         // Delete here so we don't accidentally "kill" then delete system
         //  template monsters.
         Send(self,@Delete);
      }

      return;
   }

   GetMonsterFactionRSC(faction = $)
   {
      local factionRSC;

      switch(faction)
      {
         case REP_FAROL:
            factionRSC = monster_faction_farol;
            break;

         case REP_ORC:
            factionRSC = monster_faction_orc;
            break;

         case REP_TROLL:
            factionRSC = monster_faction_troll;
            break;

         case REP_FARNOHL:
            factionRSC = monster_faction_farnohl;
            break;

         case REP_LICH:
            factionRSC = monster_faction_lich;
            break;

         case REP_PSAVAR:
            factionRSC = monster_faction_psavar;
            break;

         case REP_KKAVAR:
            factionRSC = monster_faction_kkavar;
            break;

         case REP_CTAVAR:
            factionRSC = monster_faction_ctavar;
            break;

         case REP_FEY_GOOD:
            factionRSC = monster_faction_fey_good;
            break;

         case REP_FEY_EVIL:
            factionRSC = monster_faction_fey_evil;
            break;

         case REP_FROGMEN:
            factionRSC = monster_faction_frogmen;
            break;

         case REP_HERETIC:
            factionRSC = monster_faction_heretic;
            break;

         case REP_UNDEAD:
            factionRSC = monster_faction_undead;
            break;

         default:
            factionRSC = monster_faction_unspecified;
            break;
      }

      return factionRSC;
   }

   //// SERVICE MESSAGES

   Repair()
   "This is just a stub"
   {
      return;
   }

   Offer(what = $,item_list = $)
   "Offer the player money in exchange for their goods - MOB_BUYER"
   {
      local i, iValue_offered, iAdd, x, y;

      // The Faction Pricing bonus was selling items to NPCs at higher prices
      // than the new price.  This has been taken out.

      if (viAttributes & MOB_BUYER
         OR viAttributes & MOB_RECEIVE)
      {
         iValue_offered = 0;
         foreach i in item_list
         {
            x = Send(i,@GetValue) * (100 - 10*viMerchant_markup) / 100;
            iAdd = Bound(x,1,$);

            iValue_offered += iAdd;
         }

         poCustomer = what;

         plOffer_items = [ Create(&Money,#number=iValue_offered) ];
         Send(what,@CounterOffer,#item_list=plOffer_items);
         ptCancelOffer = CreateTimer(self,@CancelOfferTimer,viCancel_offer_time);
      }
      else if IsClass(what,&DM)
      {
         Send(what,@CounterOffer,#item_list=$);
      }

      return;
   }

   CancelOfferTimer()
   {
      ptCancelOffer = $;

      Post(self,@SayToOne,#target=poCustomer,#message_rsc=Lm_buyer_timeout);
      Send(poCustomer,@OfferCanceled);
      Send(self,@OfferCanceled);

      return;
   }

   OfferCanceled()
   {
      // if called from timer, no timer left.  If user cancelled, delete timer.

      if ptCancelOffer <> $
      {
         DeleteTimer(ptCancelOffer);
      }

      ptCancelOffer = $;

      poCustomer = $;
      plOffer_items = $;

      return;
   }

   AcceptOffer()
   "Transfer the purchased merchandise - MOB_BUYER"
   {
      local i,oHolder,lTake_items;

      // set the stuff where the user can get to it
      oHolder = Send(SYS,@GetSystemHolder2);
      foreach i in plOffer_items
      {
         Send(oHolder,@NewHold,#what=i);
         if IsClass(i,&Money)
         {
            Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=Send(i,@GetNumber));
         }
      }

      // take stuff the user put there
      oHolder = Send(SYS,@GetSystemHolder1);
      foreach lTake_items in [ Send(oHolder,@GetHolderActive),
                           Send(oHolder,@GetHolderPassive) ]
      {
         foreach i in lTake_items
         {
            Send(self,@NewHold,#what=i);
         }
      }

      // kill the cancel offer timer
      Send(self,@OfferCanceled);

      return TRUE;
   }

   VaultDeposit(who=$,lItems=$)
   {
      local i, oVault, iFee, oMoney, iCash;

      if NOT Send(self,@MobIsVaultman)
      {
         return;
      }

      oVault = Send(SYS,@FindVaultByNum,#num=Send(self,@GetVaultNum));
      if oVault = $
      {
         Debug("Nil vault!");

         return;
      }

      iFee = 0;
      foreach i in lItems
      {
         // Can't store anything without any bulk, such as gold
         if Send(i,@GetBulk) <= 0 
         {
            Send(self,@SayToOne,#message_rsc=vaultman_nogold,#target=who,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         if NOT Send(who,@ReqLeaveHold,#what=i)
         {
            Send(self,@SayToOne,#message_rsc=vaultman_nocursed,#target=who,
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));

            return FALSE;
         }

         if NOT Send(i,@CanBeStoredInVault)
         {
            Send(self,@SayToOne,#message_rsc=vaultman_cant_part,#target=who,
                 #parm1=Send(i,@GetName));

            return FALSE;
         }

         iFee += Send(self,@GetVaultDepositFee,#what=i,#who=who);
      }

      oMoney = Send(who,@GetMoneyObject);
      if oMoney = $
      {
         // No cash.
         iCash = 0;
      }
      else
      {
         iCash = Send(oMoney,@GetValue);
      }

      if iCash < iFee AND iFee <> 0
      {
         Send(self,@SayToOne,#target=who,#message_rsc=vaultman_nodeposit_cash,
              #parm1=iFee);

         return;
      }

      // this checks bulk of deposited items.
      if NOT Send(oVault,@CanDepositItems,#who=who,#lItems=lItems)
      {
         Send(self,@SayToOne,#message_rsc=vaultman_fullvault,#target=who);

         return FALSE;
      }

      // passed all checks.  put the stuff in.
      Send(oVault,@DepositItems,#lItems=lItems,#who=who);

      if iFee <> 0
      {
         Send(oMoney,@SubtractNumber,#number=iFee);
         Send(self,@SayToOne,#message_rsc=vaultman_Thanks_amount,#target=who,
              #parm1=iFee);
      }
      else
      {
         Send(self,@SayToOne,#message_rsc=vaultman_deposit_thanks,#target=who);
      }

      Send(self,@AffectMood,#why=MOODMOD_VAULT_DEPOSIT);

      return;
   }

   GetVaultDepositFee(what=$)
   "Default cost is 1 gp per stone."
   {
      return Send(what,@GetBulk);
   }

   GetVaultRetrievalFee(what=$)
   "Default cost no cost.  However, expensive places can charge more."
   {
      return 0;
   }

   VaultWithdraw(what=$,lItems=$,number_list = $)
   {
      local i, j, iFee, iCash, lStored, oVault, iBulk, oMoney, bFound,
            oSafeBox, lNumbers, iCount, bFailed;

      if what = $ OR lItems = $
      {
         return;
      }

      oMoney = Send(what,@GetMoneyObject);
      if oMoney = $
      {
         // No cash.
         iCash = 0;
      }
      else
      {
         iCash = Send(oMoney,@GetValue);
      }

      oVault = Send(SYS,@FindVaultByNum,#num=Send(self,@GetVaultNum));
      oSafeBox = Send(oVault,@GetPlayerSafeBox,#who=what);

      if oSafeBox = $
      {
         Send(self,@SayToOne,#target=what,#message_rsc=vaultman_noAccount);

         return;
      }

      iFee = 0;
      iBulk = 0;
      iCount = 0;
      bFound = FALSE;

      // Make sure the player really has this item in storage.
      foreach i in lItems
      {
         foreach j in Send(oSafeBox,@GetHolderPassive)
         {
            if i = j
            {
               bFound = TRUE;
            }

            if Send(i,@IsStackable)
               AND GetClass(i) = GetClass(j)
            {
               // Check if we have a valid number list. Check is done here
               // as we don't need a number list for non-number items.
               if number_list = $
               {
                  return;
               }

               iCount = iCount + 1;
               if Nth(number_list,iCount) > Send(j,@GetNumber)
               {
                  Send(self,@SayToOne,#target=what,
                        #message_rsc=vaultman_not_enough,
                        #parm1=Send(i,@GetName));

                  return;
               }

               bFound = TRUE;
            }
         }

         if NOT bFound
         {
            Post(self,@SayToOne,#target=what,#message_rsc=vaultman_dont_have,
                 #parm1=Send(i,@getindef),#parm2=Send(i,@GetName));

            return;
         }

         iFee = iFee + Send(self,@GetVaultRetrievalFee,#what=i);

         if Send(i,@IsStackable)
            AND number_list <> $
            AND Length(number_list) >= iCount
         {
            iBulk += ((Send(i,@GetBulk) * Nth(number_list,iCount))
                        / Send(i,@GetNumber));
         }
         else
         {
            iBulk += Send(i,@GetBulk);
         }
      }

      // Does the player have enough ca$h?
      if iCash < iFee AND iFee <> 0
      {
         Send(self,@SayToOne,#target=what,
              #message_rsc=vaultman_nowithdraw_cash);

         return;
      }

      //if Send(what, @GetBulkMax) <> $ AND
      //   (iBulk + Send(what,@GetBulkHold)) > Send(what,@GetBulkMax)
      //{
      //   Send(self,@SayToOne,#target=what,#message_rsc=vaultman_no_room);
      //
      //   return;
      //}

      // The next line added to handle player specified amounts
      lNumbers = number_list;
      bFailed = FALSE;

      // At this point, we're pretty sure it's all legal.
      foreach i in lItems
      {
         // Don't bother calling ReqMewHold.  It just checks weight,
         // which you already know is legal.
         // Adding this check would be difficult.
         if Send(i,@ReqNewOwner,#what=what)
         {
            if Send(i,@IsStackable)
            {
               if NOT Send(oVault,@WithdrawFromStorage,#what=i,#who=what,
                    #count=First(lNumbers))
               {
                  bFailed = TRUE;
                  break;
               }

               lNumbers = Rest(lNumbers);
            }
            else
            {
               if NOT Send(oVault,@WithdrawFromStorage,#what=i,#who=what,#count=1)
               {
                  bFailed = TRUE;
                  break;
               }
            }
         }
      }

      if iFee <> 0
      {
         Send(oMoney,@SubtractNumber,#number=iFee);
         if bFailed
         {
            Send(self,@SayToOne,#target=what,#message_rsc=vaultman_withdraw_failed);
         }
         else
         {
            Send(self,@SayToOne,#message_rsc=vaultman_Thanks_amount,#target=what,
                  #parm1=iFee);
         }
      }
      else
      {
         if bFailed
         {
            Send(self,@SayToOne,#target=what,#message_rsc=vaultman_withdraw_failed);
         }
         else
         {
            Send(self,@SayToOne,#target=what,#message_rsc=vaultman_thanks);
         }
      }

      return;
   }

   BankBalance(who=$)
   {
      local oBank;

      if NOT Send(self,@MobIsBanker)
      {
         return;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));
      Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
           #string=Lm_bnkr_balance,#parm1=Send(oBank,@GetAccount,#what=who));

      return;
   }

   ReportBankBalance(who=$,number=0)
   {
      local oBank, lTops, oSnoop;

      if NOT Send(self,@MobIsBanker)
      {
         return FALSE;
      }

      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop = $
      {
         return FALSE;
      }

      if number = 0 AND who = $
      {
         return FALSE;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return FALSE;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));

      if who <> $
      {
         Send(oSnoop,@MsgSendUser,#message_rsc=monster_report_balance,
              #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
              #parm3=Send(who,@GetUserName),#type3=STRING_RESOURCE,
              #parm4=Send(oBank,@GetAccount,#what=who));
      }
      else
      {
         lTops = Send(oBank,@FindTopAccounts,#number=number);
         foreach who in lTops
         {
            Send(oSnoop,@MsgSendUser,#message_rsc=monster_report_balance,
               #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
               #parm3=Send(who,@GetUserName),#type3=STRING_RESOURCE,
               #parm4=Send(oBank,@GetAccount,#what=who));
         }
      }

      return TRUE;
   }

   BankDeposit(who=$, amount = 0)
   {
      local oMoney, oBank, iBankAmt;

      if NOT Send(self,@MobIsBanker)
      {
         return;
      }

      if amount <= 0
      {
         return;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return;
      }

      oMoney = Send(who,@GetMoneyObject);
      if oMoney = $
      {
         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_not_enough_deposit,#parm1=0);

         return;
      }

      if Send(oMoney,@GetValue) < amount
      {
         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_not_enough_deposit,
              #parm1=Send(oMoney,@GetValue));

         return;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));
      iBankAmt = Send(oBank,@GetAccount,#what=who);

      // Check for integer overflow.
      if (iBankAmt = MAX_KOD_INT)
      {
         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_acct_full);

         return;
      }
      else if (iBankAmt + amount < 0)
      {
         amount = MAX_KOD_INT - iBankAmt;
         // Re-check amount, just to be sure.
         if Send(oMoney,@GetValue) < amount
         {
            Debug("Error modifying bank deposit amount for ",
                  Send(who,@GetTrueName),"amt: ",amount," bank amt: ",iBankAmt);

            return;
         }

         Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
               #string=Lm_bnkr_acct_almost_full,#parm1=amount);
      }

      Send(oMoney,@SubtractNumber,#number=amount);
      Send(oBank,@DepositAccount,#what=who,#amount=amount);

      Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
           #string=Lm_bnkr_did_deposit,
           #parm1=Send(oBank,@GetAccount,#what=who));

      Send(self,@AffectMood,#why=MOODMOD_BANK_DEPOSIT);

      if Send(SYS,@IsSuspect,#who=who)
      {
         Send(self,@ReportBankBalance,#who=who);
      }

      return;
   }

   BankWithdraw(who = $, amount = 0)
   {
      local iPlayerAmt, iBankAmt, oMoney, oBank;

      if NOT Send(self,@MobIsBanker)
      {
         return;
      }

      if amount < 0
      {
         return;
      }

      if Send(self,@GetBankNum) = $
      {
         Debug("BAD: Banker has no bankID",vrname,self);

         return;
      }

      oBank = Send(SYS,@FindBankByNum,#num=Send(self,@GetBankNum));
      iBankAmt = Send(oBank,@WithdrawAccount,#what=who);

      if iBankAmt = 0
      {
         Post(who,@SomeoneSaid,#what=self,#string=Lm_bnkr_no_account,
              #type=SAY_RESOURCE);

         return;
      }

      if amount > iBankAmt
      {
         Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt);
         Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
              #string=Lm_bnkr_not_enough_withdraw,#parm1=iBankAmt);

         return;
      }

      oMoney = Send(who,@GetMoneyObject);
      if oMoney = $
      {
         oMoney = Create(&Money,#number=amount);
         Send(who,@NewHold,#what=oMoney);
      }
      else if (Send(oMoney,@GetNumber) + amount) <= 0
      {
         iPlayerAmt = Send(oMoney,@GetNumber);
         if iPlayerAmt = MAX_KOD_INT
         {
            Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt);
            Post(who,@SomeoneSaid,#what=self,#string=Lm_bnkr_player_all_full,
                  #type=SAY_RESOURCE);

            return;
         }
         else if (iPlayerAmt + amount) <= 0
         {
            amount = MAX_KOD_INT - iPlayerAmt;
            Post(who,@SomeoneSaid,#what=self,#string=Lm_bnkr_player_full,
                  #type=SAY_RESOURCE,#parm1=amount);

            if amount > iBankAmt
            {
               Debug("Error giving player ",Send(who,@GetTrueName),amount,
                  " shillings from total ",iBankAmt,"!. Player has ",iPlayerAmt);
               Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt);

               return;
            }
         }
      }
      else
      {
         Send(oMoney,@AddNumber,#number=amount);
      }

      Send(oBank,@DepositAccount,#what=who,#amount=iBankAmt-amount);

      // Send this message even if we gave the almost full one - players are
      // used to seeing this message on a successful transaction.
      Post(who,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
            #string=Lm_bnkr_did_withdraw,#parm1=amount);

      Send(self,@AffectMood,#why=MOODMOD_BANK_WITHDRAWAL);

      if Send(SYS,@IsSuspect,#who=who)
      {
         Send(self,@ReportBankBalance,#who=who);
      }

      return;
   }

   Buy(what = $,item_list = $,number_list = $)
   "Handle things having to do with mobs who have stuff to sell. "
   "This is used for both teachers and sellers"
   {
      local i, j, bFound, oBuy, oMoney, iPrice, iPriceOne, lNumbers,
            iAmount, oItemAtt, iCan_hold, oSplit; 

      // Ensure that buyer and seller are in the same room
      if Send(what,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(what,@GetTrueName),what," tried to buy items "
               "from ",Send(self,@GetTrueName)," while in distant RID ",
               Send(Send(what,@GetOwner),@GetRoomNum));

         return FALSE;
      }

      if NOT Send(self,@IsCustomerOkay,#who=what)
      {
         return;
      }

      if Send(self,@MobIsVaultman)
      {
         Send(self,@VaultWithdraw,#what=what,#lItems=item_list,
               #number_list=number_list);
         Send(self,@AffectMood,#why=MOODMOD_VAULT_WITHDRAWAL);

         return;
      }

      // The next line added to handle player specified amounts
      lNumbers = number_list;

      // Walk the objects the user selected as wanting to purchase from
      // our Sale list
      foreach i in item_list
      {
         // Find the dude's money.  Do this each time in case we exactly use it
         // up.

         // Get the amount of money for standard amount
         oMoney = Send(what,@GetMoneyObject);

         // Get the price for that amount
         iPriceOne = Send(self,@GetPrice,#what=i,#who=what);

         // Init iPrice to the cost of one item.
         iPrice = iPriceOne;

         if IsClass(i,&Item)
         {
            // If the item is an item (not a skill)
            if Send(i,@IsStackable)
            {
               // Check if we have a valid number list. Check is done here
               // as we don't need a number list for non-number items.
               if lNumbers = $
               {
                  continue;
               }
               // See how many the player wants.
               iAmount = First(lNumbers);

               if (iAmount = $)
               {
                  iAmount = 1;
               }

               // Make sure requested number of items is within the
               // limits. If selling from inventory, we can only sell
               // as many as we have.
               if vbSellFromInventory
               {
                  iAmount = Bound(iAmount,1,Send(i,@GetNumber));
               }
               else
               {
                  iAmount = Bound(iAmount,1,MAX_BUY_AMOUNT);
               }

               // Make sure cost for 1 item is at least one gold coin.
               iPriceOne = Bound(iPriceOne, 1, $);

               // Now figure price
               iPrice = iPriceOne * iAmount;

               // Make sure we have a price of at least one gold coin
               iPrice = Bound(iPrice, 1, $);

               // Move to next number in the list.
               lNumbers = Rest(lNumbers);
            }
         }

         // Does player have enough money to buy it?
         if oMoney = $ OR Send(oMoney,@GetValue) < iPrice
         {
            Post(poOwner,@SomeoneSaid,#what=self,#string=vrMrcnt_too_costly,
                  #type=SAY_RESOURCE,#parm1=Send(i,@GetDef),
                  #parm2=Send(i,@GetName));

            continue;
         }

         // Make sure the item is really for sale from this mob.
         bFound = FALSE;
         foreach j in Send(self,@GetForSale,#who=what)
         {
            if i = j
            {
               bFound = TRUE;
            }
         }

         if NOT bFound
         {
            Post(poOwner,@SomeoneSaid,#what=self,
                  #string=Lm_mrcnt_not_selling,#type=SAY_RESOURCE);

            continue;
         }

         if IsClass(i,&Item)
         {
            if Send(i,@IsStackable)
            {
               oBuy = Create(GetClass(i),#number=iAmount,#model=i);
            }
            else if vbSellFromInventory
            {
               // Selling the item itself, or a copy?
               oBuy = i;
            }
            else
            {
               oBuy = Create(GetClass(i),#model=i);
            }

            if Send(what,@ReqNewHold,#what=oBuy)
               AND Send(oBuy,@ReqNewOwner,#what=what)
            {
               // Get rid of the item from our inventory?
               if vbSellFromInventory
               {
                  if Send(i,@IsStackable)
                  {
                     // Sold all of the item?
                     if Send(i,@GetNumber) = iAmount
                     {
                        SetNth(plFor_Sale,1,DelListElem(First(plFor_Sale),i));
                     }

                     Send(i,@SubtractNumber,#Number=iAmount);
                  }
                  else
                  {
                     // Start the go bad timer.
                     if IsClass(i,&SpellItem)
                     {
                        Send(i,@StartGoBadTimer);
                     }

                     SetNth(plFor_Sale,1,DelListElem(First(plFor_Sale),i));
                  }
               }

               // Add item to buyer's inventory
               Send(what,@NewHold,#what=oBuy);
               Send(oMoney,@SubtractNumber,#number=iPrice);
               Send(self,@RemoveFromConditionalList,
                     #obj=Send(self,@GetObjectOnConditionalList,
                     #class=GetClass(i)));

               Send(self,@AffectMood,#why=MOODMOD_SELL_ITEM,#what=oBuy);

               if Send(oBuy,@HasAttribute,#ItemAtt=IA_SELL_INFO)
               {
                  oItemAtt = Send(oBuy,@GetAttributeData,
                                    #ItemAtt=IA_SELL_INFO);
                  Post(poOwner,@SomeoneSaid,#what=self,#string=Nth(oItemAtt,2),
                        #type=SAY_RESOURCE);
               }
            }
            else
            {
               // Check if this is a number item we're buying too much of.
               if Send(oBuy,@IsStackable)
                  AND Send(what,@GetNumberCanHold,#what=oBuy) > 0
               {
                  iCan_hold = Send(what,@GetNumberCanHold,#what=oBuy);
                  if iCan_hold > 0
                  {
                     oSplit = Send(oBuy,@Split,#number=iCan_hold);
                     if Send(oBuy,@ReqNewOwner,#what=oSplit)
                     {
                        Send(oMoney,@SubtractNumber,
                              #number=iPriceOne * Send(oSplit,@GetNumber));
                        Send(i,@SubtractNumber,#Number=Send(oSplit,@GetNumber));
                        Send(what,@NewHold,#what=oSplit);
                        Post(poOwner,@SomeoneSaid,#what=self,
                              #string=Lm_mrcnt_can_give_some,
                              #type=SAY_RESOURCE,#parm1=Send(oBuy,@GetDef),
                              #parm2=Send(oBuy,@GetName));
                              
                        Send(self,@RemoveFromConditionalList,
                           #obj=Send(self,@GetObjectOnConditionalList,
                           #class=GetClass(i)));

                        Send(self,@AffectMood,#why=MOODMOD_SELL_ITEM,#what=oBuy);

                        if Send(oBuy,@HasAttribute,#ItemAtt=IA_SELL_INFO)
                        {
                           oItemAtt = Send(oBuy,@GetAttributeData,
                                           #ItemAtt=IA_SELL_INFO);
                           Post(poOwner,@SomeoneSaid,#what=self,
                               #string=Nth(oItemAtt,2),
                               #type=SAY_RESOURCE);
                        }
                        Send(oBuy,@Delete);
                     }
                  }
               }
               else
               {
                  // Buyer can't accept the item for some reason.
                  Post(poOwner,@SomeoneSaid,#what=self,#string=Lm_mrcnt_cant_give,
                        #type=SAY_RESOURCE,#parm1=Send(oBuy,@GetDef),
                        #parm2=Send(oBuy,@GetName));
                  Send(oBuy,@Delete);
               }
            }
         }
         else
         {
            // It's a skill or spell which we know to be legal to "sell"
            // so go ahead and add it....
            if IsClass(i,&Skill)
            {
               Send(what,@AddSkill,#num=Send(i,@GetSkillNum));
            }
            else
            {
               Send(what,@AddSpell,#num=Send(i,@GetSpellNum));
            }
            Send(oMoney,@SubtractNumber,#number=iPrice);
         }
      }

      Send(self,@ItemBoughtHook,#buyer=what);

      return;
   }

   ItemBoughtHook(buyer = $)
   "Hook called after someone has bought something from us"
   {
      return;
   }

   //// Utility messages

   GetOccupation()
   {
      return viOccupation;
   }

   NewMaxMana(amount=0)
   {
      local iPrev_max;

      iPrev_max = piMax_mana;
      piMax_mana += amount;

      return (piMax_mana - iPrev_max);
   }

   MonsterCombatCheck()
   "Returns FALSE if a monster can't currently engage in combat."
   {
      if (piBehavior & AI_NOFIGHT)
      {
         return FALSE;
      }

      return TRUE;
   }

   MonsterCombatAction(distance=0,sight=TRUE)
   "Figure out what the monster is going to attack with."
   "Depending on our action, return an appropriate delay."
   {
      local i, iPriority, lActions, lAction, iNum, oSpell, iAttacks,
         iMana, iVigor, iFactor, iSpellPower, lTargets, iDelay, iPowerLevel,
         oSpin, iAction, oTarget, oInjured, iHealthPercent, bAttack;

      bAttack = FALSE;

      // Let's get the attack check out of the way.
      if Send(poOwner,@ReqSomethingAttack,#what=self,#victim=poTarget,#use_weapon=self)
      {
         bAttack = TRUE;
      }

      // We are scared but not cornered. Cast a heal or run!
      if (Send(self,@HealthBelowWimpy) AND NOT (piBehavior & AI_CORNERED))
      {
         foreach i in plActions
         {
            if First(i) = SKID_MINIMUM
            {
               lActions = Cons(i,lActions);
            }
            else if Nth(i,8) = COMBAT_ACTION_HEAL
               AND (Nth(i,2) < piMana)
            {
               lActions = Cons(i,lActions);
            }
         }
      }
      // We're not scared but we've lost sight of our target or can't attack it
      // directly. We are free to do anything else though.
      else if NOT (sight OR (piBehavior & AI_FIGHT_THROUGH_WALLS)) OR NOT bAttack
      {
         foreach i in plActions
         {
            if Nth(i,8) <> COMBAT_ACTION_HARM
               AND (Nth(i,2) < piMana)
               AND (Nth(i,4) > distance)
            {
               lActions = Cons(i,lActions);
            }
         }
      }
      // We got a clear target and we're not scared! Use any tool at our disposal!
      else
      {
         // Sort out any actions in our action list that can't reach the
         // target or that we don't have the resources for.
         foreach i in plActions
         {
            if (Nth(i,2) < piMana)
               AND ((Nth(i,4) > distance)
                  OR (Nth(i,8) <> COMBAT_ACTION_HARM))
            {
               lActions = Cons(i,lActions);
            }
         }
      }

      // Double check if the monster can perform basic actions.
      foreach i in lActions
      {
         iNum = First(i);

         if iNum = SKID_MINIMUM
         {
            if (piBehavior & AI_NOMOVE) OR (piBehavior & AI_CORNERED)
            {
               lActions = DelListElem(lActions,i);
               Send(self,@SetBehaviorFlag,#flag=AI_CORNERED,#value=FALSE);
            }
         }
         else if (piBehavior & AI_NOFIGHT)
         {
            lActions = DelListElem(lActions,i);
         }
         else if ((iNum = SKID_FIRE) AND (distance <= piMeleeRange*piMeleeRange))
            AND NOT (IsClass(self,&Reflection) OR IsClass(self,&EvilTwin))
         {
            lActions = DelListElem(lActions,i);
         }
         else if ((iNum = SKID_SPIN) AND (Length(Send(self,@GetTargetsInRange)) < 2))
         {
            lActions = DelListElem(lActions,i);
         }
      }

      // It's time to look at other potential targets. Check if we or a loved one are injured.
      iHealthPercent = Send(self,@GetExactHealth)/Send(self,@GetMaxHealth);
      oInjured = Send(self,@GetClosestInjured);

      if (oInjured <> $)
      {
         if (iHealthPercent < Send(oInjured,@GetExactHealth)/Send(oInjured,@GetMaxHealth))
         {
            oInjured = self;
         }
      }
      else if (iHealthPercent < 75)
      {
         oInjured = self;
      }

      // Check the actual spells in our action list for castability. Provide the matching
      // target depending on the spell chosen.
      foreach i in lActions
      {
         iNum = First(i);

         if iNum < SKID_MINIMUM
         {
            switch(Nth(i,8))
            {
               case COMBAT_ACTION_HEAL:
                  oTarget = oInjured;
                  break;
               case COMBAT_ACTION_BUFF:
                  oTarget = poLeader;
                  break;
               case COMBAT_ACTION_NEUTRAL:
                  oTarget = self;
                  break;
               default:
                  oTarget = poTarget;
                  break;
            }

            if oTarget = $
            {
               lActions = DelListElem(lActions,i);
            }
            else
            {
               oSpell = Send(SYS,@FindSpellByNum,#num=iNum);
               lTargets = Send(oSpell,@GetTargets,#who=self,#lTargets=[oTarget]);
               if NOT Send(oSpell,@CanPayMonsterCosts,#who=self,#lTargets=lTargets,
                           #iSpellPower=iSpellPower)
                  OR NOT Send(poOwner,@ReqSpellCast,#who=self,#oSpell=oSpell,
                              #lItems=lTargets)
               {
                  lActions = DelListElem(lActions,i);
               }
            }
         }
      }

      // If no actions made it through our check, quit here.
      if lActions = $
      {
         return FALSE;
      }

      // We are allowed to act and got a pool of actions.
      // Compare priorities to decide for one.
      iPriority = MIN_KOD_INT;
      foreach i in lActions
      {
         if Nth(i,5) >= iPriority
         {
            lAction = i;
            iPriority = Nth(i,5);
         }
      }

      // We have our action at this point, let's check its ID.
      iNum = First(lAction);

      // Let's also set our target depending on the action.
      switch(Nth(lAction,8))
      {
         case COMBAT_ACTION_HEAL:
            oTarget = oInjured;
            break;
         case COMBAT_ACTION_BUFF:
            oTarget = poLeader;
            break;
         case COMBAT_ACTION_NEUTRAL:
            oTarget = self;
            break;
         default:
            oTarget = poTarget;
            break;
      }

      // It's clear we will be acting now. Get our action delay.
      iDelay = Send(self,@GetAttackTime);

      // Standard melee attack. Let's initiate the attack.
      if (iNum = SKID_SLASH) OR (iNum = SKID_PUNCH)
      {
         iAttacks = 100 + viBonusSwing;
         i = 0;

         while (iAttacks > 0)
            AND oTarget <> $
            AND Send(oTarget,@GetOwner) <> $
         {
            if (Random(1,100) <= iAttacks)
               AND Send(self,@TryAttack,#what=oTarget,#stroke_obj=self,
                        #factor=Nth(lAction,7))
            {
               ++i;
            }

            iAttacks -= 100;
         }

         if i = 0
         {
            return FALSE;
         }
         else if poOwner <> $
         {
            // Not facing the target when slapping them is rude. Let's be polite.
            Send(self,@MonsterOrient,#new_row=Send(oTarget,@GetRow),
                  #new_col=Send(oTarget,@GetCol),
                  #new_finerow=Send(oTarget,@GetFineRow),
                  #new_finecol=Send(oTarget,@GetFineCol),#face_target=TRUE);
            // We actually attack. Do the animation if we're still around.
            Send(self,@DoMeleeAttack,#swings=i);
         }
      }
      // If we are a ranged attack, shoot something.
      else if (iNum = SKID_FIRE)
      {
         iAttacks = 100 + viBonusShot;
         i = 0;

         while (iAttacks > 0)
            AND oTarget <> $
            AND Send(oTarget,@GetOwner) <> $
         {
            if (Random(1,100) <= iAttacks)
               AND Send(self,@TryAttack,#what=oTarget,#stroke_obj=self,
                        #factor=Nth(lAction,7))
            {
               ++i;
            }

            iAttacks -= 100;
         }

         if i = 0
         {
            return FALSE;
         }
         else if poOwner <> $
         {
            // Same goes for shooting them in the face...
            Send(self,@MonsterOrient,#new_row=Send(oTarget,@GetRow),
                  #new_col=Send(oTarget,@GetCol),
                  #new_finerow=Send(oTarget,@GetFineRow),
                  #new_finecol=Send(oTarget,@GetFineCol),#face_target=TRUE);
            // We actually attack. Do the animation if we're still around.
            Send(self,@DoMissileAttack,#shots=i);
         }
      }
      // We're doing a spinning area effect attack! Fancy!
      else if (iNum = SKID_SPIN)
      {
         iAttacks = 100 + viBonusSpin;
         i = 0;
         lTargets = Send(self,@GetTargetsInRange);

         while (iAttacks > 0)
         {
            if (Random(1,100) <= iAttacks)
            {
               Send(poOwner,@SomeoneSaid,#what=self,#string=Lm_monster_spin,
                     #type=SAY_MESSAGE,#parm1=Send(self,@GetCapDef),
                     #parm2=Send(self,@GetName));

               foreach oSpin in lTargets
               {
                  if oSpin <> $ AND Send(oSpin,@GetOwner) <> $
                  {
                     Send(self,@TryAttack,#what=oSpin,#stroke_obj=self,
                           #factor=Nth(lAction,7));
                  }
               }

               ++i;
            }

            iAttacks -= 100;
         }

         if poOwner <> $
         {
            // Gotta get in position for a good spinning first.
            Send(self,@MonsterOrient,#new_row=Send(oTarget,@GetRow),
                  #new_col=Send(oTarget,@GetCol),
                  #new_finerow=Send(oTarget,@GetFineRow),
                  #new_finecol=Send(oTarget,@GetFineCol),#face_target=TRUE);
            // We spun around i times. Let's animate it.
            Send(self,@DoSpinAttack,#spins=i);
         }
      }
      // Looks like we are casting something. How exciting!
      // Time to set our local variables.
      else if iNum < SKID_MINIMUM
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=iNum);
         lTargets = Send(oSpell,@GetTargets,#who=self,#lTargets=[oTarget]);
         iSpellPower = Bound(Send(self,@GetSpellPower,#oSpell=oSpell) + Nth(lAction,7),
                        SPELLPOWER_MINIMUM,SPELLPOWER_MAXIMUM);

         // Do any special cast animations; send spell for specific ones.
         // Also, make sure we're still around.
         if poOwner <> $
         {
            // And let's not forget splashing acid on them. Also gotta face 'em.
            Send(self,@MonsterOrient,#new_row=Send(oTarget,@GetRow),
                  #new_col=Send(oTarget,@GetCol),
                  #new_finerow=Send(oTarget,@GetFineRow),
                  #new_finecol=Send(oTarget,@GetFineCol),#face_target=TRUE);
            Send(self,@MonsterCastAnimation,#iSpellNum=iNum);
         }

         // We are almost ready to cast the spell, only a spell resist can
         // get into our way now.
         if NOT ((Length(lTargets) = 1)
            AND (Nth(lAction,8) = COMBAT_ACTION_HARM)
            AND Send(oTarget,@SpellResist,#oSpell=oSpell,#who=self,#iSpellpower=iSpellPower))
         {
            // Monsters don't necessarily cast at the same power level as
            // players. Calculate power percentage here.
            if viPowerLevel <> $
            {
               iPowerLevel = viPowerLevel;
            }
            else
            {
               iPowerLevel = Bound(piMysticism + piIntellect + viLevel,$,300) / 3;
            }

            // Cast the spell.
            Send(oSpell,@CastSpell,#who=self,#lTargets=lTargets,
                  #iSpellPower=iSpellPower,#iPowerLevel=iPowerLevel);
         }

         iDelay = iDelay * Bound(150 - piIntellect,50,$) / 100;
      }
      // If none of the above was true, we simply moved.
      else
      {
         iDelay = FALSE;
      }

      // We did something. Pay the cost.
      iMana = Nth(lAction,2);
      iVigor = Nth(lAction,3);
      Send(self,@LoseMana,#amount=iMana,#precision=TRUE);
      Send(self,@LoseVigor,#amount=iVigor,#precision=TRUE);

      // If we made it this far, we acted in some way. Adjust our priorities.
      iFactor = Nth(lAction,6);

      foreach i in plActions
      {
         iAction = First(i);

         // Spells lose priorty when cast and gain priority
         // when another action is taken. Amount of priority
         // lost is unique to each spell, amount of priority
         // gained depends on mysticism.
         if iAction < SKID_MINIMUM
         {
            if iAction = iNum
            {
               SetNth(i,5,Bound(iPriority - iFactor,-10000,$));
            }
            else
            {
               SetNth(i,5,Bound(Nth(i,5)+(piMysticism/2),$,1000));
            }
         }

         // Attack routines gain priority with every unit of distance
         // travelled. Gain depends on aim (1 to 5 points).
         if iAction > SKID_MINIMUM
         {
            if iNum = SKID_MINIMUM
            {
               SetNth(i,5,Bound(Nth(i,5)+(piAim/10),$,1000));
            }
            else
            {
               if iAction = SKID_SLASH
               {
                  SetNth(i,5,viMeleePriority);
               }
               if iAction = SKID_SPIN
               {
                  SetNth(i,5,viMeleePriority+1);
               }
               if iAction = SKID_FIRE
               {
                  SetNth(i,5,viFirePriority);
               }
            }
         }
      }

      // Adjust our position. Only if we can move and we aren't blind though.
      if NOT ((piBehavior & AI_MOVE_RANDOM) OR (piBehavior & AI_NOMOVE))
      {
         Send(self,@SideStepCheck,#distance=distance);
      }

      return iDelay;
   }

   AdjustActionPriority(num=$,amount=$)
   {
      local i;

      foreach i in plActions
      {
         if First(i) = num
         {
            SetNth(i,5,Nth(i,5) + amount);
         }
      }

      return;
   }

   MonsterHasAbility(iNum=0)
   {
      local i;

      foreach i in plActions
      {
         if (First(i) = iNum)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   DoMeleeAttack(swings=0)
   "Calls melee attack animation as often as needed."
   {
      if ptAction = $
      {
         piAction = swings;
         Send(self,@DoMeleeAnimation);
      }

      return;
   }

   DoMeleeAnimation()
   "Handles melee attack animation."
   {
      ptAction = $;

      if poOwner <> $
      {
         piAnimation = ANIM_ATTACK;
         Send(poOwner,@SomethingChanged,#what=self);
         piAnimation = ANIM_NONE;

         if --piAction > 0
         {
            ptAction = CreateTimer(self,@DoMeleeAnimation,400);
         }
      }

      return;
   }

   DoSpinAttack(spins=0)
   "Initiates spin attack animation as often as needed."
   {
      if ptAction = $
      {
         piAction = spins * 8;
         Send(self,@DoSpinAnimation);
      }

      return;
   }

   DoSpinAnimation()
   "Handles spin attack animation."
   {
      local iDiff, iAngle;

      ptAction = $;

      if poOwner <> $
      {
         iAngle = Send(self,@GetAngle);
         if piAction % 8 < 4
         {
            iAngle += (MAX_ANGLE / 4);
         }
         else
         {
            iAngle -= (MAX_ANGLE / 4);
         }

         if piAction % 4 = 0
         {
            piAnimation = ANIM_ATTACK;
            Send(poOwner,@SomethingChanged,#what=self);
            piAnimation = ANIM_NONE;
         }

         Send(poOwner,@SomethingTurned,#what=self,#new_angle=iAngle);

         if --piAction > 0
         {
            ptAction = CreateTimer(self,@DoSpinAnimation,viSpinAnimationTime);
         }
      }

      return;
   }

   DoMissileAttack(shots=0)
   "Calls ranged attack animation as often as needed."
   {
      if ptAction = $
      {
         piAction = shots;
         Send(self,@DoMissileAnimation);
      }

      return;
   }

   DoMissileAnimation()
   "Handles ranged attack animation. Default is same as melee."
   {
      ptAction = $;

      if poOwner <> $
      {
         piAnimation = ANIM_ATTACK;
         Send(poOwner,@SomethingChanged,#what=self);
         piAnimation = ANIM_NONE;
         Send(poOwner,@SomethingShot,#who=self,#target=poTarget,#projectile=self);

         if --piAction > 0
         {
            ptAction = CreateTimer(self,@DoMissileAnimation,400);
         }
      }

      return;
   }

   MonsterCastAnimation(iSpellNum=$)
   "If a monster has a special cast animation, call this."
   {
      piAnimation = ANIM_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = ANIM_NONE;

      return;
   }

   GetMeleeAnimation()
   {
      return ANIM_ATTACK;
   }

   GetFireAnimation()
   {
      return ANIM_ATTACK;
   }

   GetCastAnimation()
   {
      return ANIM_ATTACK;
   }

   HitPointThresholdDamage()
   {
      local i, iThreshold, rDamage_report, each_obj;

      iThreshold = piHealth / (piMax_health * 20);

      if iThreshold >= 4
      {
         return;
      }
      else if iThreshold = 3
      {
         rDamage_report = vrFirst_damage_level;
      }
      else if iThreshold = 2
      {
         rDamage_report = vrSecond_damage_level;
      }
      else if iThreshold = 1
      {
         rDamage_report = vrThird_damage_level;
      }
      else
      {
         rDamage_report = vrFourth_damage_level;
      }

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&User)
            AND Send(each_obj,@GetKillTarget) = self
         {
            Post(each_obj,@MsgSendUser,#what=self,#message_rsc=rDamage_report,
                  #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         }
      }

      // Let our leader know we are in need of some help.
      if (poLeader <> $)
         AND (Send(poLeader,@GetOwner) = poOwner)
      {
         Send(self,@MercenaryInjured,#iThreshold=iThreshold);
      }

      return;
   }

   HitPointThresholdHeal()
   {
      local i, iThreshold, rHeal_report, each_obj;

      iThreshold = piHealth / (piMax_health * 20);

      if iThreshold >= 5
      {
         return;
      }
      else if iThreshold = 4
      {
         rHeal_report = vrFirst_heal_level;
      }
      else if iThreshold = 3
      {
         rHeal_report = vrSecond_heal_level;
      }
      else if iThreshold = 2
      {
         rHeal_report = vrThird_heal_level;
      }
      else
      {
         rHeal_report = vrFourth_heal_level;
      }

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&User)
            AND Send(each_obj,@GetKillTarget) = self
         {
            Post(each_obj,@MsgSendUser,#what=self,#message_rsc=rHeal_report,
                  #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));
         }
      }

      // Let our leader know that we're doing better again.
      if (poLeader <> $)
         AND (Send(poLeader,@GetOwner) = poOwner)
      {
         Send(self,@MercenaryRecovered,#iThreshold=iThreshold);
      }

      return;
   }

   CheckWhyWanted(obj=$, who=$)
   {
      local value,oMoney;

      if IsClass(obj,&SignetRing)
      {
         // Does the signet want this mob? (or vice versa).
         if Send(obj,@GetRingOwner) = self
         {
            Send(Send(SYS,@GetLibrary),@UnregisterSignet,#newring=obj);
            Send(Send(SYS,@GetLibrary),@SignetDelivered,#who=who);
            Post(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
                 #string=LS_Signet_returned);
            Send(obj,@NewOwner,#what=self);

            // Have the ring handle the reward.
            Send(obj,@RewardReturner,#who=who);

            return TRUE;
         }
         else
         {
            Post(poOwner,@SomeoneSaid,#what=self,
                 #string=LS_Signet_wrong,#type=SAY_RESOURCE,
                 #parm1=Send(Send(obj,@GetRingOwner),@GetDef),
                 #parm2=Send(Send(obj,@GetRingOwner),@GetName));

            return FALSE;
         }
      }

      Post(poOwner,@SomeoneSaid,#what=self,#string=LS_wanted_keep,
           #type=SAY_RESOURCE);

      return TRUE;
   }

   ShowDesc(iHitPoint_Percent = $)
   "Adds max HP that can be gained from monster, followed by its condition."
   {
      local iHit_Percent, rMonster_condition;

      if iHitPoint_Percent = $
      {
         iHit_Percent = piHealth / piMax_health;
      }
      else
      {
         iHit_Percent = iHitPoint_Percent;
      }

      if iHit_Percent > 80
      {
         if (piBehavior & AI_NPC) OR IsClass(self,&Follower)
         {
            AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,monster_nothing);
         }
         else
         {
            AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,monster_desc_level,
                      4,Bound(viLevel,20,150));
         }

         return;
      }
      else if iHit_Percent > 60
      {
         rMonster_condition = vrCondition_good;
      }
      else if iHit_Percent > 40
      {
         rMonster_condition = vrCondition_fair;
      }
      else if iHit_Percent > 20
      {
         rMonster_condition = vrCondition_poor;
      }
      else
      {
         rMonster_condition = vrCondition_bad;
      }

      if (piBehavior & AI_NPC) OR IsClass(self,&Follower)
      {
         AddPacket(4,rMonster_Condition, 4,vrDesc, 4,monster_nothing,
                   4,Send(self,@GetCapDef), 4,Send(self,@GetName));
      }
      else
      {
         AddPacket(4,rMonster_Condition, 4,vrDesc, 4,monster_desc_level,
                   4,Bound(viLevel,20,150), 4,Send(self,@GetCapDef),
                   4,Send(self,@GetName));
      }

      return;
   }

   GainMaxHealth(amount = 0)
   "Equivalent to the message in Player, but without starting a timer."
   {
      local iPrev_max;

      iPrev_max = piMax_health;
      piMax_health = Bound(piMax_health + amount, 1, $);

      return piMax_health - iPrev_max;
   }

   SetMaxHitPoints(amount=$)
   {
      piMax_health = amount;
      piHealth = amount*100;

      return;
   }

   IsFullTalk()
   {
      // We AND with TRUE to have it return a boolean.
      return (viAttributes & MOB_FULL_TALK) AND TRUE;
   }

   GetLevel()
   {
      return viLevel;
   }

   GetDifficulty()
   {
      return viDifficulty;
   }

   ClearBehavior(timer = $)
   {
      if ptBehavior <> timer AND ptBehavior <> $
      {
         DeleteTimer(ptBehavior);
      }

      ptBehavior = $;

      return;
   }

   IsObjectWeapon(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_WEAPON);
   }

   IsObjectSundry(what=$)
   {
      // perhaps here so certain merchants will buy them?
      if IsClass(what,&Torch)
      {
         return TRUE;
      }

      return Send(what,@IsItemType,#type=ITEMTYPE_SUNDRY);
   }

   IsObjectPotion(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_POTION);
   }

   IsObjectMisc(what=$)
   {
      // not sure why these were in misc but keeping them here for now
      if IsClass(what,&SpellItem)
         OR IsClass(what,&Arsenic)
      {
         return TRUE;
      }

      return Send(what,@IsItemType,#type=ITEMTYPE_MISC);
   }

   IsObjectWearable(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_RING) |
               Send(what,@IsItemType,#type=ITEMTYPE_NECKLACE) |
               Send(what,@IsItemType,#type=ITEMTYPE_ARMOR);
   }

   IsObjectGem(what=$)
   {
      if IsClass(what,&JewelofFroz)
      {
         return TRUE;
      }

      return Send(what,@IsItemType,#type=ITEMTYPE_GEM);
   }

   IsObjectReagent(what=$)
   {
      return Send(what,@IsItemType,#type=ITEMTYPE_REAGENT);
   }

   KarmaSame(who=$)
   "Return TRUE if the mob and the who have karmas of the same polarity."
   {
      local iPlayer_karma;

      // This means the monster has no Karma.
      if viKarma = $
      {
         return TRUE;
      }

      iPlayer_karma = Send(who,@GetKarma);

      // Second clause is to give newbies a break
      if (viKarma * Send(who,@GetKarma)) < 0
         AND Abs(iPlayer_karma) >= 10
      {
         return FALSE;
      }

      return TRUE;
   }

   StartBasicTimers()
   {
      if (viAttributes & MOB_RANDOM)
      {
         ptRandom = CreateTimer(self,@RandomTimer,
                                viRandom_delay+Random(0,viRandom_delay/2));
      }

      if (viAttributes & MOB_SPASM)
      {
         ptSpasm = CreateTimer(self,@SpasmMonsterTimer,
                               viSpasm_delay+Random(0,viSpasm_delay/3));
      }

      return;
   }

   Fuzzy(num = 0, scale = 4)
   "Returns a number which is +/- num/scale of the original num."
   "Without the scale factor given, default is 0.75 to 1.25 of orig num."
   {
      if scale < 1
      {
         scale = 1;
      }

      if num < 0
      {
         num = num * -1;
         return (num - num/scale + Random(0,num*2/scale)) * -1; 
      }

      return num - num/scale + Random(0,num*2/scale);
   }

   ClearBasicTimers()
   {
      if ptRandom <> $
      {
         DeleteTimer(ptRandom);
         ptRandom = $;
      }

      if ptSpasm <> $
      {
         DeleteTimer(ptSpasm);
         ptSpasm = $;
      }

      if ptCancelOffer <> $
      {
         DeleteTimer(ptCancelOffer);
         ptCancelOffer = $;
      }

      poCustomer = $;

      // Clear spam list when last user leaves.
      plSpamList = $;

      return;
   }

   SetState(bit=0)
   "For now, the personality (or state) bits are used as numerical"
   "tokens rather than as independent flags."
   {
      // ESTATE gets erased when we change states
      if NOT (piState & bit)
      {
         piState &= ESTATE_ZERO_MASK;
      }

      piState &= STATE_ZERO_MASK;
      piState |= bit;

      return;
   }

   GetState()
   {
      return piState;
   }

   GetSpeed()
   {
      // Set our current speed based on classvar and agility.
      piSpeed = Bound(viSpeed + (piAgility/10) - 2,0,USER_RUNNING_SPEED);

      // Movement speed mods (e.g. slow spell)
      piSpeed = piSpeed * Send(self,@GetMovementSpeedPercent) / 100;

      // Strolling, not in a rush, unless we are under orders.
      if (piState & STATE_MOVE) 
         AND ((poMaster = $) OR IsClass(poMaster,&Monster))
         AND (poLeader = $)
      {
         piSpeed = Bound(piSpeed * viStrollSpeed / 100,$,piSpeed);
      }

      if poLeader <> $
      {
         piSpeed *= 2;
      }

      // If our monster is able to move in general, then other
      // effects can't immobilize it.
      if viSpeed
      {
         piSpeed = Bound(piSpeed,1,$);
      }

      return piSpeed;
   }

   GetAttackTime()
   {
      return Send(self,@Fuzzy,#num=MOB_ATTACK_TIMER_WAIT)
             + 3500-70*(3*viDifficulty+viSpeed);
   }

   GetMoveTime()
   {
      local iTime;

      // GetSpeed sets piSpeed accordingly.
      Send(self,@GetSpeed);

      // Unit of viSpeed is: #gridsquares per 10 seconds (per 10000 ms)
      // viSpeed is pre-defined by monster
      // Move-increment is predefined/fixed at 16fine unit per step
      // --> The elapse-interval is fixed!
  
      // EXAMPLE: SPEED_VERY_SLOW: 4 squares per 10000 ms
      // 1024 super-fine squares = 1 square
      // 256 super-fine squares = 1 highres square = 16 finesquare = stepwidth
      // -------------------------------------------------------
      // 4 * 1024    = 4096 super-fine squares per 10000 ms
      // 4096 / 256  = 16 (Monster has to make 16 steps per 10000ms)
      // 10000 / 16  = 625 (steps must be made in 625ms intervals)
      // T = 10000 / ((viSpeed * 1024) / 256)

      // avoid division by zero, if objects teleport
      // objects with viSpeed = 0 don't need seamless movements in the client
      // so we just assume it is enough to teleport them once a second
      if piSpeed > 0
      {
         // see formula above  
         iTime = 10000 / (piSpeed * 4);

         // diagonal gridmove (astar):
         // scale-up the time according to the increased distance
         if piState & ESTATE_LONG_STEP
         {
            // sqrt(2) = 1.41421356
            iTime = (14142 * iTime) / 10000;
         }

         // make sure timer interval does not get negative
         // and also not like "run all the time"
         iTime = Bound(iTime, 16, 10000);
      }
      else
      {
         iTime = 1000;
      }

      return iTime;
   }

   CutWantedItem(class = $)
   {
      local i;

      if class = $
      {
         return;
      }

      foreach i in plWantedItems
      {
         if i = class
         {
            // You only want to delete one of the items that the NPC wants so
            //  as not to ruin any quests for duplicate items
            //  (esp signet rings).
            plWantedItems = DelListElem(plWantedItems,i);

            return;
         }
      }

      return;
   }

   SetWantedItem(class = $)
   {
      if class = $
      {
       return;
      }

      plWantedItems = Cons(class,plWantedItems);

      return;
   }

   DeleteForSaleList()
   {
      local i;

      if plFor_sale = $
      {
         return;
      }

      foreach i in Nth(plFor_sale,2)
      {
         i = $;
      }

      foreach i in Nth(plFor_sale,3)
      {
         i = $;
      }

      foreach i in First(plFor_sale)
      {
         Send(i,@Delete);
      }

      if Length(plFor_sale) = 4
      {
         foreach i in Nth(plFor_sale,4)
         {
            Send(i,@Delete);
         }
      }

      plFor_sale = $;

      return;
   }

   CanAddSkill(who = $, num = 0)
   {
      return Send(who,@PlayerCanLearn,#skill_num=num,#spell_num=0)
                  = PLAYER_LEARN_SUCCESS;
   }

   CanAddSpell(who = $, num = 0)
   {
      return Send(who,@PlayerCanLearn,#skill_num=0,#spell_num=num)
                  = PLAYER_LEARN_SUCCESS;
   }

   HasDoneLearnQuest(who=$)
   {
      local iQuestHistory;

      if who = $
      {
         Debug("Who shouldn't be $!");

         return FALSE;
      }

      if viQuestID = 0
      {
         return TRUE;
      }

      iQuestHistory = First(Send(who,@GetQuestHistory,#index=viQuestID));
      return (QUEST_HISTORY_SUCCESS & iQuestHistory);
   }

   CanDoTeach(who = $, sid = 0, bSkill = FALSE)
   {
      local oAbility, iVal, iReason, iAmount, rAmount;

      if sid = 0 OR who = $
      { 
         Debug("Invalid data sent to CanDoTeach!");

         return FALSE; 
      }

      if bSkill
      {
         oAbility = Send(SYS,@FindSkillByNum,#num=sid);
      }
      else
      {
         oAbility = Send(SYS,@FindSpellByNum,#num=sid);
      }

      if oAbility = $
      {
         Debug("Got invalid sid info!",sid);

         return FALSE;
      }

      // Sacred Haven check.
      if NOT Send(oAbility,@IsAccessible)
      {
         return FALSE;
      }

      if IsClass(self,&Temples)
      {
         if (NOT bSkill)
            AND Send(oAbility,@GetLevel) > 2
            AND NOT Send(self,@HasDoneLearnQuest,#who=who)
         {
            // Player needs to do a quest for the priestess to gain this spell or
            //  skill.
            Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
                  #string=vrTeach_quest_needed,#parm1=Send(oAbility,@GetName));

            return FALSE;
         }
      }
      else if NOT Send(self,@HasDoneLearnQuest,#who=who)
      {
         // Player needs to do a quest for the seller to gain this spell or
         //  skill.
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=vrTeach_quest_needed,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if bSkill
      {
         iVal = Send(who,@PlayerCanLearn,#skill_num=SID);
      }
      else
      {
         iVal = Send(who,@PlayerCanLearn,#spell_num=SID);
      }

      if iVal = PLAYER_LEARN_ERROR
      {
         return FALSE;
      }

      if iVal = PLAYER_LEARN_SUCCESS
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_success,#parm1=Send(oAbility,@GetName));

         return TRUE;
      }

      if iVal = PLAYER_LEARN_ALREADY
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_already,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if iVal = PLAYER_LEARN_NOBASE
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_nobase,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if iVal = PLAYER_LEARN_KARMA 
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_karma,#parm1=Send(oAbility,@GetName));

         return FALSE;
      }

      if iVal = PLAYER_LEARN_IMPOSSIBLE 
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_impossible);

         return FALSE;
      }

      // Of we're below here, then the 1's column stores the reason, and the
      //  10s and 100s stores by how much.
      iReason = iVal % 10;
      iAmount = iVal / 10;
      rAmount = Send(self,@LearnHowMuchFurther,#iAmount=iAmount);

      if iReason = PLAYER_LEARN_BASE
      {
         Send(poOwner,@SomeoneSaid,#type=SAY_RESOURCE,#what=self,
              #string=monster_teach_base,#parm1=rAmount,
              #parm2=Send(oAbility,@GetSchoolStr),
              #parm3=Send(oAbility,@GetName));

         return FALSE;
      }

      Debug("Oops, fell through in our testing for learning.");

      return FALSE;
   }

   LearnHowMuchFurther(iAmount=0,rval=0)
   {
      local temp_rsc;

      if iAmount < MONSTER_LEARN_GRADIENT
      {
         temp_rsc = monster_little;
      }
      else if iAmount < 2 * MONSTER_LEARN_GRADIENT
      {
         temp_rsc = monster_nothing;
      }
      else if iAmount < 3 * MONSTER_LEARN_GRADIENT
      {
         temp_rsc = monster_some;
      }
      else if iAmount < 4 * MONSTER_LEARN_GRADIENT
      {
         temp_rsc = monster_much;
      }
      else if iAmount < 5 * MONSTER_LEARN_GRADIENT
      {
         temp_rsc = monster_significantly;
      }
      else
      {
         temp_rsc = monster_drastically;
      }

      return temp_rsc;
   }

   // Generally false, except for e.g. faction solder/faction mage.
   IsMonsterQuestEquivalent()
   {
      return FALSE;
   }

   HasAttribute(mask = $)
   {
      return (viAttributes & mask);
   }

   // We AND to TRUE for the MobIs... functions to return a boolean instead
   //  of a value.
   MobIsBanker()
   {
      // We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_BANKER) AND TRUE);
   }

   MobIsVaultman()
   {
      // We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_VAULTMAN) AND TRUE);
   }

   MobIsBuyer()
   {
      // We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_BUYER) AND TRUE);
   }

   MobIsCondSeller()
   {
      // We AND with TRUE to have it return a boolean.
      return ((viAttributes & MOB_COND_SELLER) AND TRUE);
   }

   MobIsSeller()
   {
      return (viAttributes & MOB_SELLER)
             OR (viAttributes & MOB_COND_SELLER)
             OR (viAttributes & MOB_TEACHER);
   }

   GetAttributes()
   {
      return viAttributes;
   }

   ObjectDesired(what=$)
   "This is set in individual buyers.  It allows them to pick and choose"
   "what they want to buy."
   {
      return TRUE;
   }

   InitCondSale()
   {
      return;
   }

   AddToConditionalList(obj=$,value=0)
   {
      local i;

      if plFor_sale = $ OR Length(plFor_sale) < 4
      {
         return;
      }

      foreach i in Nth(plFor_sale,4)
      {
         if First(i) = obj
         {
            return;
         }
      } 

      SetNth(plFor_sale,4,Cons([obj,value],Nth(plFor_sale,4)));

      return;
   }

   GetObjectOnConditionalList(class=$)
   {
      local i;

      if plFor_sale = $ OR Length(plFor_sale) < 4
      {
         return;
      }

      foreach i in Nth(plFor_sale,4)
      {
         if GetClass(First(i)) = class
         {
            return First(i);
         }
      } 

      return $;
   }

   RemoveFromConditionalList(obj=$)
   {
      local i;

      if obj = $ OR plFor_sale = $ OR Length(plFor_sale) < 4
      {
         return;
      }

      foreach i in Nth(plFor_sale,4)
      {
         if First(i) = obj
         {
            SetNth(plFor_sale,4,DelListElem(Nth(plFor_sale,4),i)); 

            return;
         }
      }

      return;
   }

   SetForSale()
   "Clears and recreates plFor_sale."
   {
      plFor_sale = $;

      return;
   }

   SetForSaleFrenzy(override=FALSE)
   "Used to give Innkeepers a frenzy sale list."
   {
      if Send(SYS,@GetChaosNight)
         OR override
      {
         plFor_sale = [
            [
               Create(&ShockRing),
               Create(&FireRing),
               Create(&ColdRing),
               Create(&AcidRing),
               Create(&BerserkerRing),
               Create(&RingInvisibility),
               Create(&LeatherArmor),
               Create(&ChainArmor),
               Create(&ScaleArmor),
               Create(&NeruditeArmor),
               Create(&PlateArmor),
               Create(&DiscipleRobe),
               Create(&GuildShield),
               Create(&NeruditeSword),
               Create(&Mace),
               Create(&Hammer),
               Create(&Axe),
               Create(&MysticSword),
               Create(&Scimitar),
               Create(&Longsword),
               Create(&Longbow),
               Create(&BattleBow),
               Create(&Gauntlet),
               Create(&JewelOfFroz),
               Create(&Arrow,#number=150),
               Create(&SilverArrow,#number=150),
               Create(&NeruditeArrow,#number=150),
               Create(&IceArrow,#number=150),
               Create(&FireArrow,#number=150),
               Create(&AcidArrow,#number=150),
               Create(&Helm),
               Create(&DaemonHelm),
               Create(&Mint,#number=100),
               Create(&NeruditeBow),
               Create(&Gift),
               Create(&Chaosfood,#number=100),
               Create(&KarmaPotion,#karma=-10000),
               Create(&KarmaPotion,#karma=10000)
            ],
            $,
            $,
         $];
      }

      return;
   }

   AssembleVaultList(who=$)
   {
      local oVault, i, j;

      oVault = Send(SYS,@FindVaultByNum,#num=Send(self,@GetVaultNum));

      if oVault = $
      {
         Debug("Something wrong here!");

         return $;
      }

      return Send(oVault,@GetItemsStored,#who=who);
   }

   GetCostPer100Bulk()
   {
      return 200;
   }

   GetForSale(who = $)
   "Returns the list of objects the mob has for sale "
   "(items, skills, spells, conditionals)"
   {
      local i,lForSale;

      if Send(self,@MobIsVaultman)
      {
         return Send(self,@AssembleVaultList,#who=who);
      }

      if plFor_sale = $
      {
         return;
      }

      // first do conditional items
      if Length(plFor_sale) = 4
      {
         foreach i in Nth(plFor_sale,4)
         {
            lForSale = Cons(First(i),lForSale);
         }
      }

      // now do spells
      foreach i in Nth(plFor_sale,3)
      {
         if Send(self,@CanAddSpell,#who=who,#num=i)
            AND (Send(who,@GetSpellAbility,#spell_num=i) = 0)
         {
            lForSale = Cons(Send(SYS,@FindSpellByNum,#num=i),lForSale);
         }
      }

      // now do skills
      foreach i in Nth(plFor_sale,2)
      {
         if Send(self,@CanAddSkill,#who=who,#num=i)
            AND (Send(who,@GetSkillAbility,#skill_num=i) = 0)
         {
            lForSale = Cons(Send(SYS,@FindSkillByNum,#num=i),lForSale);
         }
      }

      // now do the items
      foreach i in First(plFor_sale)
      {
         lForSale = Cons(i,lForSale);
      }

      if lForSale = $
      {
         Send(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
               #string=vrNothing_for_sale);
      }

      return lForSale;
   }

   GetPrice(what = $, who = $)
   "Returns the value of an item, or the cost of a skill or spell"
   "No markup for skills or spells"
   {
      local i, x, y;

      if plFor_sale <> $ AND Length(plFor_sale) = 4
      {
         foreach i in Nth(plFor_sale,4)
         {
            if what = First(i)
            {
               return Nth(i,2);
            }
         }
      }

      if IsClass(what,&Item)
      {
         x = Send(what,@GetInitValue) * (100 + 20*viMerchant_markup) / 100;
         y = Send(Send(SYS,@GetParliament),@GetFactionPriceBonus,#who=who,
                  #buying=TRUE);
         return Bound(x*y/100, 1, $);
      }

      if IsClass(what,&Spell) OR IsClass(what,&Skill)
      {
         return Send(what,@GetValue);
      }

      Debug("Strange item",what,":",Send(what,@GetName),"in GetPrice");

      return 0;
   }

   GetGender()
   {
      return viGender;
   }

   GetKarma(detect=FALSE)
   {
      if pbDontDispose
         AND NOT detect
      {
         // This means that the monster has no Karma.  This is used for event
         //  monsters like Xeos and admin-created beasties.
         return 0;
      }

      // A survival mob
      if poOwner <> $
         AND IsClass(poOwner,&SurvivalRoom)
      {
         return 0;
      }

      return viKarma;
   }

   GetTreasureType()
   {
      return viTreasure_type;
   }

   CreateTreasure(who=$,corpse=$)
   {
      local i, j, oReagent, iNumberItems, oTreasure, oTreasure_type,
            lTreasureItems, iNumberOfItemsDropped, iNumberOfItemsLooted,
            iRandomCashAmount, oMoney, iGetResult, bCapacityFailure,
            bRangeFailure, iSurvivalLoot, bPlayer, oHurter;

      bPlayer = FALSE;

      // Apparitions, etc, provide no treasure
      if pbIllusion
      {
         return;
      }

      // If no player was involved, no loot is dropped.
      foreach i in plHurtMeRecently
      {
         oHurter = First(i);

         if (IsClass(oHurter,&Player)
            OR Send(oHurter,@IsOwnedByPlayer))
         {
            bPlayer = TRUE;

            break;
         }
      }

      if NOT bPlayer
      {
         return;
      }

      oTreasure_type = Send(SYS,@FindTreasureByNum,
                              #num=Send(self,@GetTreasureType));
      if oTreasure_type = $
      {
         Debug("Can't find monster treasure type",Send(self,@GetTreasureType),
               vrname,self);

         return;
      }

      // TreasureType now handles putting together the treasure list.
      // Returns a list of items to drop, or $.
      lTreasureItems = Send(oTreasure_Type,@CreateMobTreasure,#mob=self,
                              #who=who,#level=viLevel,#difficulty=viDifficulty,
                              #corpse=corpse,#attributes=viAttributes,
                              #boostedlevel=piBoostedLevel);

      // Add in our inventory
      foreach i in plActive
      {
         lTreasureItems = Cons(i,lTreasureItems);
      }

      foreach i in plPassive
      {
         lTreasureItems = Cons(i,lTreasureItems);
      }

      // Add money to the treasure
      iRandomCashAmount = Random(viCashMin,viCashMax);
      if iRandomCashAmount > 0
      {
         // Don't send a corpse unless the player killed the mob. Minion kills
         // already handed to the player in KilledSomething and double-checked
         // in Killed. Corpse is used for the loot timer, which GenerateTreasure
         // handles for monster kills but Constructor in Item does not.
         if NOT IsClass(who,&Player)
         {
            corpse = $;
         }

         oMoney = Create(&Money,#corpse=corpse,#number=iRandomCashAmount + (piBoostedLevel
                     * Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalCash)));

         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=Send(oMoney,@GetNumber));
         lTreasureItems = Cons(oMoney,lTreasureItems);
      }

      iNumberOfItemsDropped = 0;
      iNumberOfItemsLooted = 0;
      bCapacityFailure = FALSE;
      bRangeFailure = FALSE;
      
      // Now drop all the treasure.
      foreach oTreasure in lTreasureItems
      {
         if Send(poOwner,@ReqNewHold,#what=oTreasure,#new_row=piRow,
                 #new_col=piCol)
         {
            Send(poOwner,@NewHold,#what=oTreasure,
                  #new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col);

            if NOT IsClass(oTreasure,&Money)
            {
               ++iNumberOfItemsDropped;
            }

            if Send(oTreasure,@IsStackable)
               AND Send(SYS,@UtilGetRoom,#what=oTreasure) = Send(who,@GetOwner)
               AND Send(oTreasure,@GetPos) <> $
               AND IsClass(who,&User)
               AND Send(who,@CheckPlayerPreference,#flag=CF_AUTOLOOT)
               AND (IsClass(oTreasure,&Money)
                       OR (NOT bRangeFailure
                           AND NOT bCapacityFailure))
            {
               iGetResult = Send(who,@UserGet,#what=oTreasure,#report=FALSE);
               if NOT IsClass(oTreasure,&Money)
                  AND (iGetResult = AUTOLOOT_GOT_ITEM
                         OR iGetResult = AUTOLOOT_GOT_PARTIAL_STACK)
               {
                  ++iNumberOfItemsLooted;
               }

               if iGetResult = AUTOLOOT_OUT_OF_RANGE
               {
                  bRangeFailure = TRUE;
               }
               else if (iGetResult = AUTOLOOT_GOT_PARTIAL_STACK
                        OR iGetResult = AUTOLOOT_CANNOT_GET)
               {
                  bCapacityFailure = TRUE;
               }
            }
         }
         else
         {
            Send(oTreasure,@Delete);
         }
      }

      // Handle autoloot resources displayed to user.
      if iNumberOfItemsDropped <> 0
         AND IsClass(who,&User)
         AND Send(who,@CheckPlayerPreference,#flag=CF_AUTOLOOT)
      {
         if bRangeFailure
         {
            Send(who,@MsgSendUser,#message_rsc=autoloot_too_far_away);

            return;
         }

         if bCapacityFailure
         {
            if iNumberOfItemsLooted > 0
            {
               Send(who,@MsgSendUser,#message_rsc=autoloot_got_some_but_full_now);
            }
            else if iNumberOfItemsLooted = 0
            {
               if iRandomCashAmount > 0
               {
                  Send(who,@MsgSendUser,#message_rsc=autoloot_got_only_shillings_because_full,
                        #parm1=Send(oMoney,@GetNumber));
               }
               else
               {
                  Send(who,@MsgSendUser,#message_rsc=autoloot_got_nothing_because_full);
               }
            }

            return;
         }

         if iNumberOfItemsLooted > 0
         {
            if iNumberOfItemsLooted = iNumberOfItemsDropped
            {
               if iRandomCashAmount > 0
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_all,
                        #parm1=Send(oMoney,@GetNumber));
               }
               else
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_all_no_money);
               }
            }
            else if iNumberOfItemsLooted < iNumberOfItemsDropped
            {
               if iRandomCashAmount > 0
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_some,
                        #parm1=Send(oMoney,@GetNumber));
               }
               else
               {
                  Send(who,@MsgSendUser,#message_rsc=autolooted_some_no_money);
               }
            }
         }
         else if iNumberOfItemsLooted = 0
         {
            if iRandomCashAmount > 0
            {
               Send(who,@MsgSendUser,#message_rsc=autolooted_only_money,
                     #parm1=Send(oMoney,@GetNumber));
            }
            else if iRandomCashAmount <= 0
            {
               Send(who,@MsgSendUser,#message_rsc=autolooted_none);
            }
         }
      }

      return;
   }

   CanMonsterFight(who=$)
   {
      if (piBehavior & AI_NPC)
      {
         if who <> $
         {
            Send(who,@MsgSendUser,#message_rsc=LS_nofight_attacked);
         }

         return FALSE;
      }

      return TRUE;
   }

   IsCustomerOkay(who=$)
   {
      // Do business with everyone.

      return TRUE;
   }

   SomeoneTryUserCommand(who = $,command = $,data = $)
   {
      if NOT (viAttributes & MOB_BANKER) AND NOT (viAttributes & MOB_VAULTMAN)
      {
         return;
      }

      if NOT Send(self,@IsCustomerOkay,#who=who)
      {
         propagate;
      }

      if command = UC_DEPOSIT
      {
         if (viAttributes & MOB_VAULTMAN)
         {
            return TRUE;
         }

         Send(self,@BankDeposit,#who=who,#amount=data);

         return TRUE;
      }

      if command = UC_WITHDRAW
      {
         if (viAttributes & MOB_VAULTMAN)
         {
            return TRUE;
         }

         Send(self,@BankWithdraw,#who=who,#amount=data);

         return TRUE;
      }

      if command = UC_BALANCE
      {
         Send(self,@BankBalance,#who=who);

         return TRUE;
      }

      propagate;
   }

   DestroyDisposable()
   {
      if (viAttributes & MOB_LISTEN)
         OR (piBehavior & AI_NPC)
         OR poMaster <> $
         OR pbDontDispose
      {
         return;
      }

      Send(self,@Delete);

      return;
   }

   SetDontDispose(bValue=TRUE)
   {
      pbDontDispose = bValue;

      return pbDontDispose;
   }

   GetObjectFlags(what=$)
   {
      local iFlags;

      iFlags = viObject_flags | piDrawEffectFlag;

      if (piBehavior & AI_NPC)
      {
         iFlags &= ~OF_ATTACKABLE;

         if (what <> $
            AND IsClass(what,&User))
         {
            if (Send(what,@UserDisplayNPCQuestActive,#what=self))
            {
               iFlags |= OF_NPCACTIVEQUEST | OF_NPCQUESTABLE;
            }
            // NPC might have a quest for this user.
            else if (Send(self,@HasQuestsForUser,#who=what))
            {
               iFlags |= OF_NPCHASQUESTS | OF_NPCQUESTABLE;
            }
            else if (Send(self,@IsQuestableForUser,#who=what))
            {
               iFlags |= OF_NPCQUESTABLE;
            }
         }
      }
      else if (poMaster = $
         AND what <> $
         AND IsClass(what,&User)
         AND Send(what,@UserDisplayMobQuestActive,#what=self))
      {
         iFlags |= OF_MOBKILLQUEST;
      }

      if Send(self,@MobIsSeller)
      {
         iFlags |= OF_BUYABLE;
      }

      if ((viAttributes & MOB_BUYER
         OR viAttributes & MOB_RECEIVE)
         OR what <> $ AND IsClass(what,&DM))
      {
         iFlags |= OF_OFFERABLE;
      }

      return iFlags;
   }

   Say(message_rsc=$, parm1=$, parm2=$, parm3=$, parm4=$,
       parm5=$, parm6=$, parm7=$, parm8=$)
   {
      Send(poOwner,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
           #string=message_rsc,#parm1=parm1,#parm2=parm2,#parm3=parm3,
           #parm4=parm4,#parm5=parm5,#parm6=parm6,#parm7=parm7,#parm8=parm8);

      return;
   }

   SayToOne(target=$, message_rsc=$,
            parm1=$, parm2=$, parm3=$, parm4=$, parm5=$,
            type1=STANDARD_RESOURCE, type2=STANDARD_RESOURCE,
            type3=STANDARD_RESOURCE, type4=STANDARD_RESOURCE,
            type5=STANDARD_RESOURCE)
   {
      if target = $
      {
         Debug("SayToOne reached with null target.");
         return;
      }

      Send(target,@MsgSendUser,#message_rsc=monster_say_to_one,
           #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
           #parm3=message_rsc,#parm4=parm1,#type4=type1,
           #parm5=parm2,#type5=type2,#parm6=parm3,#type6=type3,
           #parm7=parm4,#type7=type4,#parm8=parm5,#type8=type5);

      return;
   }
   
   CanMorphTo()
   {
      return TRUE;
   }

   IsIllusion()
   {
      return pbIllusion;
   }

   // TRUE if mob can have evil twin cast on it
   CanEvilTwin()
   {
      return TRUE;
   }

   CanSeduce()
   {
      // Exclude mobs that can't move.
      if (viAttributes & MOB_NOMOVE)
      {
         return FALSE;
      }

      return vbCanSeduce;
   }

   ApparitionCaster(who=$)
   "If this monster is an apparition, keep track of the caster."
   {
      poApparitionCaster = who;

      return;
   }

   IsOwnedByPlayer()
   "Checks the two cases of minions, and returns TRUE if owned by "
   "a player, FALSE if not. If minion has a monster for a master, "
   "IsOwnedByPlayer is called on the master."
   {
      if poMaster <> $
      {
         if IsClass(poMaster,&Player)
         {
            return TRUE;
         }

         if IsClass(poMaster,&Monster)
         {
            return Send(poMaster,@IsOwnedByPlayer);
         }

         // Could be a room or an item that owns the monster.
         // If we allow players to attach minions to guild halls
         // or other creative uses of non-player/monster owners,
         // we may need to change this.
         return FALSE;
      }

      if poApparitionCaster <> $
      {
         if IsClass(poApparitionCaster,&User)
         {
            return TRUE;
         }

         if IsClass(poApparitionCaster,&Monster)
         {
            return Send(poApparitionCaster,@IsOwnedByPlayer);
         }

         return FALSE;
      }

      return FALSE;
   }

   IsMinion()
   "Returns TRUE for seduced and animated mobs, reflections, "
   "evil twins and apparitions."
   {
      if poMaster <> $
         OR poApparitionCaster <> $
      {
         return TRUE;
      }

      return FALSE;
   }

   // This section deals with minion code.
   CommandMinionAttack(oTarget=$)
   {
      local oActive;

      // If we have minions, we only want them to attack Battlers,
      // not items or anything else that can damage us.
      if plControlledMinions = $
         OR oTarget = $
         OR NOT IsClass(oTarget,&Battler)
         OR IsClass(oTarget,&Revenant)
      {
         return;
      }

      // Lets not have the minions kill each other. Check if the target is
      // a minion under our control.
      if IsClass(oTarget,&Monster)
         AND Send(oTarget,@GetMaster) = self
      {
         return;
      }

      foreach oActive in plControlledMinions
      {
         if IsClass(oActive,&Monster)
            AND Send(oActive,@GetMaster) = self
            AND Send(oActive,@GetTarget) <> oTarget
         {
            Send(oActive,@TargetSwitch,#what=oTarget,#iHatred=100);
            Send(oActive,@EnterStateEngage,#target=oTarget,#actnow=TRUE);
         }
      }

      return;
   }

   GetMaster()
   "Preferably return poMaster, otherwise check if monster is an apparition."
   {
      if (poMaster <> $)
      {
         return poMaster;
      }
      else if (poApparitionCaster <> $)
      {
         return poApparitionCaster;
      }

      return $;
   }

   // Evil twin and reflection have an override for this.
   SetMaster(oMaster=$)
   {
      if oMaster = $
      {
         if poMaster <> $
         {
            Send(poMaster,@RemoveControlledMinion,#what=self);
            poMaster = $;

            // Delete apparitions at this point.
            if (poApparitionOriginal <> $)
            {
               Post(self,@Delete);

               return;
            }
         }
      }
      else
      {
         poMaster = oMaster;
         // Add this creature to master's minion list
         Send(oMaster,@NewControlledMinion,#minion=self);
         // Break target.
         Send(self,@EnterStateMove);
      }

      Send(self,@ResetBehaviorFlags);

      if poOwner <> $
      {
         Post(poOwner,@SomethingChangedFlags,#what=self);
      }

      return;
   }

   GetLeader()
   {
      return poLeader;
   }

   SetLeader(oLeader=$,report=TRUE,bContracted=FALSE)
   {
      // We don't have a leader thus far.
      if (poLeader = $)
      {
         // New leader provided.
         if (oLeader <> $)
         {
            // Leader already has a mercenary. Return FALSE.
            if Send(oLeader,@GetMercenary) <> $
            {
               return FALSE;
            }
            // Our leader-to-be has a free mercenary spot! Take it and return TRUE.
            else
            {
               if report
               {
                  // Reporting for duty!
                  Send(self,@MercenaryJoinMessage,#what=oLeader,#bContracted=bContracted);
               }

               Send(oLeader,@SetMercenary,#oMercenary=self);
               poLeader = oLeader;

               // This may happen when the player isn't even logged on.
               if poOwner <> $
               {
                  Send(poOwner,@SomethingChangedFlags,#what=self);
               }
            }
         }
         else
         {
            return FALSE;
         }
      }

      // We already have a leader.
      if (poLeader <> $)
      {
         // We no longer follow our leader. Tell the leader and return TRUE.
         if (oLeader = $)
         {
            // SetMercenary called without paramter sets mercenary to nil.
            if report
            {
               // Let the abandoned leader know.
               Send(self,@MercenaryLeaveMessage,#what=poLeader);
            }

            Send(poLeader,@SetMercenary);
            poLeader = $;

            // This may happen when the player isn't even logged on.
            if poOwner <> $
            {
               Send(poOwner,@SomethingChangedFlags,#what=self);
            }
         }
         // We won't take a new leader if we already got one. Return FALSE.
         if (oLeader <> $)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   // It's impolite not to face your leader when addressing him.
   FaceLeader()
   {
      if (poOwner <> $)
         AND (poLeader <> $)
         AND (Send(poLeader,@GetOwner) = poOwner)
      {
         Send(self,@MonsterOrient,#new_row=Send(poLeader,@GetRow),
               #new_col=Send(poLeader,@GetCol),#new_finerow=Send(poLeader,@GetFineRow),
               #new_finecol=Send(poLeader,@GetFineCol),#face_target=TRUE);
      }

      return;
   }

   MercenaryJoinMessage(what=$,bContracted=FALSE)
   {
      if bContracted
      {
         Post(self,@SayToOne,#target=what,#message_rsc=vrMercenaryJoinContracted);
      }
      else if IsClass(self,&Follower) OR NOT Random(0,7)
      {
         Post(self,@SayToOne,#target=what,#message_rsc=vrMercenaryJoin);
      }

      return;
   }

   MercenaryLeaveMessage(what=$)
   {
      if (NOT IsClass(self,&Follower)) AND Random(0,5)
      {
         return;
      }

      Post(self,@SayToOne,#target=what,#message_rsc=vrMercenaryLeave);

      Send(self,@FaceLeader);

      if IsClass(self,&Human)
      {
         Send(self,@DoWave);
      }

      return;
   }

   MercenaryCommand(what=$,message=$)
   {
      //// General Merc Chat Commands
      // Get rid of mercenary
      if StringEqual(message,Lm_mercenary_leave_trigger)
         AND (what = poLeader)
         AND Send(self,@SetLeader)
      {
         Send(what,@MercenarySentAway);

         return TRUE;
      }

      //// Follower chat commands can be found in follower.kod

      return FALSE;
   }

   CanPlayerAdvanceOnMe()
   {
      return (NOT Send(self,@IsIllusion));
   }

   SetIllusion(value = $)
   {
      if value = $
      {
         Debug("SetIllusion called without an argument!");
         value = FALSE;
      }

      pbIllusion = value;

      return;
   }

   SetSummoned(value = $)
   {
      if value = $
      {
         Debug("SetSummoned called without an argument!");
         value = FALSE;
      }

      vbSummoned = value;

      return;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   RemoveSchoolEnchantments(school = $, report=TRUE)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   GetClosestFrightener()
   {
      local iRangeSquared, oTarget, iThisRangeSquared, i, iDistRow, iDistCol,
            oIllusion, oObject, oBodyType;

      if poOwner = $
      {
         return $;
      }

      iRangeSquared = piVisionDistance * piVisionDistance;

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oObject = First(i);

         // Pass if we're looking at ourself here.
         if oObject = self
         {
            continue;
         }

         oBodyType = oObject;
         if IsClass(oObject,&User)
         {
            oIllusion = Send(oObject,@GetIllusionForm);
            if oIllusion <> $
            {
               oBodyType = oIllusion;
            }
         }

         // Check if we are scared of this.
         if NOT Send(self,@IsFrightenedOf,#target=oBodyType)
         {
            continue;
         }

         iDistRow = (piRow * FINENESS + piFine_row)
                     - (Send(oObject,@GetRow) * FINENESS + Send(oObject,@GetFineRow));

         iDistCol = (piCol * FINENESS + piFine_col)
                     - (Send(oObject,@GetCol) * FINENESS + Send(oObject,@GetFineCol));

         iThisRangeSquared = (iDistRow * iDistRow + iDistCol * iDistCol)
                                 / FINENESS_SQUARED;

         if iThisRangeSquared <= iRangeSquared
         {
            iRangeSquared = iThisRangeSquared;
            oTarget = oObject;
         }
      }

      // oTarget = nil if none are in range.
      return oTarget;
   }

   IsFrightenedOf(target = $)
   {
      if vbIsUndead
         AND (poHolySymbolCaster <> $)
         AND (poHolySymbolCaster = target)
      {
         return TRUE;
      }

      return FALSE;
   }

   GetClosestAlly()
   {
      local iRangeSquared, oTarget, iThisRangeSquared, i, iDistRow, iDistCol,
            oIllusion, oObject, oBodyType;

      if poOwner = $
      {
         return $;
      }

      iRangeSquared = piVisionDistance * piVisionDistance;

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oObject = First(i);

         // Pass if we're looking at ourself here.
         if oObject = self
         {
            continue;
         }

         // is what it looks like, an ally?
         oBodyType = oObject;
         if IsClass(oObject,&User)
            AND NOT IsClass(self,&Follower)
         {
            oIllusion = Send(oObject,@GetIllusionForm); 
            if oIllusion <> $
            {
               oBodyType = oIllusion;
            }
         }

         // If not an ally, we don't care.
         if NOT Send(self,@IsAlly,#target=oBodyType)
         {
            continue;
         }

         iDistRow = (piRow * FINENESS + piFine_row)
                     - (Send(oObject,@GetRow) * FINENESS + Send(oObject,@GetFineRow));

         iDistCol = (piCol * FINENESS + piFine_col)
                     - (Send(oObject,@GetCol) * FINENESS + Send(oObject,@GetFineCol));

         iThisRangeSquared = (iDistRow * iDistRow + iDistCol * iDistCol)
                              / FINENESS_SQUARED;

         if iThisRangeSquared <= iRangeSquared
         {
            iRangeSquared = iThisRangeSquared;
            oTarget = oObject;
         }
      }

      // oTarget = nil if none are in range.
      return oTarget;
   }

   GetClosestInjured()
   {
      local iRangeSquared, oTarget, iThisRangeSquared, i, iDistRow, iDistCol,
            oIllusion, oObject, oBodyType;

      if poOwner = $
      {
         return $;
      }

      iRangeSquared = piVisionDistance * piVisionDistance;

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oObject = First(i);

         // Pass if we're looking at ourself here.
         if oObject = self
         {
            continue;
         }

         // is what it looks like, an ally?
         oBodyType = oObject;
         if IsClass(oObject,&User)
            AND NOT IsClass(self,&Follower)
         {
            oIllusion = Send(oObject,@GetIllusionForm); 
            if oIllusion <> $
            {
               oBodyType = oIllusion;
            }
         }

         // If not an ally, we don't care.
         if NOT Send(self,@IsAlly,#target=oBodyType)
         {
            continue;
         }

         // If not injured below 75% of our social rating, we don't care.
         if Send(oObject,@GetExactHealth) > viSocial * Send(oObject,@GetMaxHealth) * 75 / 100
         {
            continue;
         }

         iDistRow = (piRow * FINENESS + piFine_row)
                     - (Send(oObject,@GetRow) * FINENESS + Send(oObject,@GetFineRow));

         iDistCol = (piCol * FINENESS + piFine_col)
                     - (Send(oObject,@GetCol) * FINENESS + Send(oObject,@GetFineCol));

         iThisRangeSquared = (iDistRow * iDistRow + iDistCol * iDistCol)
                              / FINENESS_SQUARED;

         if iThisRangeSquared <= iRangeSquared
         {
            iRangeSquared = iThisRangeSquared;
            oTarget = oObject;
         }
      }

      // oTarget = nil if none are in range.
      return oTarget;
   }

   IsAlly(target=$)
   {
      local oTargetMaster;

      if (target = $)
         OR NOT IsClass(target,&Battler)
      {
         return FALSE;
      }

      if (target = self)
      {
         return TRUE;
      }

      if (poMaster <> $)
      {
         return Send(poMaster,@IsAlly,#target=target);
      }

      if (poApparitionCaster <> $)
      {
         return Send(poApparitionCaster,@IsAlly,#target=target);
      }

      oTargetMaster = Send(target,@GetMaster);

      if (oTargetMaster <> $)
      {
         return Send(self,@IsAlly,#target=oTargetMaster);
      }

      return Send(self,@IsAlliedClass,#what=target);
   }

   IsAlliedClass(what=$)
   {
      // Always allied with our own kind.
      if GetClass(self) = GetClass(what)
      {
         return TRUE;
      }

      return FALSE;
   }

   GetClosestEnemy()
   {
      local iRangeSquared, oTarget, iThisRangeSquared, i, iDistRow, iDistCol,
            oIllusion, oObject, oBodyType;

      if poOwner = $
      {
         return $;
      }

      iRangeSquared = piVisionDistance * piVisionDistance;

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oObject = First(i);

         // We usually don't hold much of a grudge against inanimate objects.
         if (oObject = self) OR (NOT IsClass(oObject,&Battler))
         {
            continue;
         }

         iThisRangeSquared = MAX_KOD_INT;

         // If we have been hurt by the battler, he's on our hitlist, regardless
         // of whether he is an enemy or not.
         if NOT Send(self,@GetHurtMeRecentlyAmount,#who=oObject)
         {
            // We don't care about monsters, unless they are sworn enemies.
            if IsClass(oObject,&Monster) AND NOT Send(self,@IsEnemy,#what=oObject)
            {
               continue;
            }

            // Does it look like an ally?
            oBodyType = oObject;
            if IsClass(oObject,&User)
            {
               oIllusion = Send(oObject,@GetIllusionForm); 
               if oIllusion <> $
               {
                  oBodyType = oIllusion;
               }
            }

            // If it does, we don't care.
            if Send(self,@IsAlly,#target=oBodyType)
            {
               continue;
            }
         }
         // If we have been hurt, we will chase our hurter no matter the distance.
         // Set squared vision distance as our upper boundary.
         else
         {
            iThisRangeSquared = piVisionDistance * piVisionDistance;
         }

         // Looks like we found someone we wouldn't mind clubbing. Check if
         // it is close enough.
         iDistRow = (piRow * FINENESS + piFine_row)
                     - (Send(oObject,@GetRow) * FINENESS + Send(oObject,@GetFineRow));

         iDistCol = (piCol * FINENESS + piFine_col)
                     - (Send(oObject,@GetCol) * FINENESS + Send(oObject,@GetFineCol));

         iThisRangeSquared = Bound((iDistRow * iDistRow + iDistCol * iDistCol)
            / FINENESS_SQUARED,0,iThisRangeSquared);

         if iThisRangeSquared <= iRangeSquared
         {
            iRangeSquared = iThisRangeSquared;
            oTarget = oObject;
         }
      }

      // oTarget = nil if none are in range.
      return oTarget;
   }

   IsEnemy(what = $)
   "Just a dummy. Some mobs may have sworn racial enemies."
   {
      return FALSE;
   }

   GetTopHurter(oExclude=$)
   {
      local oTop, oHurter, oBodyType, iHurt, iTop, i,
         oIllusion, iStealth;

      if poOwner = $
      {
         return $;
      }

      iTop = 0;

      foreach i in plHurtMeRecently
      {
         oHurter = First(i);

         // We usually don't hold much of a grudge against ourselves,
         // inanimate objects, or the dead.
         if (oHurter = oExclude)
            OR (oHurter = self)
            OR (NOT IsClass(oHurter,&Battler))
            OR (Send(oHurter,@GetOwner) = $)
         {
            continue;
         }

         // Hatred is based on damage dealt by the hurter.
         iHurt = Nth(i,2);

         // Does it look like an ally?
         oBodyType = oHurter;
         if IsClass(oHurter,&User)
         {
            oIllusion = Send(oHurter,@GetIllusionForm); 
            if oIllusion <> $
            {
               oBodyType = oIllusion;
            }
         }

         // If it does, cut amount in half.
         if Send(self,@IsAlly,#target=oBodyType)
         {
            iHurt /= 2;
         }

         // If we can't reach our hurter, cut amount in half.
         if NOT Send(self,@CanReach,#what=oHurter,#bRanged=TRUE)
         {
            iHurt /= 2;
         }

         if iHurt > iTop
         {
            iTop = iHurt;
            oTop = oHurter;
         }
      }

      return oTop;
   }

   HealthBelowWimpy()
   {
      // Wimpy of 0 means monster never runs, just fights til the end.
      if viWimpy = 0
      {
         return FALSE;
      }

      // If wimpy is set at 50, monster will flee once his health is at 49% of
      //  max.
      if (piHealth/ piMax_health) < viWimpy
      {
         Send(self,@SetBehaviorFlag,#flag=AI_FLEEING,#value=TRUE);

         return TRUE;
      }

      Send(self,@SetBehaviorFlag,#flag=AI_FLEEING,#value=FALSE);

      return FALSE;
   }

   SetBehaviorFlag(flag=0, value = TRUE)
   {
      if value
      {
         piBehavior |= flag;
      }
      else
      {
         piBehavior &= ~flag;
      }

      return;
   }

   IsWizard()
   {
      return FALSE;
   }

   IsAreaEffect()
   {
      return vbIsAreaEffect;
   }

   GetHatred()
   {
      return piHatred;
   }

   SetHatred(bForce=FALSE,iHatred=0)
   {
      if bForce OR piHatred < iHatred
      {
         piHatred = iHatred;

         return TRUE;
      }

      return FALSE;
   }

   TargetSwitch(what=$, iHatred = 0)
   {
      if what = $
         OR poOwner = $
      {
         Debug("BAD target we're switching to here!");

         return FALSE;
      }

      if IsClass(what,&User)
         AND NOT Send(what,@IsLoggedOn)
      {
         // Trying to switch to someone logged off. Can't do that.
         return FALSE;
      }

      // Apparitions can't switch targets, unless they have a proper master.
      if (poApparitionOriginal <> $
         AND poMaster = $
         AND what <> poApparitionOriginal)
      {
         return FALSE;
      }

      piHatred = iHatred;

      // SetTarget handles the rest.
      Send(self,@SetTarget,#what=what);

      piState &= VSTATE_VALIDITY_MASK;

      // 'lock' sound
      if vrSound_aware <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=vrSound_aware);
      }

      return TRUE;
   }

   SpecialHatredBehavior(what=$)
   "A monster may hate an opponent more under special behaviors, or may "
   "hate certain opponents more.  Use this to check for those special cases."
   "Test case is avar clans fighting in the temple ruins."
   {
      return 0;
   }

   GetMood()
   {
      return piMood;
   }

   // used for library speech/random lib restriction vectors
   GetMoodFlags()
   {
      if piMood < -10
      {
         return LIBRES_MOOD_BAD;
      }

      if piMood > 10
      {
         return LIBRES_MOOD_GOOD;
      }

      return LIBRES_MOOD_NEUTRAL;
   }

   SetMood(new_mood = 0)
   {
      piMood = Bound(new_mood,-100,100);

      return;
   }

   ChangeMood(change = 0)
   {
      piMood = Bound(piMood+change,-100,100);

      return;
   }

   IsInvisible()
   {
      return (Send(self,@GetDrawingEffects) = DRAWFX_INVISIBLE);
   }

   IsShadowForm()
   {
      return (Send(self,@GetDrawingEffects) = DRAWFX_BLACK);
   }

   GetVaultNum()
   {
      return $;
   }

   GetBankNum()
   {
      return $;
   }

   GetIllusionForm()
   {
      return $;
   }

   PrintState()
   "Prints monster state out to the Debug log."
   {
      if (piState & STATE_LIMBO)
      {
         Debug(self,"is in limbo.");
      }

      if (piState & STATE_WAIT)
      {
         Debug(self,"is in wait");
      }

      if (piState & STATE_ENGAGE)
      {
         Debug(self,"is engaging");
      }

      if (piState & STATE_MOVE)
      {
         Debug(self,"is in move");
      }

      if ptBehavior = $
      {
         Debug("Behavior Timer is equal to nil!");

         return;
      }

      Debug("ptBehavior has ",GetTimeRemaining(ptBehavior),"ms left.");

      return;
   }

   PrintBehavior()
   "Prints monster behavior out to the Debug log."
   {
      if (piBehavior & AI_NPC)
      {
         Debug(self,"is in AI_NPC.");
      }

      if (piBehavior & AI_NOMOVE)
      {
         Debug(self,"is in AI_NOMOVE");
      }

      if (piBehavior & AI_MOVE_RANDOM)
      {
         Debug(self,"is in AI_MOVE_RANDOM");
      }

      if (piBehavior & AI_MOVE_OPTIMAL_RANGE)
      {
         Debug(self,"is in AI_MOVE_OPTIMAL_RANGE");
      }

      if (piBehavior & AI_MOVE_FLEE_FRIGHTENERS)
      {
         Debug(self,"is in AI_MOVE_FLEE_FRIGHTENERS");
      }

      if (piBehavior & AI_MOVE_WALKTHROUGH_WALLS)
      {
         Debug(self,"is in AI_MOVE_WALKTHROUGH_WALLS");
      }

      if (piBehavior & AI_MOVE_WHEN_ALONE)
      {
         Debug(self,"is in AI_MOVE_WHEN_ALONE.");
      }

      if (piBehavior & AI_CAN_PATROL)
      {
         Debug(self,"is in AI_CAN_PATROL");
      }

      if (piBehavior & AI_HAS_TARGET_LOCATION)
      {
         Debug(self,"is in AI_HAS_TARGET_LOCATION");
      }

      if (piBehavior & AI_LOOPING_PATROL)
      {
         Debug(self,"is in AI_LOOPING_PATROL");
      }

      if (piBehavior & AI_NOFIGHT)
      {
         Debug(self,"is in AI_NOFIGHT.");
      }

      if (piBehavior & AI_FIGHT_AGGRESSIVE)
      {
         Debug(self,"is in AI_FIGHT_AGGRESSIVE");
      }

      if (piBehavior & AI_FLEEING)
      {
         Debug(self,"is in AI_FLEEING");
      }

      if (piBehavior & AI_RALLY)
      {
         Debug(self,"is in AI_RALLY");
      }

      if (piBehavior & AI_FIGHT_KARMA_AGGRESSIVE)
      {
         Debug(self,"is in AI_FIGHT_KARMA_AGGRESSIVE");
      }

      if (piBehavior & AI_FIGHT_MURDERERS)
      {
         Debug(self,"is in AI_FIGHT_MURDERERS");
      }

      if (piBehavior & AI_FIGHT_NEWBIESAFE)
      {
         Debug(self,"is in AI_FIGHT_NEWBIESAFE");
      }

      if (piBehavior & AI_FIGHT_SINGLEMINDED)
      {
         Debug(self,"is in AI_FIGHT_SINGLEMINDED");
      }

      if (piBehavior & AI_FIGHT_THROUGH_WALLS)
      {
         Debug(self,"is in AI_FIGHT_THROUGH_WALLS");
      }

      if (piBehavior & AI_FIGHT_LASHOUT)
      {
         Debug(self,"is in AI_FIGHT_LASHOUT");
      }

      if (piBehavior & AI_FIGHT_HYPERAGGRESSIVE)
      {
         Debug(self,"is in AI_FIGHT_HYPERAGGRESSIVE");
      }

      if (piBehavior & AI_FIGHT_SWITCHALOT)
      {
         Debug(self,"is in AI_FIGHT_SWITCHALOT");
      }

      if (piBehavior & AI_CORNERED)
      {
         Debug(self,"is in AI_CORNERED");
      }

      if (piBehavior & AI_SOCIALIZER)
      {
         Debug(self,"is in AI_SOCIALIZER");
      }

      if (piBehavior & AI_STROLLING)
      {
         Debug(self,"is in AI_STROLLING");
      }

      return;
   }

   InCombat()
   {
      return (piState & STATE_ENGAGE);
   }

   GetFaction()
   {
      return viFaction;
   }

   AddLearnAdvice()
   {
      local i, lFinal, lDialogue, oAbility, sid, oName;

      // Go through the monster's sell list.  If the monster has a spell or 
      //  skill to sell, add it to their dialogue.

      if NOT (viAttributes & MOB_TEACHER)
      {
         return;
      }

      if plFor_sale = $ OR Length(plFor_sale) < 3
      {
         return;
      }

      foreach sid in nth(plFor_sale,2)
      {
         // skills first
         oAbility = Send(SYS,@FindSkillByNum,#num=sid);
         if oAbility <> $
         {
            oName = Send(oAbility,@GetName);
         }

         lDialogue = Cons([[oName],0,[LIBACT_LEARN, sid, TRUE]],lDialogue);
      }

      foreach sid in nth(plFor_sale,3)
      {
         // spells next
         oAbility = Send(SYS,@FindSpellByNum,#num=sid);
         if oAbility <> $
         {
            oName = Send(oAbility,@GetName);
         }

         lDialogue = Cons([[oName],0,[LIBACT_LEARN, sid, FALSE]],lDialogue);
      }

      lFinal = [ GetClass(self), lDialogue ];

      Send(Send(SYS,@GetLibrary),@AppendSpeechLibrary,#lDialogue=lFinal);

      return;
   }

   GetBrain()
   {
      return poBrain;
   }

   IsUndead()
   {
      return vbIsUndead;
   }

   TurnedBy(who = $)
   {
      if who = $
      {
         Debug("Turned by $.");

         return;
      }

      if NOT vbIsUndead
      {
         Debug("Somehow turned a monster that isn't undead.");

         return;
      }

      poHolySymbolCaster = who;

      if ptUnturn <> $
      {
         DeleteTimer(ptUnturn);
         ptUnturn = $;
      }

      ptUnturn = CreateTimer(self,@UnTurn,TURN_TIME/viDifficulty);

      return;
   }

   UnTurn()
   {
      ptUnturn = $;
      poHolySymbolCaster = $;

      return;
   }

   DMCanArmageddon()
   {
      return TRUE;
   }

   CanBeSilenced()
   "Can this monster be silenced by the room enchantment?"
   {
      return TRUE;
   }

   RewardSweep(who = $)
   {
      local oMoney,oRoom;

      oMoney=Create(&Money,#number=Random(20,120));
      oRoom = Send(self,@GetOwner);

      if piSweepCounter < 5
      {
         Post(oRoom,@SomeoneSaid,#what=self,#string=Monster_Sweep_Reward,
              #type=SAY_RESOURCE,#parm1=Send(who,@GetDef),
              #parm2=Send(who,@GetName));

         ++piSweepCounter;

         if Send(who,@ReqNewHold,#what=oMoney)
         {
            Send(who,@NewHold,#what=oMoney);
            Send(Send(SYS,@GetStatistics),@MoneyCreated,
                  #amount=Send(oMoney,@GetNumber));
         }
      }

      return;
   }

   GetActions()
   {
      return plActions;
   }

   GetSpellList()
   {
      local i, lSpells;

      foreach i in plActions
      {
         if First(i) < SKID_MINIMUM
         {
            lSpells = Cons(First(i),lSpells);
         }
      }

      return lSpells;
   }

   GetBaseSpellPower()
   {
      return piSpellPower;
   }

   GetBaseResistances()
   {
      return plResistances;
   }

   GetBoostedLevel()
   {
      return piBoostedLevel;
   }

   // GainLight and LoseLight here so (some) mobs can use touch spells.
   GainLight()
   {
      return 0;
   }

   LoseLight()
   {
      return 0;
   }

   PrintInfo()
   {
      local i, iTresLen, lTresList, oItem, oTresType;

      ClearTempString();

      oTresType = Send(SYS,@FindTreasureByNum,#num=Send(self,@GetTreasureType));

      if (oTresType <> $)
      {
         lTresList = Send(oTresType,@GetTreasureList);
      }

      iTresLen = Length(lTresList);

      if (iTresLen > 0)
      {
         AppendTempString(", Treasure: ");
      }
      else
      {
         AppendTempString(", No Treasure.");
      }

      foreach i in lTresList
      {
         oItem = Send(SYS,@FindTemplateItemByClass,#cClass=First(i));
         if (oItem = $)
         {
            continue;
         }

         AppendTempString(Send(oItem,@GetTrueName));
         AppendTempString(" ");
         AppendTempString(Nth(i,2));
         if (--iTresLen > 0)
         {
            AppendTempString("\%, ");
         }
         else
         {
            AppendTempString("\%");
         }
      }

      GodLog(Send(self,@GetTrueName)," level: ",viLevel,", karma: ",viKarma,
         ", speed: ",piSpeed, GetTempString());

      return;
   }

   PrintSellList()
   "Prints out all the items (not spells/skills) for sale for this mob, "
   "including any conditional sale items (with prices)."
   {
      local i, iPrice;

      if (plFor_sale = $
         OR First(plFor_sale) = $)
      {
         return;
      }

      GodLog("NPC: ",Send(self,@GetName));

      foreach i in First(plFor_sale)
      {
         iPrice = Send(i,@GetInitValue) * (100 + 20 * viMerchant_markup) / 100;
         GodLog("Item: ",Send(i,@GetName),", Price: ",iPrice);
      }

      Send(Send(SYS,@GetLibrary),@PrintMobConditional,#mob=self);

      return;
   }

   PrintRoom()
   "Prints out the name of the mob and the room it is in."
   {
      if (poOwner = $)
      {
         return;
      }

      GodLog("NPC: ",Send(self,@GetName),", Map: ",Send(poOwner,@GetName));

      return;
   }

   DeathOverTime()
   "Monster is dying to damage over time."
   {
      local iStrength, use_weapon, oKiller, i, each_obj;

      // The strength of the DoT. We are looking at
      // negative values here.
      iStrength = 0;

      // The source of the dot as well as the associated spell.
      // If no source/spell have been associated with the dot,
      // 0 - not nil - is passed.
      oKiller = 0;
      use_weapon = 0;

      // Let's check 'what' pained the monster most.
      foreach i in Send(self,@GetOverTimeEffects)
      {
         if Nth(i,3) < iStrength
            AND Nth(i,10) = FALSE         // Illusions don't count.
         {
            oKiller = Nth(i,6);
            use_weapon = Nth(i,5);
            iStrength = Nth(i,3);
         }
      }

      // Looks like we only had a mild case of death after all...
      if iStrength = 0
      {
         return;
      }

      // Convert 0 to regular nil for further processing.
      // To-do: Check for more elegant solution.
      if use_weapon = 0
      {
         use_weapon = $;
      }

      if oKiller = 0
      {
         oKiller = $;
      }

      foreach i in Send(poOwner,@GetHolderActive)
      {
         each_obj = First(i);
         if IsClass(each_obj,&User)
            AND each_obj <> oKiller
            AND Send(each_obj,@GetKillTarget) = self
         {
            Send(each_obj,@MsgSendUser,#what=self,
                 #message_rsc=vrParty_monster_died_to_dot,
                 #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName),
                 #parm3=Send(self,@GetHisHer));
         }
      }

      if oKiller <> $
      {
         Send(oKiller,@KilledSomething,#what=self,#use_weapon=use_weapon);
      }
      else
      {
         Send(self,@KilledSomething,#what=self,#use_weapon=use_weapon);
      }

      return;
   }

   ZeroVigor()
   "Uh oh! Are we in trouble?"
   {
      Send(self,@EnterStateRest,#target=poTarget,
            #delay=Bound(10000-100*piStamina,5000,10000));
      Send(self,@GainVigor,#amount=piVigor_rest_threshold);

      Post(poOwner,@SomeoneSaid,#what=self,#string=Lm_monster_winded,
            #type=SAY_MESSAGE,#parm1=Send(self,@GetCapDef),
            #parm2=Send(self,@GetName),#parm3=Send(self,@GetHisHer));

      return;
   }

   // This message is used to modify responsiveness of resource
   // regeneration for monsters. Tick duration and restored resource
   // amount are scaled by a percentage.
   GetTickFactor(i=$)
   "Time ticks differently for monsters."
   {
      return i * TICK_FACTOR_MONSTER / 100;
   }

   CanPoison()
   {
      if (vbCanPoison)
      {
         // Battler handles max poison enchantments,
         // only for mobs that can be poisoned.
         propagate;
      }

      return FALSE;
   }

   CanBleed()
   {
      return vbCanBleed;
   }

   CanSiphon()
   {
      return vbCanSiphon;
   }

   CanFatigue()
   {
      return vbCanFatigue;
   }

   CanBurn()
   {
      return vbCanBurn;
   }

   GetProjectileSpeed()
   {
      return viProjectileSpeed;
   }

   GetProjectileIcon()
   {
      return vrProjectile_icon;
   }

   SendProjectileAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE, 4,175, 2,1, 2,4);

      return;
   }

   GetProjectileLightFlags()
   {
      return LIGHT_FLAG_NONE;
   }

   SetTarget(what=$)
   {
      // Sanity checks: If we drift in the void or our designated
      // target is the same as our current target, skip.
      if (poOwner <> $) AND (poTarget <> what)
      {
         // We have had a different target before. If that different
         // target was a User, subtract us from his chaser log.
         if (poTarget <> $)
            AND IsClass(poTarget,&User)
         {
            Send(poTarget,@SubtractFromMonsterChasers,#level=viLevel);
         }

         // We have a new target now. If that new target is a User,
         // we have to add ourselves to his chaser list. Our new
         // target will automatically be in the same room, unless
         // something has gone horribly wrong in the calls before.
         if (what <> $)
            AND IsClass(what,&User)
         {
            Send(what,@AddToMonsterChasers,#level=viLevel);
         }

         // Set the new target as our current target.
         poTarget = what;

         // Notify the room that we changed our target. This allows
         // the Users' minimap dots to update accordingly.
         Send(poOwner,@SomethingChangedFlags,#what=self);
      }

      return;
   }

   IsPacified()
   {
      return (piState & STATE_WAIT);
   }

   GetAggroRange(what=$,bStrolling=FALSE)
   {
      local iDifference, iRange;

      if what = $
      {
         return 0;
      }

      // Our base range is our vision.
      iRange = Send(self,@GetVisionDistance) * FINENESS;

      iRange = iRange * Send(SETTINGS_OBJECT,@GetVisionModifier) / 100;

      // Factor in stealth.
      iRange = (iRange * (300 - Send(what,@GetStealth,#what=self))) / 300;

      // A high level difference between our target and us makes it less
      // likely for us to attack them, since we are scared / don't care.
      if IsClass(what,&Player)
      {
         iDifference = Abs(Send(what,@GetMaxHealth) - Send(self,@GetLevel));
      }
      else
      {
         iDifference = Abs(Send(what,@GetLevel) - Send(self,@GetLevel));
      }

      iDifference = iDifference * Send(SETTINGS_OBJECT,@GetAggroDeltaFactor) / 100;

      iDifference = Bound(iDifference,0,100);

      // Factor in level difference calculated earlier.
      iRange = (iRange * (100 - iDifference)) / 100;

      // We are much more likely to stop chasing when we can't
      // see our target anymore.
      if NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         iRange /= 10;
      }

      // All range checks are handled squared.
      return iRange * iRange;
   }

   GetSocial()
   {
      return viSocial;
   }

   // Allow monster to take a step away from the target if too close.
   SideStepCheck(distance=0)
   {
      if Bound(4000 - distance,0,$)
      {
         // Take a step back unless we are directly on top of our target.
         Send(self,@RandomCombatMove,#direction=-distance);
      }

      return;
   }

   // Some mobs may have a special trick up their sleeves.
   DoFleeingRoutine()
   {
      return;
   }

   // Causes mobs to become docile.
   StartLullaby(iSpellPower=0)
   {
      // Minions owned by players excluded.
      if (poLeader <> $
         OR Send(self,@IsOwnedByPlayer))
      {
         return;
      }

      if NOT (piBehavior & AI_FIGHT_HYPERAGGRESSIVE)
      {
         piBehavior &= ~AI_FIGHT_AGGRESSIVE;
         piBehavior &= ~AI_FIGHT_KARMA_AGGRESSIVE;
      }

      // Max spell power allows aggro wipe on monsters
      // up to level 147. But only if they haven't been hurt.
      // DMs can sleep anything.
      if iSpellPower = $
         OR ((iSpellPower * 3 / 2 > viLevel)
            AND plHurtMeRecently = $)
      {
         Send(self,@EnterStateWait,#delay=1000);
      }

      return;
   }

   // Restores aggressive behavior if needed.
   EndLullaby(iSpellPower=0)
   {
      if (viDefault_behavior & AI_FIGHT_AGGRESSIVE)
      {
         piBehavior |= AI_FIGHT_AGGRESSIVE;
      }

      if (viDefault_behavior & AI_FIGHT_KARMA_AGGRESSIVE)
      {
         piBehavior |= AI_FIGHT_KARMA_AGGRESSIVE;
      }

      return;
   }

   MemoryWipe(who=$,iMemoryWipe=FALSE,bFull=FALSE)
   {
      local bWipe, i;

      bWipe = FALSE;

      // If our memory is wiped, we forget about the one
      // who put us on timeout.
      if (Random(1,100) <= iMemoryWipe) OR bFull
      {
         if plHurtMeRecently <> $
         {
            foreach i in plHurtMeRecently
            {
               if (First(i) = who) OR bFull
               {
                  if IsTimer(Nth(i,3))
                  {
                     DeleteTimer(Nth(i,3));
                  }
                  SetFirst(i,$);
                  SetNth(i,3,$);
                  plHurtMeRecently = DelListElem(plHurtMeRecently,i);
                  bWipe = TRUE;
               }
            }
         }
      }

      return bWipe;
   }

   GetStealth(what=$)
   {
      local iStealth, iLight;

      if (what = $) OR (poOwner = $)
      {
         return FALSE;
      }

      // Stealth is primarily based on our agility and intellect.
      iStealth = 2 * Send(self,@GetAgility) + Send(self,@GetIntellect);

      // Sneaking/strolling increases stealth.
      if (piBehavior & AI_STROLLING)
      {
         iStealth += 100;
      }

      // Invisibility grants greatly increased stealth.
      if Send(self,@IsInvisible)
      {
         iStealth += 200;
      }

      // Shadowform grants slightly increased stealth.
      if Send(self,@IsShadowForm)
      {
         iStealth += 50;
      }

      // A blind target has a very hard time spotting enemies.
      if Send(what,@IsEnchanted,#byClass=&Blind)
         OR Send(what,@IsEnchanted,#byClass=&Dazzle)
      {
         iStealth += 200;
      }

      iLight = Send(poOwner,@GetRoomLight) + Send(what,@GetLightLevel);

      iStealth += Bound(155 - iLight,-100,150);

      return Bound(iStealth,0,300);
   }

   GetLightLevel()
   {
      return viNightVision;
   }

   GetSpellPower()
   {
      return piSpellPower;
   }

   StartResting()
   {
      piBattlerFlags |= BFLAG_RESTING;
      Send(self,@EnterStateWait,#delay=$);
      Send(self,@NewVigor);

      return;
   }

   StopResting()
   {
      piBattlerFlags &= ~BFLAG_RESTING;
      Send(self,@WaitTimer);
      Send(self,@NewVigor);

      return;
   }

   CheckMonsterBehavior(flag=$)
   {
      return piBehavior & flag;
   }

   HowCloseToCommander()
   {
      return 2;
   }

   SetSpawnLoc(iRow=0,iCol=0,iIndex=0)
   {
      if (iRow <> 0) OR (iCol <> 0)
      {
         piSpawnLoc = iIndex*1000000 + iRow*1000 + iCol;
      }

      return;
   }

   GetSpawnLoc()
   {
      return piSpawnLoc;
   }

   GetSpawnIndex()
   {
      return piSpawnLoc/1000000;
   }

   GetSpawnRow()
   {
      return (piSpawnLoc/1000)%1000;
   }

   GetSpawnCol()
   {
      return piSpawnLoc%1000;
   }

   MonsterLeashReset()
   {
      local i, oHurter, bMinion;

      bMinion = (poMaster <> $);

      if NOT bMinion
      {
         Send(poTarget,@MsgSendUser,#message_rsc=monster_leash_reset,
            #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName));
      }

      foreach i in plHurtMeRecently
      {
         oHurter = First(i);

         // Tell all hurters if they haven't already been told, because
         // they were our target.
         if (oHurter <> poTarget) AND NOT bMinion
         {
            Send(oHurter,@MsgSendUser,#message_rsc=monster_leash_reset,
               #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName));
         }

         // Proceed to delete the list entry.
         if IsTimer(Nth(i,3))
         {
            DeleteTimer(Nth(i,3));
         }
         SetFirst(i,$);
         SetNth(i,3,$);

         plHurtMeRecently = DelListElem(plHurtMeRecently,i);
      }

      // Reset our resources...
      piHealth = piMax_health * 100;
      piMana = piMax_mana * 100;
      piVigor = piMax_vigor * 100;

      // Cancel maintained spells, such as reflections...
      Send(self,@CancelMaintainedSpells);

      // Delete any enchantments...
      Send(self,@RemoveAllEnchantments);

      // ...or over time effects the monster may have.
      Send(self,@DeleteAllOverTimeEffects);

      // Grant temporary NPC status while returning to spawn.
      Send(self,@SetBehaviorFlag,#flag=AI_NPC,#value=TRUE);
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_WALKTHROUGH_WALLS,#value=TRUE);
      Send(poOwner,@SomethingChangedFlags,#what=self);

      // Start moving...
      Send(self,@EnterStateMove);

      return;
   }

   MonsterEndCombat()
   {
      local i, oHurter, bMinion;

      // Clear our hurter list...
      foreach i in plHurtMeRecently
      {
         if IsTimer(Nth(i,3))
         {
            DeleteTimer(Nth(i,3));
         }
         SetFirst(i,$);
         SetNth(i,3,$);
         plHurtMeRecently = DelListElem(plHurtMeRecently,i);
      }

      // Start moving...
      Send(self,@EnterStateMove);

      return;
   }

   CountsAsMonster()
   {
      return TRUE;
   }

   CountsAsHero()
   {
      return FALSE;
   }

   IsEventSpawn()
   {
      return pbEvent;
   }

   IsLegitimateSpawn()
   {
      return NOT (pbIllusion OR vbSummoned OR pbEvent);
   }

   GetTriggerObject()
   {
      return poObject;
   }
   
   SetTriggerObject(oObject=$)
   {
      poObject = oObject;
      return;
   }

   // Called when the mercenary is injured beyond a threshold.
   MercenaryInjured(iThreshold=$)
   {
      return;
   }

   // Called when the mercenary recovers beyond a threshold.
   MercenaryRecovered(iThreshold=$)
   {
      return;
   }

   GetBonusXP()
   {
      return viBonusXP;
   }

   GetBonusTP()
   {
      return viBonusTP;
   }

   IsArenaMonster()
   {
      return TRUE;
   }


end
////////////////////////////////////////////////////////////////////////////////
